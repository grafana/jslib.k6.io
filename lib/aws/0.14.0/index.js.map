{
  "version": 3,
  "sources": ["../src/internal/error.ts", "../src/internal/signature.ts", "../src/internal/constants.ts", "../src/internal/http.ts", "../src/internal/utils.ts", "../src/internal/endpoint.ts", "../src/internal/config.ts", "../src/internal/kms.ts", "../src/internal/client.ts", "../src/internal/s3.ts", "../src/internal/secrets-manager.ts", "../src/internal/ssm.ts", "../src/internal/sqs.ts", "../src/internal/kinesis.ts", "../src/internal/event-bridge.ts", "../src/internal/lambda.ts"],
  "sourcesContent": ["import { JSONObject } from \"./json.ts\";\nimport { parseHTML } from \"k6/html\";\nimport { Response } from \"k6/http\";\n\n/**\n * Base class to derive errors from\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class AWSError extends Error {\n  /**\n   * Error code issued by the service (if any)\n   */\n  code?: string;\n\n  /**\n   * Create an AWSError\n   *\n   * @param {string} message - A longer human readable error message.\n   * @param {string?} code - A unique short code representing the error that was emitted\n   */\n  constructor(message: string, code?: string) {\n    super(message);\n    this.name = \"AWSError\";\n    this.code = code;\n  }\n\n  /**\n   * Parse an AWSError from an XML document\n   *\n   * @param  {string} xmlDocument - Serialized XML document to parse the error from\n   * @returns {AWSError} - The parsed AWSError object\n   */\n  static parseXML(xmlDocument: string): AWSError {\n    const doc = parseHTML(xmlDocument);\n    return new AWSError(doc.find(\"Message\").text(), doc.find(\"Code\").text());\n  }\n\n  /**\n   * Parse an AWSError from a Response object\n   *\n   * @param {Response} response - The Response object to parse the error from\n   * @returns {AWSError} - The parsed AWSError object\n   */\n  static parse(response: Response): AWSError {\n    if (response.headers[\"Content-Type\"] === \"application/json\") {\n      const error = (response.json() as JSONObject) || {};\n      const message = error.Message ||\n        error.message ||\n        error.__type ||\n        \"An error occurred on the server side\";\n      const code = response.headers[\"X-Amzn-Errortype\"] || error.__type;\n      return new AWSError(message as string, code as string);\n    } else {\n      return AWSError.parseXML(response.body as string);\n    }\n  }\n}\n\n/**\n * Base class for network errors as produced by k6.\n *\n * Based on the network error handling in k6, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n *\n * @typeparam N - The name of the network error\n * @typeparam K - The kind of the network error\n */\nexport class NetworkError<N extends NetworkErrorName, K extends ErrorKind>\n  extends Error {\n  code: K;\n  override name: N;\n\n  /**\n   * Create a NetworkError\n   *\n   * @param {N} name - The name of the network error\n   * @param {K} code - The kind of the network error\n   */\n  constructor(name: N, code: K) {\n    super(ErrorMessages[code] || \"An unknown error occurred\");\n    this.name = name;\n    this.code = code;\n  }\n}\n\n/**\n * Represents a general network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nexport class GeneralError\n  extends NetworkError<\"GeneralError\", GeneralErrorKind> {\n  /**\n   * Create a GeneralError\n   *\n   * @param {GeneralErrorKind} code - The kind of the general error\n   */\n  constructor(code: GeneralErrorKind) {\n    super(\"GeneralError\", code);\n  }\n}\n\n/**\n * Represents a DNS-related network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nexport class DNSError extends NetworkError<\"DNSError\", DNSErrorKind> {\n  /**\n   * Create a DNSError\n   *\n   * @param {DNSErrorKind} code - The kind of the DNS error\n   */\n  constructor(code: DNSErrorKind) {\n    super(\"DNSError\", code);\n  }\n}\n\n/**\n * Represents a TCP-related network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nexport class TCPError extends NetworkError<\"TCPError\", TCPErrorKind> {\n  /**\n   * Create a TCPError\n   *\n   * @param {TCPErrorKind} code - The kind of the TCP error\n   */\n  constructor(code: TCPErrorKind) {\n    super(\"TCPError\", code);\n  }\n}\n\n/**\n * Represents a TLS-related network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nexport class TLSError extends NetworkError<\"TLSError\", TLSErrorKind> {\n  /**\n   * Create a TLSError\n   *\n   * @param {TLSErrorKind} code - The kind of the TLS error\n   */\n  constructor(code: TLSErrorKind) {\n    super(\"TLSError\", code);\n  }\n}\n\n/**\n * Represents an HTTP/2-related network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nexport class HTTP2Error extends NetworkError<\"HTTP2Error\", HTTP2ErrorKind> {\n  /**\n   * Create an HTTP2Error\n   *\n   * @param {HTTP2ErrorKind} code - The kind of the HTTP/2 error\n   */\n  constructor(code: HTTP2ErrorKind) {\n    super(\"HTTP2Error\", code);\n  }\n}\n\n/**\n * Represents the name of a network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\ntype NetworkErrorName =\n  | \"GeneralError\"\n  | \"DNSError\"\n  | \"TCPError\"\n  | \"TLSError\"\n  | \"HTTP2Error\";\n\n/**\n * Represents the kind of a network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\ntype ErrorKind =\n  | GeneralErrorKind\n  | DNSErrorKind\n  | TCPErrorKind\n  | TLSErrorKind\n  | HTTP2ErrorKind;\n\n/**\n * Represents the kind of a general network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nexport enum GeneralErrorKind {\n  GenericError = 1000,\n  NonTCPNetworkError = 1010,\n  InvalidURL = 1020,\n  HTTPRequestTimeout = 1050,\n}\n\n/**\n * Represents the kind of a DNS-related network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nexport enum DNSErrorKind {\n  GenericDNSError = 1100,\n  NoIPFound = 1101,\n  BlacklistedIP = 1110,\n  BlacklistedHostname = 1111,\n}\n\n/**\n * Represents the kind of a TCP-related network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nexport enum TCPErrorKind {\n  GenericTCPError = 1200,\n  BrokenPipeOnWrite = 1201,\n  UnknownTCPError = 1202,\n  GeneralTCPDialError = 1210,\n  DialTimeoutError = 1211,\n  DialConnectionRefused = 1212,\n  DialUnknownError = 1213,\n  ResetByPeer = 1220,\n}\n\n/**\n * Represents the kind of a TLS-related network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nexport enum TLSErrorKind {\n  GeneralTLSError = 1300,\n  UnknownAuthority = 1310,\n  CertificateHostnameMismatch = 1311,\n}\n\n/**\n * Represents the kind of an HTTP/2-related network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nexport enum HTTP2ErrorKind {\n  GenericHTTP2Error = 1600,\n  GeneralHTTP2GoAwayError = 1610,\n}\n\n/**\n * Error messages for each kind of network error, as described in:\n * https://grafana.com/docs/k6/latest/javascript-api/error-codes/\n */\nconst ErrorMessages: { [key in ErrorKind]: string } = {\n  [GeneralErrorKind.GenericError]:\n    \"A generic error that isn\u2019t any of the ones listed below\",\n  [GeneralErrorKind.NonTCPNetworkError]:\n    \"A non-TCP network error - this is a placeholder and there is no error currently known to trigger it\",\n  [GeneralErrorKind.InvalidURL]: \"An invalid URL was specified\",\n  [GeneralErrorKind.HTTPRequestTimeout]: \"The HTTP request has timed out\",\n  [DNSErrorKind.GenericDNSError]:\n    \"A generic DNS error that isn\u2019t any of the ones listed below\",\n  [DNSErrorKind.NoIPFound]: \"No IP for the provided host was found\",\n  [DNSErrorKind.BlacklistedIP]:\n    \"Blacklisted IP was resolved or a connection to such was tried to be established\",\n  [DNSErrorKind.BlacklistedHostname]:\n    \"Blacklisted hostname using The Block Hostnames option\",\n  [TCPErrorKind.GenericTCPError]:\n    \"A generic TCP error that isn\u2019t any of the ones listed below\",\n  [TCPErrorKind.BrokenPipeOnWrite]:\n    \"A \u201Cbroken pipe\u201D on write - the other side has likely closed the connection\",\n  [TCPErrorKind.UnknownTCPError]:\n    \"An unknown TCP error - We got an error that we don\u2019t recognize but it is from the operating system and has errno set on it. The message in error includes the operation(write,read) and the errno, the OS, and the original message of the error\",\n  [TCPErrorKind.GeneralTCPDialError]: \"General TCP dial error\",\n  [TCPErrorKind.DialTimeoutError]:\n    \"Dial timeout error - the timeout for the dial was reached\",\n  [TCPErrorKind.DialConnectionRefused]:\n    \"Dial connection refused - the connection was refused by the other party on dial\",\n  [TCPErrorKind.DialUnknownError]: \"Dial unknown error\",\n  [TCPErrorKind.ResetByPeer]:\n    \"Reset by peer - the connection was reset by the other party, most likely a server\",\n  [TLSErrorKind.GeneralTLSError]: \"General TLS error\",\n  [TLSErrorKind.UnknownAuthority]:\n    \"Unknown authority - the certificate issuer is unknown\",\n  [TLSErrorKind.CertificateHostnameMismatch]:\n    \"The certificate doesn\u2019t match the hostname\",\n  [HTTP2ErrorKind.GenericHTTP2Error]:\n    \"A generic HTTP/2 error that isn\u2019t any of the ones listed below\",\n  [HTTP2ErrorKind.GeneralHTTP2GoAwayError]: \"A general HTTP/2 GoAway error\",\n};\n", "import crypto from \"k6/crypto\";\nimport { bytes } from \"k6\";\n\nimport * as constants from \"./constants.ts\";\nimport { AWSError } from \"./error.ts\";\nimport {\n  hasHeader,\n  HTTPHeaderBag,\n  HTTPRequest,\n  QueryParameterBag,\n  SignedHTTPRequest,\n} from \"./http.ts\";\nimport { isArrayBuffer } from \"./utils.ts\";\n\n/**\n * SignatureV4 can be used to sign HTTP requests and presign URLs using the AWS Signature\n * Version 4 signing process.\n *\n * It offers two signing methods:\n * - sign: signs the request headers and payload\n * - presign: returns a presigned (authorization information contained in the query string) URL\n *\n * @see https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */\nexport class SignatureV4 {\n  /**\n   * The name of the service to sign for.\n   */\n  private readonly service: string;\n\n  /**\n   * The name of the region to sign for.\n   */\n  private readonly region: string;\n\n  /**\n   * The credentials with which the request should be signed.\n   */\n  private readonly credentials: Credentials;\n\n  /**\n   * Whether to uri-escape the request URI path as part of computing the\n   * canonical request string. This is required for every AWS service, except\n   * Amazon S3, as of late 2017.\n   *\n   * @default [true]\n   */\n  private readonly uriEscapePath: boolean;\n\n  /**\n   * Whether to calculate a checksum of the request body and include it as\n   * either a request header (when signing) or as a query string parameter\n   * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n   * every other AWS service as of late 2017.\n   *\n   * @default [true]\n   */\n  private readonly applyChecksum: boolean;\n\n  // TODO: uriEscapePath and applyChecksum should not be present in the constructor\n  constructor({\n    service,\n    region,\n    credentials,\n    uriEscapePath,\n    applyChecksum,\n  }: SignatureV4Options) {\n    this.service = service;\n    this.region = region;\n    this.credentials = credentials;\n    this.uriEscapePath = typeof uriEscapePath === \"boolean\"\n      ? uriEscapePath\n      : true;\n    this.applyChecksum = typeof applyChecksum === \"boolean\"\n      ? applyChecksum\n      : true;\n  }\n\n  /**\n   * Includes AWS v4 signing information to the provided HTTP request.\n   *\n   * This method adds an Authorization header to the request, containing\n   * the signature and other signing information. It also returns a preformatted\n   * URL that can be used to make the k6 http request.\n   *\n   * This method mutates the request object.\n   *\n   * @param request {HTTPRequest} The request to sign.\n   * @param options {Partial<RequestSigningOptions>} Options for signing the request.\n   * @returns {SignedHTTPRequest} The signed request.\n   */\n  sign(\n    request: HTTPRequest,\n    options: Partial<RequestSigningOptions> = {},\n  ): SignedHTTPRequest {\n    // Set default values for options which are not provided by the user.\n    const defaultOptions = {\n      signingDate: new Date(),\n      unsignableHeaders: new Set<string>(),\n      signableHeaders: new Set<string>(),\n    };\n\n    // Merge default options with the ones maybe provided by the user.\n    const finalOptions = { ...defaultOptions, ...options };\n\n    const { longDate, shortDate }: DateInfo = formatDate(\n      finalOptions.signingDate,\n    );\n    const service = finalOptions.signingService || this.service;\n    const region = finalOptions.signingRegion || this.region;\n    const scope =\n      `${shortDate}/${region}/${service}/${constants.KEY_TYPE_IDENTIFIER}`;\n\n    // Required by the specification:\n    //   \"For HTTP/1.1 requests, you must include the host header at a minimum.\n    //   Standard headers like content-type are optional.\n    //   For HTTP/2 requests, you must include the :authority header instead of\n    //   the host header. Different services might require other headers.\"\n    if (!request.headers[constants.HOST_HEADER]) {\n      request.headers[constants.HOST_HEADER] = request.endpoint.hostname;\n    }\n\n    // Filter out headers that will be generated and managed by the signing process.\n    // If the user provide any of those as part of the HTTPRequest's headers, they\n    // will be ignored.\n    for (const headerName of Object.keys(request.headers)) {\n      if (constants.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {\n        delete request.headers[headerName];\n      }\n    }\n\n    request.headers[constants.AMZ_DATE_HEADER] = longDate;\n    if (this.credentials.sessionToken) {\n      request.headers[constants.AMZ_TOKEN_HEADER] =\n        this.credentials.sessionToken;\n    }\n\n    // If the request body is a typed array, we need to convert it to a buffer\n    // so that we can calculate the checksum.\n    if (ArrayBuffer.isView(request.body)) {\n      request.body = request.body.buffer;\n    }\n\n    // Ensure we avoid passing undefined to the crypto hash function.\n    if (!request.body) {\n      request.body = \"\";\n    }\n\n    const payloadHash = this.computePayloadHash(request);\n    if (\n      !hasHeader(constants.AMZ_CONTENT_SHA256_HEADER, request.headers) &&\n      this.applyChecksum\n    ) {\n      request.headers[constants.AMZ_CONTENT_SHA256_HEADER] = payloadHash;\n    }\n\n    const canonicalHeaders = this.computeCanonicalHeaders(\n      request,\n      finalOptions.unsignableHeaders,\n      finalOptions.signableHeaders,\n    );\n    const signature = this.calculateSignature(\n      longDate,\n      scope,\n      this.deriveSigningKey(this.credentials, service, region, shortDate),\n      this.createCanonicalRequest(request, canonicalHeaders, payloadHash),\n    );\n\n    /**\n     * Step 4 of the signing process: add the signature to the HTTP request's headers.\n     *\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n     */\n    request.headers[constants.AUTHORIZATION_HEADER] =\n      `${constants.SIGNING_ALGORITHM_IDENTIFIER} ` +\n      `Credential=${this.credentials.accessKeyId}/${scope}, ` +\n      `SignedHeaders=${Object.keys(canonicalHeaders).sort().join(\";\")}, ` +\n      `Signature=${signature}`;\n\n    // If a request path was provided, add it to the URL\n    let url = request.endpoint.href;\n    if (request.path) {\n      // Ensure the URI and the request path are properly concatenated\n      // by adding a trailing slash to the URI if it's missing.\n      if (!url.endsWith(\"/\") && !request.path.startsWith(\"/\")) {\n        url += \"/\";\n      }\n\n      // Append the path to the URL\n      url += request.path;\n    }\n\n    // If a request query string was provided, add it to the URL\n    if (request.query) {\n      // We exclude the signature from the query string\n      url += `?${this.serializeQueryParameters(request.query)}`;\n    }\n\n    return {\n      url: url,\n      ...request,\n    };\n  }\n\n  /**\n   * Produces a presigned URL with AWS v4 signature information for the provided HTTP request.\n   *\n   * A presigned URL is a URL that contains the authorization information\n   * (signature and other signing information) in the query string. This method\n   * returns a preformatted URL that can be used to make the k6 http request.\n   *\n   * @param originalRequest - The original request to presign.\n   * @param options - Options controlling the signing of the request.\n   * @returns A signed request, including the presigned URL.\n   */\n  presign(\n    originalRequest: HTTPRequest,\n    options: PresignOptions = {},\n  ): SignedHTTPRequest {\n    const {\n      signingDate = new Date(),\n      expiresIn = 3600,\n      unsignableHeaders,\n      unhoistableHeaders,\n      signableHeaders,\n      signingRegion,\n      signingService,\n    } = options;\n    const { longDate, shortDate }: DateInfo = formatDate(signingDate);\n    const region = signingRegion || this.region;\n    const service = signingService || this.service;\n\n    if (expiresIn > constants.MAX_PRESIGNED_TTL) {\n      throw new InvalidSignatureError(\n        \"Signature version 4 presigned URLs can't be valid for more than 7 days\",\n      );\n    }\n\n    const scope =\n      `${shortDate}/${region}/${service}/${constants.KEY_TYPE_IDENTIFIER}`;\n    const request = this.moveHeadersToQuery(originalRequest, {\n      unhoistableHeaders,\n    });\n\n    // Required by the specification:\n    //   \"For HTTP/1.1 requests, you must include the host header at a minimum.\n    //   Standard headers like content-type are optional.\n    //   For HTTP/2 requests, you must include the :authority header instead of\n    //   the host header. Different services might require other headers.\"\n    if (!request.headers[constants.HOST_HEADER]) {\n      request.headers[constants.HOST_HEADER] =\n        originalRequest.endpoint.hostname;\n    }\n\n    // If the user provided a session token, include it in the signed url query string.\n    if (this.credentials.sessionToken) {\n      request.query[constants.AMZ_TOKEN_QUERY_PARAM] =\n        this.credentials.sessionToken;\n    }\n    // Add base signing query parameters to the request, as described in the documentation\n    // @see https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n    request.query[constants.AMZ_ALGORITHM_QUERY_PARAM] =\n      constants.SIGNING_ALGORITHM_IDENTIFIER;\n    request.query[\n      constants.AMZ_CREDENTIAL_QUERY_PARAM\n    ] = `${this.credentials.accessKeyId}/${scope}`;\n    request.query[constants.AMZ_DATE_QUERY_PARAM] = longDate;\n    request.query[constants.AMZ_EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n\n    const canonicalHeaders = this.computeCanonicalHeaders(\n      request,\n      unsignableHeaders,\n      signableHeaders,\n    );\n    request.query[constants.AMZ_SIGNED_HEADERS_QUERY_PARAM] = Object.keys(\n      canonicalHeaders,\n    )\n      .sort()\n      .join(\";\");\n\n    const signingKey = this.deriveSigningKey(\n      this.credentials,\n      service,\n      region,\n      shortDate,\n    );\n\n    // Computing the payload from the original request. This is required\n    // in the event the user attempts to produce a presigned URL for s3,\n    // which requires the payload hash to be 'UNSIGNED-PAYLOAD'.\n    //\n    // To that effect, users need to set the 'x-amz-content-sha256' header,\n    // and mark it as unhoistable and unsignable. When setup this way,\n    // the computePayloadHash method will then return the string 'UNSIGNED-PAYLOAD'.\n    const payloadHash = this.computePayloadHash(originalRequest);\n    const canonicalRequest = this.createCanonicalRequest(\n      request,\n      canonicalHeaders,\n      payloadHash,\n    );\n\n    request.query[constants.AMZ_SIGNATURE_QUERY_PARAM] = this\n      .calculateSignature(\n        longDate,\n        scope,\n        signingKey,\n        canonicalRequest,\n      );\n\n    // If a request path was provided, add it to the URL\n    let url = originalRequest.endpoint.href;\n    if (request.path) {\n      // Ensure there is a trailing slash at the end of the URL\n      // so that appending the path does not result in a malformed URL.\n      if (!url.endsWith(\"/\") && !request.path.startsWith(\"/\")) {\n        url += \"/\";\n      }\n\n      // Append the path to the URL\n      url += request.path;\n    }\n\n    // If a request query string was provided, add it to the URL\n    if (request.query) {\n      url += `?${this.serializeQueryParameters(request.query)}`;\n    }\n\n    return { url: url, ...request };\n  }\n\n  /**\n   * Create a string including information from your request\n   * in a AWS signature v4 standardized (canonical) format.\n   *\n   * Step 1 of the signing process: create the canonical request string.\n   * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n   *\n   * @param request {HTTPRequest} The request to sign.\n   * @param canonicalHeaders {HTTPHeaderBag} The request's canonical headers.\n   * @param payloadHash {string} The hexadecimally encoded request's payload hash .\n   * @returns {string} The canonical request string.\n   */\n  private createCanonicalRequest(\n    request: HTTPRequest,\n    canonicalHeaders: HTTPHeaderBag,\n    payloadHash: string,\n  ): string {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    const sortedCanonicalHeaders = sortedHeaders\n      .map((name) => `${name}:${canonicalHeaders[name]}`)\n      .join(\"\\n\");\n    const signedHeaders = sortedHeaders.join(\";\");\n\n    return (\n      `${request.method}\\n` +\n      `${this.computeCanonicalURI(request)}\\n` +\n      `${this.computeCanonicalQuerystring(request)}\\n` +\n      `${sortedCanonicalHeaders}\\n\\n` +\n      `${signedHeaders}\\n` +\n      `${payloadHash}`\n    );\n  }\n\n  /**\n   * Create the \"string to sign\" part of the signature Version 4 protocol.\n   *\n   * The \"string to sign\" includes meta information about your request and\n   * about the canonical request that you created with `createCanonicalRequest`.\n   * It is used hand in hand with the signing key to create the request signature.\n   * Step 2 of the signing process: create the string to sign.\n   * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n   *\n   * @param longDate {string} The request's date in iso 8601 format.\n   * @param credentialScope {string} The request's credential scope.\n   * @param canonicalRequest {string} The request's canonical request.\n   * @returns {string} The \"string to sign\".\n   */\n  private createStringToSign(\n    longDate: string,\n    credentialScope: string,\n    canonicalRequest: string,\n  ): string {\n    const hashedCanonicalRequest = crypto.sha256(canonicalRequest, \"hex\");\n\n    return (\n      `${constants.SIGNING_ALGORITHM_IDENTIFIER}\\n` +\n      `${longDate}\\n` +\n      `${credentialScope}\\n` +\n      `${hashedCanonicalRequest}`\n    );\n  }\n\n  /**\n   * Calculte the signature for AWS signature version 4.\n   *\n   * Step 3 of the signing process: create the signature.\n   * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n   *\n   * @param longDate {string} The request's date in iso 8601 format.\n   * @param credentialScope {string} The request's credential scope.\n   * @param signingKey {string} the signing key as computed by the deriveSigningKey method.\n   * @param canonicalRequest {string} The request's canonical request.\n   * @returns {string} The signature.\n   */\n  private calculateSignature(\n    longDate: string,\n    credentialScope: string,\n    signingKey: Uint8Array,\n    canonicalRequest: string,\n  ): string {\n    const stringToSign = this.createStringToSign(\n      longDate,\n      credentialScope,\n      canonicalRequest,\n    );\n    return crypto.hmac(\"sha256\", signingKey, stringToSign, \"hex\");\n  }\n\n  /**\n   * Derives the signing key for authenticating requests signed with\n   * the Signature version 4 authentication protocol.\n   *\n   * deriveSigningKey produces a signing key by creating a series of\n   * hash-based message authentication codes (HMACs) represented in\n   * a binary format.\n   *\n   * The derived signing key is specific to the date it's made at, as well as\n   * the service and region it targets.\n   *\n   * @param credentials {AWSCredentials} The credentials to use for signing.\n   * @param service {string} The service the request is targeted at.\n   * @param region {string} The region the request is targeted at.\n   * @param shortDate {string} The request's date in YYYYMMDD format.\n   * @returns {Uint8Array} The derived signing key.\n   */\n  private deriveSigningKey(\n    credentials: Credentials,\n    service: string,\n    region: string,\n    shortDate: string,\n  ): Uint8Array {\n    const kSecret: string = credentials.secretAccessKey;\n\n    // First HMAC: string secret -> bytes\n    const kDateBytes: bytes = crypto.hmac(\n      \"sha256\",\n      \"AWS4\" + kSecret,\n      shortDate,\n      \"binary\",\n    );\n    const kDate = bytesToUint8Array(kDateBytes);\n\n    // Second HMAC: ArrayBuffer secret -> bytes\n    const kRegionBytes: bytes = crypto.hmac(\n      \"sha256\",\n      uint8ArrayToArrayBuffer(kDate),\n      region,\n      \"binary\",\n    );\n    const kRegion = bytesToUint8Array(kRegionBytes);\n\n    // Third HMAC: ArrayBuffer secret -> bytes\n    const kServiceBytes: bytes = crypto.hmac(\n      \"sha256\",\n      uint8ArrayToArrayBuffer(kRegion),\n      service,\n      \"binary\",\n    );\n    const kService = bytesToUint8Array(kServiceBytes);\n\n    // Fourth HMAC: ArrayBuffer secret -> bytes\n    const kSigningBytes: bytes = crypto.hmac(\n      \"sha256\",\n      uint8ArrayToArrayBuffer(kService),\n      \"aws4_request\",\n      \"binary\",\n    );\n    const kSigning = bytesToUint8Array(kSigningBytes);\n\n    return kSigning;\n  }\n\n  /**\n   * Create a string that includes information from your request\n   * in a AWS signature v4 standardized (canonical) format.\n   *\n   * @param param0 {HTTPRequest} The request to sign.\n   * @returns {string} The canonical URI.\n   */\n  private computeCanonicalURI({ path }: HTTPRequest): string {\n    if (this.uriEscapePath) {\n      // Non-S3 services, we normalize the path and then double URI encode it.\n      // Ref: \"Remove Dot Segments\" https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4\n      const normalizedURISegments = [];\n\n      for (const URISegment of path.split(\"/\")) {\n        if (URISegment?.length === 0) {\n          continue;\n        }\n\n        if (URISegment === \".\") {\n          continue;\n        }\n\n        if (URISegment === \"..\") {\n          normalizedURISegments.pop();\n        } else {\n          normalizedURISegments.push(URISegment);\n        }\n      }\n\n      // Normalize the URI\n      const leading = path?.startsWith(\"/\") ? \"/\" : \"\";\n      const URI = normalizedURISegments.join(\"/\");\n      const trailing = normalizedURISegments.length > 0 && path?.endsWith(\"/\")\n        ? \"/\"\n        : \"\";\n      const normalizedURI = `${leading}${URI}${trailing}`;\n\n      const doubleEncoded = encodeURIComponent(normalizedURI);\n\n      return doubleEncoded.replace(/%2F/g, \"/\");\n    }\n\n    // For S3, we shouldn't normalize the path. For example, object name\n    // my-object//example//photo.user should not be normalized to\n    // my-object/example/photo.user\n    return path;\n  }\n\n  /**\n   * Serializes the request's query parameters into their canonical\n   * string version. If the request does not include a query parameters,\n   * returns an empty string.\n   *\n   * @param param0 {HTTPRequest} The request containing the query parameters.\n   * @returns {string} The canonical query string.\n   */\n  private computeCanonicalQuerystring({ query = {} }: HTTPRequest): string {\n    const keys: Array<string> = [];\n    const serialized: Record<string, string> = {};\n\n    for (const key of Object.keys(query).sort()) {\n      if (key.toLowerCase() === constants.AMZ_SIGNATURE_HEADER) {\n        continue;\n      }\n\n      keys.push(key);\n      const value = query[key];\n\n      if (typeof value === \"string\") {\n        serialized[key] = `${escapeURI(key)}=${escapeURI(value)}`;\n      } else if (Array.isArray(value)) {\n        serialized[key] = value\n          .slice(0)\n          .sort()\n          .reduce(\n            (encoded: Array<string>, value: string) =>\n              encoded.concat([`${escapeURI(key)}=${escapeURI(value)}`]),\n            [],\n          )\n          .join(\"&\");\n      }\n    }\n\n    return keys\n      .map((key) => serialized[key])\n      .filter((serialized) => serialized)\n      .join(\"&\");\n  }\n\n  /**\n   * Create the canonical form of the request's headers.\n   * Canonical headers consist of all the HTTP headers you\n   * are including with the signed request.\n   *\n   * @param param0 {HTTPRequest} The request to compute the canonical headers of.\n   * @param unsignableHeaders {Set<string>} The headers that should not be signed.\n   * @param signableHeaders {Set<string>} The headers that should be signed.\n   * @returns {string} The canonical headers.\n   */\n  private computeCanonicalHeaders(\n    { headers }: HTTPRequest,\n    unsignableHeaders?: Set<string>,\n    signableHeaders?: Set<string>,\n  ): HTTPHeaderBag {\n    const canonicalHeaders: HTTPHeaderBag = {};\n\n    for (const headerName of Object.keys(headers).sort()) {\n      if (headers[headerName] == undefined) {\n        continue;\n      }\n\n      const canonicalHeaderName = headerName.toLowerCase();\n      if (\n        canonicalHeaderName in constants.ALWAYS_UNSIGNABLE_HEADERS ||\n        unsignableHeaders?.has(canonicalHeaderName)\n      ) {\n        if (\n          !signableHeaders ||\n          (signableHeaders && !signableHeaders.has(canonicalHeaderName))\n        ) {\n          continue;\n        }\n      }\n\n      if (typeof headers[headerName] === \"string\") {\n        canonicalHeaders[canonicalHeaderName] =\n          headers[headerName] =\n            headers[headerName]\n              .trim()\n              .replace(/\\s+/g, \" \");\n      }\n    }\n\n    return canonicalHeaders;\n  }\n\n  /**\n   * Computes the SHA256 cryptographic hash of the request's body.\n   *\n   * If the headers contain the 'X-Amz-Content-Sha256' header, then\n   * the value of that header is returned instead. This proves useful\n   * when, for example, presiging a URL for S3, as the payload hash\n   * must always be equal to 'UNSIGNED-PAYLOAD'.\n   *\n   * @param param0 {HTTPRequest} The request to compute the payload hash of.\n   * @returns {string} The hex encoded SHA256 payload hash, or the value of the 'X-Amz-Content-Sha256' header.\n   */\n  private computePayloadHash({ headers, body }: HTTPRequest): string {\n    // for (const headerName of Object.keys(headers)) {\n    //     // If the header is present, return its value.\n    //     // So that we let the 'UNSIGNED-PAYLOAD' value pass through.\n    //     if (headerName.toLowerCase() === constants.AMZ_CONTENT_SHA256_HEADER) {\n    //         return headers[headerName]\n    //     }\n    // }\n\n    if (headers[constants.AMZ_CONTENT_SHA256_HEADER]) {\n      return headers[constants.AMZ_CONTENT_SHA256_HEADER];\n    }\n\n    if (body == undefined) {\n      return constants.EMPTY_SHA256;\n    }\n\n    if (typeof body === \"string\" || isArrayBuffer(body)) {\n      return crypto.sha256(body, \"hex\").toLowerCase();\n    }\n\n    if (ArrayBuffer.isView(body)) {\n      // If the request body is a typed array, we need to convert it to a buffer\n      // so that we can calculate the checksum.\n      return crypto.sha256((body as DataView).buffer, \"hex\").toLowerCase();\n    }\n\n    return constants.UNSIGNED_PAYLOAD;\n  }\n\n  /**\n   * Moves a request's headers to its query parameters.\n   *\n   * The operation will ignore any amazon standard headers, prefixed\n   * with 'X-Amz-'. It will also ignore any headers specified as unhoistable\n   * by the options.\n   *\n   * The operation will delete the headers from the request.\n   *\n   * @param request {HTTPRequest} The request to move the headers from.\n   * @param options\n   * @returns {HTTPRequest} The request with the headers moved to the query parameters.\n   */\n  private moveHeadersToQuery(\n    request: HTTPRequest,\n    options: { unhoistableHeaders?: Set<string> } = {},\n  ): HTTPRequest & { query: QueryParameterBag } {\n    const requestCopy = JSON.parse(JSON.stringify(request));\n    const { headers, query = {} as QueryParameterBag } = requestCopy;\n\n    for (const name of Object.keys(headers)) {\n      const lowerCaseName = name.toLowerCase();\n      if (\n        lowerCaseName.slice(0, 6) === \"x-amz-\" &&\n        !options.unhoistableHeaders?.has(lowerCaseName)\n      ) {\n        query[name] = headers[name];\n        delete headers[name];\n      }\n    }\n\n    return {\n      ...requestCopy,\n      headers,\n      query,\n    };\n  }\n\n  /**\n   * Serializes a HTTPRequest's query parameter bag into a string.\n   *\n   * @param query {QueryParameterBag} The query parameters to serialize.\n   * @param ignoreKeys {Set<string>} The keys to ignore.\n   * @returns {string} The serialized, and ready to use in a URL, query parameters.\n   */\n  private serializeQueryParameters(\n    query: QueryParameterBag,\n    ignoreKeys?: string[],\n  ): string {\n    const keys: Array<string> = [];\n    const serialized: Record<string, string> = {};\n\n    for (const key of Object.keys(query).sort()) {\n      if (ignoreKeys?.includes(key.toLowerCase())) {\n        continue;\n      }\n\n      keys.push(key);\n      const value = query[key];\n\n      if (typeof value === \"string\") {\n        serialized[key] = `${escapeURI(key)}=${escapeURI(value)}`;\n      } else if (Array.isArray(value)) {\n        serialized[key] = value\n          .slice(0)\n          .sort()\n          .reduce(\n            (encoded: Array<string>, value: string) =>\n              encoded.concat([`${escapeURI(key)}=${escapeURI(value)}`]),\n            [],\n          )\n          .join(\"&\");\n      }\n    }\n\n    return keys\n      .map((key) => serialized[key])\n      .filter((serialized) => serialized)\n      .join(\"&\");\n  }\n}\n\n/**\n * Error indicating an Invalid signature has been sent to AWS services\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class InvalidSignatureError extends AWSError {\n  /**\n   * Constructs an InvalidSignatureError\n   *\n   * @param  {string} message - human readable error message\n   */\n  constructor(message: string, code?: string) {\n    super(message, code);\n    this.name = \"InvalidSignatureError\";\n  }\n}\n\nexport interface SignatureV4Options {\n  /**\n   * The name of the service to sign for.\n   */\n  service: string;\n\n  /**\n   * The name of the region to sign for.\n   */\n  region: string;\n\n  /**\n   * The credentials with which the request should be signed.\n   */\n  credentials: Credentials;\n\n  /**\n   * Whether to uri-escape the request URI path as part of computing the\n   * canonical request string. This is required for every AWS service, except\n   * Amazon S3, as of late 2017.\n   *\n   * @default [true]\n   */\n  uriEscapePath?: boolean;\n\n  /**\n   * Whether to calculate a checksum of the request body and include it as\n   * either a request header (when signing) or as a query string parameter\n   * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n   * every other AWS service as of late 2017.\n   *\n   * @default [true]\n   */\n  applyChecksum?: boolean;\n}\n\nexport interface SignOptions {\n  /**\n   * The date and time to be used as signature metadata. This value should be\n   * a Date object, a unix (epoch) timestamp, or a string that can be\n   * understood by the JavaScript `Date` constructor.If not supplied, the\n   * value returned by `new Date()` will be used.\n   */\n  signingDate?: Date;\n\n  /**\n   * The service signing name. It will override the service name of the signer\n   * in current invocation\n   */\n  signingService?: string;\n\n  /**\n   * The region name to sign the request. It will override the signing region of the\n   * signer in current invocation\n   */\n  signingRegion?: string;\n}\n\nexport interface RequestSigningOptions extends SignOptions {\n  /**\n   * A set of strings whose members represents headers that cannot be signed.\n   * All headers in the provided request will have their names converted to\n   * lower case and then checked for existence in the unsignableHeaders set.\n   */\n  unsignableHeaders?: Set<string>;\n\n  /**\n   * A set of strings whose members represents headers that should be signed.\n   * Any values passed here will override those provided via unsignableHeaders,\n   * allowing them to be signed.\n   *\n   * All headers in the provided request will have their names converted to\n   * lower case before signing.\n   */\n  signableHeaders?: Set<string>;\n}\n\nexport interface PresignOptions extends RequestSigningOptions {\n  /**\n   * The number of seconds before the presigned URL expires\n   */\n  expiresIn?: number;\n\n  /**\n   * A set of strings whose representing headers that should not be hoisted\n   * to presigned request's query string. If not supplied, the presigner\n   * moves all the AWS-specific headers (starting with `x-amz-`) to the request\n   * query string. If supplied, these headers remain in the presigned request's\n   * header.\n   * All headers in the provided request will have their names converted to\n   * lower case and then checked for existence in the unhoistableHeaders set.\n   */\n  unhoistableHeaders?: Set<string>;\n}\n\nexport interface Credentials {\n  /**\n   * AWS access key ID\n   */\n  readonly accessKeyId: string;\n\n  /**\n   * AWS secret access key\n   */\n  readonly secretAccessKey: string;\n\n  /**\n   * A security or session token to use with these credentials. Usually\n   * present for temporary credentials.\n   */\n  readonly sessionToken?: string;\n}\n\nexport interface DateInfo {\n  /**\n   * ISO8601 formatted date string\n   */\n  longDate: string;\n\n  /**\n   * String in the format YYYYMMDD\n   */\n  shortDate: string;\n}\n\n/**\n * Converts k6's bytes (number[]) to Uint8Array for proper typing.\n * k6's crypto.hmac with 'binary' encoding returns bytes (number[]), but subsequent\n * HMAC operations need ArrayBuffer input, and our function signature requires Uint8Array.\n *\n * @param bytes {bytes} The bytes array from k6's crypto operations.\n * @returns {Uint8Array} The converted Uint8Array.\n */\nfunction bytesToUint8Array(bytes: bytes): Uint8Array {\n  return new Uint8Array(bytes);\n}\n\n/**\n * Converts Uint8Array to ArrayBuffer for HMAC secret parameter.\n * k6's crypto.hmac accepts string | ArrayBuffer as secret, so we convert our Uint8Array\n * to ArrayBuffer for chained HMAC operations.\n *\n * @param uint8Array {Uint8Array} The Uint8Array to convert.\n * @returns {ArrayBuffer} The converted ArrayBuffer.\n */\nfunction uint8ArrayToArrayBuffer(uint8Array: Uint8Array): ArrayBuffer {\n  return uint8Array.buffer.slice(\n    uint8Array.byteOffset,\n    uint8Array.byteOffset + uint8Array.byteLength,\n  );\n}\n\n/**\n * Escapes a URI following the AWS signature v4 escaping rules.\n *\n * @param URI {string} The URI to escape.\n * @returns {string} The escaped URI.\n */\nfunction escapeURI(URI: string): string {\n  const hexEncode = (c: string): string => {\n    return `%${c.charCodeAt(0).toString(16).toUpperCase()}`;\n  };\n\n  return encodeURIComponent(URI).replace(/[!'()*]/g, hexEncode);\n}\n\n/**\n * formatDate formats a Date object into a ISO8601 formatted date string\n * and a string in the format YYYYMMDD.\n *\n * @param date {Date} The date to format.\n * @returns {DateInfo} The formatted date.\n */\nfunction formatDate(date: Date): DateInfo {\n  const longDate = iso8601(date).replace(/[-:]/g, \"\");\n  return {\n    longDate,\n    shortDate: longDate.slice(0, 8),\n  };\n}\n\n/**\n * Formats a time into an ISO 8601 string.\n *\n * @see https://en.wikipedia.org/wiki/ISO_8601\n *\n * @param time {number | string | Date} The time to format.\n * @returns {string} The ISO 8601 formatted time.\n */\nfunction iso8601(time: number | string | Date): string {\n  return toDate(time)\n    .toISOString()\n    .replace(/\\.\\d{3}Z$/, \"Z\");\n}\n\n/**\n * Converts a time value into a Date object.\n *\n * @param time {number | string | Date} The time to convert.\n * @returns {Date} The resulting Date object.\n */\nfunction toDate(time: number | string | Date): Date {\n  if (typeof time === \"number\") {\n    return new Date(time * 1000);\n  }\n\n  if (typeof time === \"string\") {\n    if (Number(time)) {\n      return new Date(Number(time) * 1000);\n    }\n\n    return new Date(time);\n  }\n\n  return time;\n}\n", "/**\n * Standard Amazon AWS query parameter names\n */\nexport const AMZ_ALGORITHM_QUERY_PARAM = \"X-Amz-Algorithm\";\nexport const AMZ_CREDENTIAL_QUERY_PARAM = \"X-Amz-Credential\";\nexport const AMZ_DATE_QUERY_PARAM = \"X-Amz-Date\";\nexport const AMZ_EXPIRES_QUERY_PARAM = \"X-Amz-Expires\";\nexport const AMZ_SIGNATURE_QUERY_PARAM = \"X-Amz-Signature\";\nexport const AMZ_SIGNED_HEADERS_QUERY_PARAM = \"X-Amz-SignedHeaders\";\nexport const AMZ_TARGET_QUERY_PARAM = \"X-Amz-Target\";\nexport const AMZ_TOKEN_QUERY_PARAM = \"X-Amz-Security-Token\";\n\n/**\n * Standard Amazon AWS header names\n */\nexport const AMZ_CONTENT_SHA256_HEADER = \"x-amz-content-sha256\";\nexport const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();\nexport const AMZ_SIGNATURE_HEADER = AMZ_SIGNATURE_QUERY_PARAM.toLowerCase();\nexport const AMZ_TARGET_HEADER = AMZ_TARGET_QUERY_PARAM.toLowerCase();\nexport const AMZ_TOKEN_HEADER = AMZ_TOKEN_QUERY_PARAM.toLowerCase();\n\n/**\n * Common HTTP headers we rely on in the signing process\n */\nexport const AUTHORIZATION_HEADER = \"authorization\";\nexport const DATE_HEADER = \"date\";\n\n/**\n * Lists the headers that are generated as part of the signature process.\n */\nexport const GENERATED_HEADERS = [\n  AUTHORIZATION_HEADER,\n  AMZ_DATE_HEADER,\n  DATE_HEADER,\n];\nexport const HOST_HEADER = \"host\";\n\n/**\n * Lists the headers that should never be included in the\n * request signature signature process.\n */\nexport const ALWAYS_UNSIGNABLE_HEADERS = {\n  authorization: true,\n  \"cache-control\": true,\n  connection: true,\n  expect: true,\n  from: true,\n  \"keep-alive\": true,\n  \"max-forwards\": true,\n  pragma: true,\n  referer: true,\n  te: true,\n  trailer: true,\n  \"transfer-encoding\": true,\n  upgrade: true,\n  \"user-agent\": true,\n  \"x-amzn-trace-id\": true,\n};\n\n/**\n * Signature specific constants included in the signing process\n */\nexport const KEY_TYPE_IDENTIFIER = \"aws4_request\";\nexport const SIGNING_ALGORITHM_IDENTIFIER = \"AWS4-HMAC-SHA256\";\n\n/**\n * Maximum time to live of a signed request in seconds: 7 days.\n */\nexport const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;\n\n/**\n * SHA256 hash of an empty string (so we don't waste cycles recomputing it)\n */\nexport const EMPTY_SHA256 =\n  \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\";\n\n/**\n * SHA256 hash of the unsigned payload constant (so we don't waste cycles recomputing it)\n */\nexport const UNSIGNED_PAYLOAD_SHA256 =\n  \"5a41b0751e4537c6ff868564ab44a4d4ecceec2ec5b1c5f74d97422968e04237\";\n\nexport const UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\n", "import { Endpoint } from \"./endpoint.ts\";\n\n/**\n * Type representing HTTP schemes\n */\nexport type HTTPScheme = \"http\" | \"https\";\n\n/**\n * Type representing HTTP Methods\n */\nexport type HTTPMethod = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n\n/**\n * Type alias representing HTTP Headers\n */\nexport type HTTPHeaders = { [key: string]: string };\n\n/**\n * HTTPHeaderBag is a type alias representing HTTP Headers\n */\nexport type HTTPHeaderBag = Record<string, string>;\n\nexport function hasHeader(\n  soughtHeader: string,\n  headers: HTTPHeaderBag,\n): boolean {\n  soughtHeader = soughtHeader.toLowerCase();\n\n  for (const headerName of Object.keys(headers)) {\n    if (soughtHeader === headerName.toLowerCase()) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * QueryParameterBag is a type alias representing HTTP Query Parameters\n */\nexport type QueryParameterBag = Record<string, string | Array<string>>;\n\n/**\n * HTTPRequest represents an HTTP request\n */\nexport interface HTTPRequest {\n  /**\n   * The HTTP method to use\n   */\n  method: HTTPMethod;\n\n  /**\n   * Represents an AWS service endpoint, providing utilities for parsing and handling URL details.\n   */\n  endpoint: Endpoint;\n\n  /**\n   * The path to the resource\n   */\n  path: string;\n\n  /**\n   * The query parameters to include in the request\n   */\n  query?: QueryParameterBag;\n\n  /**\n   * The headers to include in the request\n   */\n  headers: HTTPHeaderBag;\n\n  /**\n   * The body of the request\n   */\n  body?: string | ArrayBuffer | null;\n}\n\n/**\n * SignedHTTPRequest represents an HTTP request that has been signed\n * with an AWS signature. It is a superset of HTTPRequest adding\n * the following fields:\n * - url: the fully qualified URL of the request that can be used in a k6 http.request.\n */\nexport interface SignedHTTPRequest extends HTTPRequest {\n  url: string;\n}\n", "/**\n * @param value\n * @returns\n */\nexport function isArrayBuffer(value: unknown): value is ArrayBuffer {\n  return (\n    typeof ArrayBuffer === \"function\" &&\n    (value instanceof ArrayBuffer ||\n      Object.prototype.toString.call(value) === \"[object ArrayBuffer]\")\n  );\n}\n\nexport function toFormUrlEncoded(\n  form: Record<string, string | number | boolean>,\n): string {\n  return Object.keys(form)\n    .reduce((params, key) => {\n      const value = form[key];\n      if (value !== undefined && value !== null) {\n        params.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n      }\n      return params;\n    }, [] as string[])\n    .join(\"&\");\n}\n", "/**\n * Represents an AWS service endpoint, providing utilities for parsing and handling URL details.\n */\nexport class Endpoint {\n  private _protocol: string;\n  private _hostname: string;\n  private _port?: number;\n\n  // Default protocol, this can be globally changed as per application requirements\n  private static readonly DEFAULT_PROTOCOL = \"https\"; // Set this as per AWS.config\n\n  /**\n    //  * Constructs a new Endpoint instance.\n     *\n     * @param {string} endpoint - The URL to construct an endpoint from. If the URL omits a protocol, the default protocol will be used.\n     */\n  constructor(endpoint: string) {\n    const isDefaultProtocol = !endpoint.startsWith(\"http://\") &&\n      !endpoint.startsWith(\"https://\");\n    const completeUrl = isDefaultProtocol\n      ? `${Endpoint.DEFAULT_PROTOCOL}://${endpoint}`\n      : endpoint;\n\n    const protocolMatch = completeUrl.match(/^https?:/);\n    const hostAndPath = completeUrl.replace(/^https?:\\/\\//, \"\");\n    const [hostnameWithPort] = hostAndPath.split(\"/\");\n\n    this._protocol = protocolMatch\n      ? protocolMatch[0].slice(0, -1)\n      : Endpoint.DEFAULT_PROTOCOL;\n    this._hostname = hostnameWithPort.split(\":\")[0];\n    this._port = hostnameWithPort.split(\":\")[1]\n      ? parseInt(hostnameWithPort.split(\":\")[1])\n      : undefined;\n  }\n\n  /**\n   * Creates a new Endpoint instance that is a copy of the current one.\n   *\n   * @returns {Endpoint} The copied Endpoint.\n   */\n  public copy(): Endpoint {\n    return new Endpoint(this.href);\n  }\n\n  /**\n   * Gets the host portion of the endpoint including the port.\n   *\n   * @returns {string} The host portion of the endpoint including the port.\n   */\n  public get host(): string {\n    return this._port ? `${this._hostname}:${this._port}` : this._hostname;\n  }\n\n  /**\n   * Sets the host portion of the endpoint including the port.\n   *\n   * @param {string} value - The value to set for the host.\n   */\n  public set host(value: string) {\n    const [hostname, port] = value.split(\":\");\n    this._hostname = hostname;\n    this._port = port ? parseInt(port) : undefined;\n  }\n\n  /**\n   * Gets the host portion of the endpoint without the port.\n   *\n   * @returns {string} The host portion of the endpoint.\n   */\n  public get hostname(): string {\n    return this._hostname;\n  }\n\n  /**\n   * Sets the host portion of the endpoint without the port.\n   *\n   * @param {string} value - The value to set for the hostname.\n   */\n  public set hostname(value: string) {\n    this._hostname = value;\n  }\n\n  /**\n   * Gets the full URL of the endpoint.\n   *\n   * @returns {string} The full URL of the endpoint.\n   */\n  public get href(): string {\n    return `${this.protocol}://${this.host}`;\n  }\n\n  /**\n   * Sets the full URL of the endpoint.\n   *\n   * @param {string} value - The value to set for the full URL.\n   */\n  public set href(value: string) {\n    const protocolMatch = value.match(/^https?:/);\n    const withoutProtocol = value.replace(/^https?:\\/\\//, \"\");\n    const [hostnameWithPort] = withoutProtocol.split(\"/\");\n\n    this._protocol = protocolMatch\n      ? protocolMatch[0].slice(0, -1)\n      : Endpoint.DEFAULT_PROTOCOL; // remove the trailing colon\n    this._hostname = hostnameWithPort.split(\":\")[0];\n    this._port = hostnameWithPort.split(\":\")[1]\n      ? parseInt(hostnameWithPort.split(\":\")[1])\n      : undefined;\n  }\n\n  /**\n   * Gets the port of the endpoint.\n   *\n   * @returns {number|undefined} The port of the endpoint.\n   */\n  public get port(): number | undefined {\n    return this._port;\n  }\n\n  /**\n   * Sets the port of the endpoint.\n   *\n   * @param {number|undefined} value - The value to set for the port.\n   */\n  public set port(value: number | undefined) {\n    this._port = value;\n  }\n\n  /**\n   * Gets the protocol (http or https) of the endpoint URL.\n   *\n   * @returns {string} The protocol of the endpoint URL.\n   */\n  public get protocol(): string {\n    return this._protocol;\n  }\n\n  /**\n   * Sets the protocol (http or https) of the endpoint URL.\n   *\n   * @param {string} value - The value to set for the protocol.\n   */\n  public set protocol(value: string) {\n    this._protocol = value;\n  }\n}\n", "import { HTTPScheme } from \"./http.ts\";\nimport { Endpoint } from \"./endpoint.ts\";\n\n/** Class holding an AWS connection information */\nexport class AWSConfig {\n  /**\n   * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n   *\n   * @type {string}\n   */\n  region: string;\n\n  /**\n   * Your user's AWS access key id credential.\n   *\n   * @type {string}\n   */\n  accessKeyId: string;\n\n  /**\n   * Your user's AWS secret access key credential.\n   *\n   * @type {string}\n   */\n  secretAccessKey: string;\n\n  /**\n   * Your user's AWS session token credential.\n   *\n   * @type {string}\n   */\n  sessionToken?: string;\n\n  /**\n   * The AWS hostname to connect to.\n   *\n   * @type {string} ['amazonaws.com']\n   */\n  endpoint?: Endpoint;\n\n  /**\n   * fromEnvironment creates an AWSConfig from the environment variables.\n   *\n   * It expects to find the following compulsory environment variables:\n   *  * AWS_REGION\n   *  * AWS_ACCESS_KEY_ID\n   *  * AWS_SECRET_ACCESS_KEY\n   *\n   * If set, the following optional environment variables are also used:\n   *  * AWS_SESSION_TOKEN\n   *\n   * Finally, the options parameter allows to explicitly set the scheme and endpoint\n   * to use when connecting to AWS.\n   *\n   * @param options {AWSConnectionOptions}\n   * @returns\n   */\n  static fromEnvironment(options?: AWSConnectionOptions): AWSConfig {\n    const region = __ENV.AWS_REGION;\n    const accessKeyId = __ENV.AWS_ACCESS_KEY_ID;\n    const secretAccessKey = __ENV.AWS_SECRET_ACCESS_KEY;\n    const sessionToken: string | undefined = __ENV.AWS_SESSION_TOKEN;\n    const endpoint: Endpoint | string | undefined = options?.endpoint;\n\n    return new AWSConfig({\n      region,\n      accessKeyId,\n      secretAccessKey,\n      sessionToken,\n      endpoint: endpoint,\n    });\n  }\n\n  /**\n   * Create an AWSConfig.\n   *\n   * @param {AWSConfigOptions} options - configuration attributes to use when interacting with AWS' APIs\n   * @throws {InvalidArgumentException}\n   */\n  constructor(options: AWSConfigOptions) {\n    if (!options.region || options.region === \"\") {\n      throw new InvalidAWSConfigError(\n        `invalid AWS region; reason: expected a valid AWS region name (e.g. \"us-east-1\"), got \\`${options.region}\\``,\n      );\n    }\n\n    if (!options.accessKeyId || options.accessKeyId === \"\") {\n      throw new InvalidAWSConfigError(\n        `invalid AWS access key ID; reason: expected a non empty string, got \\`${options.accessKeyId}\\``,\n      );\n    }\n\n    if (\n      options.accessKeyId.length < 16 ||\n      (options.accessKeyId.length > 128 && options.sessionToken != undefined)\n    ) {\n      throw new InvalidAWSConfigError(\n        `invalid AWS access key ID; reason: size should be between 16 and 128 characters, got ${options.accessKeyId.length}`,\n      );\n    }\n\n    if (!options.secretAccessKey || options.secretAccessKey === \"\") {\n      throw new InvalidAWSConfigError(\n        `invalid AWS secret access key; reason: expected a non empty string, got \\`${options.secretAccessKey}\\``,\n      );\n    }\n\n    this.region = options.region;\n    this.accessKeyId = options.accessKeyId;\n    this.secretAccessKey = options.secretAccessKey;\n\n    if (options.sessionToken !== undefined) {\n      this.sessionToken = options.sessionToken;\n    }\n\n    if (options.endpoint !== undefined) {\n      if (typeof options.endpoint === \"string\") {\n        this.endpoint = new Endpoint(options.endpoint);\n      } else {\n        this.endpoint = options.endpoint;\n      }\n    }\n  }\n}\n\n/**\n * Interface representing AWSConfig options\n */\nexport interface AWSConfigOptions extends AWSConnectionOptions {\n  /**\n   * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n   *\n   * @type {string}\n   */\n  region: string;\n\n  /**\n   * Your user's AWS access key id credential.\n   *\n   * @type {string}\n   */\n  accessKeyId: string;\n\n  /**\n   * Your user's AWS secret access key credential.\n   *\n   * @type {string}\n   */\n  secretAccessKey: string;\n\n  /**\n   * Your user's AWS session token credential.\n   *\n   * @type {string}\n   */\n  sessionToken?: string;\n}\n\n/**\n * Interface representing AWS connection options\n */\nexport interface AWSConnectionOptions {\n  /**\n   * The HTTP scheme to use when connecting to AWS.\n   *\n   * @type {HTTPScheme}\n   */\n  scheme?: HTTPScheme;\n\n  /**\n   * The AWS hostname to connect to.\n   *\n   * @type {string}\n   */\n  endpoint?: Endpoint | string;\n}\n\n/** Class representing an invalid AWS configuration */\nexport class InvalidAWSConfigError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n", "import { JSONArray, JSONObject } from \"k6\";\nimport http, { RefinedResponse, ResponseType } from \"k6/http\";\n\nimport { AWSClient } from \"./client.ts\";\nimport { AWSConfig } from \"./config.ts\";\nimport { AMZ_TARGET_HEADER } from \"./constants.ts\";\nimport { AWSError } from \"./error.ts\";\nimport { HTTPHeaders, HTTPMethod } from \"./http.ts\";\nimport { InvalidSignatureError, SignatureV4 } from \"./signature.ts\";\n\n/**\n * Class allowing to interact with Amazon AWS's KMS service\n */\nexport class KMSClient extends AWSClient {\n  private readonly signature: SignatureV4;\n  private readonly method: HTTPMethod;\n  private readonly commonHeaders: HTTPHeaders;\n\n  /**\n   * Create a KMSClient\n   * @param  {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n   */\n  constructor(awsConfig: AWSConfig) {\n    super(awsConfig, \"kms\");\n\n    this.signature = new SignatureV4({\n      service: this.serviceName,\n      region: awsConfig.region,\n      credentials: {\n        accessKeyId: awsConfig.accessKeyId,\n        secretAccessKey: awsConfig.secretAccessKey,\n        sessionToken: awsConfig.sessionToken,\n      },\n      uriEscapePath: true,\n      applyChecksum: false,\n    });\n\n    // All interactions with the KMS service\n    // are made via the GET or POST method.\n    this.method = \"POST\";\n\n    this.commonHeaders = {\n      \"Content-Type\": \"application/x-amz-json-1.1\",\n    };\n  }\n\n  /**\n   * Gets a list of all the KMS keys in the caller's AWS\n   * account and region.\n   *\n   * @returns an array of all the available keys\n   */\n  async listKeys(): Promise<Array<KMSKey>> {\n    const signedRequest = this.signature.sign(\n      {\n        method: this.method,\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          // For some reason, the base target is not kms...\n          [AMZ_TARGET_HEADER]: `TrentService.ListKeys`,\n        },\n        body: JSON.stringify({}),\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      this.method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, KMSOperation.ListKeys);\n\n    const json: JSONArray = res.json(\"Keys\") as JSONArray;\n    return json.map((k) => KMSKey.fromJSON(k as JSONObject));\n  }\n\n  /**\n   * GenerateDataKey returns a unique symmetric data key for use outside of AWS KMS.\n   *\n   * This operation returns a plaintext copy of the data key and a copy that is encrypted under a symmetric encryption KMS key that you specify.\n   * The bytes in the plaintext key are random; they are not related to the caller or the KMS key.\n   * You can use the plaintext key to encrypt your data outside of AWS KMS and store the encrypted data key with the encrypted data.\n   *\n   * To generate a data key, specify the symmetric encryption KMS key that will be used to encrypt the data key.\n   * You cannot use an asymmetric KMS key to encrypt data keys.\n   *\n   * Used to generate data key with the KMS key defined\n   * @param {string} id - Specifies the symmetric encryption KMS key that encrypts the data key. Use its key ID, key ARN, alias name, or alias ARN.\n   * @param {KMKeySize} size - Specifies the length of the data key in bytes. For example, use the value 64 to generate a 512-bit data key (64 bytes is 512 bits). Default is 32, and generates a 256-bit data key.\n   * @throws {KMSServiceError}\n   * @throws {InvalidSignatureError}\n   * @returns {KMSDataKey} - The generated data key.\n   */\n  async generateDataKey(\n    id: string,\n    size: KMSKeySize = KMSKeySize.Size256,\n  ): Promise<KMSDataKey | undefined> {\n    const signedRequest = this.signature.sign(\n      {\n        method: this.method,\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          // For some reason, the base target is not kms...\n          [AMZ_TARGET_HEADER]: `TrentService.GenerateDataKey`,\n        },\n        body: JSON.stringify({ KeyId: id, NumberOfBytes: size }),\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      this.method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, KMSOperation.GenerateDataKey);\n\n    return KMSDataKey.fromJSON(res.json() as JSONObject);\n  }\n\n  protected override handleError(\n    response: RefinedResponse<ResponseType | undefined>,\n    operation?: string,\n  ): boolean {\n    const errored = super.handleError(response, operation);\n    if (!errored) {\n      return false;\n    }\n\n    const errorCode = response.error_code;\n    const error = response.json() as JSONObject;\n    if (errorCode >= 1400 && errorCode <= 1499) {\n      // In the event of certain errors, the message is not set.\n      // Also, note the inconsistency in casing...\n      const errorMessage: string = (error.Message as string) ||\n        (error.message as string) || (error.__type as string);\n\n      // Handle specifically the case of an invalid signature\n      if (error.__type === \"InvalidSignatureException\") {\n        throw new InvalidSignatureError(errorMessage, error.__type);\n      }\n\n      // Otherwise throw a standard service error\n      throw new KMSServiceError(\n        errorMessage,\n        error.__type as string,\n        operation as KMSOperation,\n      );\n    }\n\n    if (errorCode === 1500) {\n      throw new KMSServiceError(\n        \"An error occured on the server side\",\n        \"InternalServiceError\",\n        operation as KMSOperation,\n      );\n    }\n\n    return true;\n  }\n}\n\n/**\n * Class representing a KMS key\n */\nexport class KMSKey {\n  /**\n   * ARN of the key\n   */\n  keyArn: string;\n\n  /**\n   * Unique identifier of the key\n   */\n  keyId: string;\n\n  constructor(keyArn: string, KeyId: string) {\n    this.keyArn = keyArn;\n    this.keyId = KeyId;\n  }\n\n  static fromJSON(json: JSONObject) {\n    return new KMSKey(json.KeyArn as string, json.KeyId as string);\n  }\n}\n\n/**\n * Class representing a data key\n */\nexport class KMSDataKey {\n  /**\n   * The Amazon Resource Name (key ARN) of the KMS key that encrypted the data key.\n   */\n  id: string;\n\n  /**\n   * The (base64-encoded) encrypted copy of the data key.\n   */\n  ciphertextBlob: string;\n\n  /**\n   * The plaintext data key.\n   * Use this data key to encrypt your data outside of KMS. Then, remove it from memory as soon as possible.\n   */\n  plaintext: string;\n\n  constructor(CiphertextBlob: string, KeyId: string, Plaintext: string) {\n    this.ciphertextBlob = CiphertextBlob;\n    this.id = KeyId;\n    this.plaintext = Plaintext;\n  }\n\n  static fromJSON(json: JSONObject) {\n    return new KMSDataKey(\n      json.CiphertextBlob as string,\n      json.KeyId as string,\n      json.Plaintext as string,\n    );\n  }\n}\n\nexport class KMSServiceError extends AWSError {\n  operation: KMSOperation;\n\n  /**\n   * Constructs a KMSServiceError\n   *\n   * @param  {string} message - human readable error message\n   * @param  {string} code - A unique short code representing the error that was emitted\n   * @param  {string} operation - Name of the failed Operation\n   */\n  constructor(message: string, code: string, operation: KMSOperation) {\n    super(message, code);\n    this.name = \"KMSServiceError\";\n    this.operation = operation;\n  }\n}\n\n/**\n *  KMSOperation defines all currently implemented KMS Service operations.\n */\nenum KMSOperation {\n  GenerateDataKey = \"GenerateDataKey\",\n  ListKeys = \"ListKeys\",\n}\n\n/**\n *  KMSKeyLength describes possible key lenght values for KMS API data key operations.\n */\nenum KMSKeySize {\n  Size256 = 32,\n  Size512 = 64,\n}\n", "import { type Params, type RefinedResponse, type ResponseType } from \"k6/http\";\n\nimport { AWSConfig } from \"./config.ts\";\nimport { Endpoint } from \"./endpoint.ts\";\nimport { HTTPHeaders } from \"./http.ts\";\nimport {\n  DNSError,\n  DNSErrorKind,\n  GeneralError,\n  GeneralErrorKind,\n  HTTP2Error,\n  HTTP2ErrorKind,\n  TCPError,\n  TCPErrorKind,\n  TLSError,\n  TLSErrorKind,\n} from \"./error.ts\";\n\n/**\n * Class allowing to build requests targeting AWS APIs\n *\n * This class is meant to be used as a base class for specific\n * services clients. See S3Client or SecretsManagerClient for\n * usage examples.\n */\nexport class AWSClient {\n  readonly awsConfig: AWSConfig;\n  readonly serviceName: string;\n\n  // Because jslib-aws is mostly used as a way to setup or feed k6 tests, and\n  // we want the jslib-aws to be able to disregard k6's discardResponseBodies: meaning\n  // that for instance, even when setting discardResponseBodies to true in the k6 options, using\n  // s3.getObject still receives the underlying response body and returns data to the user.\n  //\n  // To achieve this, we set the responseType to 'text' in the baseRequestParams, as it\n  // will lead the http module to ignore the discardResponseBodies option.\n  //\n  // AWS Client classes can override this value if they want to receive the response body\n  // as a different type ('binary' for instance, e.g. S3Client.getObject).\n  //\n  // See #45: https://github.com/grafana/k6-jslib-aws/issues/45\n  readonly baseRequestParams: Params = {\n    responseType: \"text\",\n  };\n\n  private _endpoint?: Endpoint;\n\n  /**\n   * @param {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n   * @param  {string} serviceName - name of the service to target.\n   * @param  {URIEncodingConfig} URIencodingConfig - configures how requests URIs should be encoded.\n   */\n  constructor(awsConfig: AWSConfig, serviceName: string) {\n    this.awsConfig = awsConfig;\n    this.serviceName = serviceName;\n\n    // If an endpoint is provided in the config, set it\n    // to ensure the default endpoint is not used.\n    if (awsConfig.endpoint != undefined) {\n      this._endpoint = awsConfig.endpoint;\n    }\n  }\n\n  /**\n   * Represents the endpoint URL of the AWS service.\n   *\n   * If no custom endpoint is set, a default endpoint will be constructed\n   * using the service name and region provided in the AWS config.\n   *\n   * @type {Endpoint}\n   * @public\n   */\n  public get endpoint() {\n    if (this._endpoint == undefined) {\n      this._endpoint = new Endpoint(\n        `https://${this.serviceName}.${this.awsConfig.region}.amazonaws.com`,\n      );\n    }\n    return this._endpoint;\n  }\n\n  /**\n   * Updates the endpoint URL of the AWS service.\n   *\n   * This can be used to override the default AWS service endpoint or set a custom endpoint.\n   *\n   * @param {Endpoint} endpoint - The new endpoint to set for the AWS service.\n   * @public\n   */\n  public set endpoint(endpoint: Endpoint) {\n    this._endpoint = endpoint;\n  }\n\n  /**\n   * Handles the k6 http response potential errors produced when making a\n   * request to an AWS service.\n   *\n   * Importantly, this method only handles errors that emerge from the k6 http client itself, and\n   * won't handle AWS specific errors. To handle AWS specific errors, client classes are\n   * expected to implement their own error handling logic by overriding this method.\n   *\n   * @param response {RefinedResponse<ResponseType | undefined>} the response received by the k6 http client\n   * @param operation {string | undefined } the name of the operation that was attempted when the error occurred\n   * @param {boolean} returns true if an error was handled, false otherwise\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected handleError(\n    response: RefinedResponse<ResponseType | undefined>,\n    _operation?: string,\n  ): boolean {\n    const status: number = response.status;\n    const errorCode: number = response.error_code;\n    const errorMessage: string = response.error;\n\n    // We consider codes 200-299 as success.\n    //\n    // We do not consider 3xx as success as some services such as S3 can use\n    // 301 to indicate a bucket not found\n    if (\n      status >= 200 && status < 300 && errorMessage == \"\" && errorCode === 0\n    ) {\n      return false;\n    }\n\n    switch (errorCode) {\n      case GeneralErrorKind.GenericError:\n      case GeneralErrorKind.NonTCPNetworkError:\n      case GeneralErrorKind.InvalidURL:\n      case GeneralErrorKind.HTTPRequestTimeout:\n        throw new GeneralError(errorCode);\n      case DNSErrorKind.GenericDNSError:\n      case DNSErrorKind.NoIPFound:\n      case DNSErrorKind.BlacklistedIP:\n      case DNSErrorKind.BlacklistedHostname:\n        throw new DNSError(errorCode);\n      case TCPErrorKind.GenericTCPError:\n      case TCPErrorKind.BrokenPipeOnWrite:\n      case TCPErrorKind.UnknownTCPError:\n      case TCPErrorKind.GeneralTCPDialError:\n      case TCPErrorKind.DialTimeoutError:\n      case TCPErrorKind.DialConnectionRefused:\n      case TCPErrorKind.DialUnknownError:\n      case TCPErrorKind.ResetByPeer:\n        throw new TCPError(errorCode);\n      case TLSErrorKind.GeneralTLSError:\n      case TLSErrorKind.UnknownAuthority:\n      case TLSErrorKind.CertificateHostnameMismatch:\n        throw new TLSError(errorCode);\n      case HTTP2ErrorKind.GenericHTTP2Error:\n      case HTTP2ErrorKind.GeneralHTTP2GoAwayError:\n        throw new HTTP2Error(errorCode);\n    }\n\n    return true;\n  }\n}\n\n/**\n * Type alias representing the result of an AWSClient.buildRequest call\n */\nexport interface AWSRequest {\n  readonly url: string;\n  readonly headers: HTTPHeaders;\n}\n", "import { parseHTML } from \"k6/html\";\nimport http, { RefinedResponse, ResponseType } from \"k6/http\";\n\nimport { AWSClient } from \"./client.ts\";\nimport { AWSConfig } from \"./config.ts\";\nimport { AWSError } from \"./error.ts\";\nimport { SignedHTTPRequest } from \"./http.ts\";\nimport { InvalidSignatureError, SignatureV4 } from \"./signature.ts\";\n\n/** Class allowing to interact with Amazon AWS's S3 service */\nexport class S3Client extends AWSClient {\n  private readonly signature: SignatureV4;\n\n  /**\n   * Create a S3Client\n   *\n   * @param {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n   */\n  constructor(awsConfig: AWSConfig) {\n    super(awsConfig, \"s3\");\n\n    this.signature = new SignatureV4({\n      service: this.serviceName,\n      region: this.awsConfig.region,\n      credentials: {\n        accessKeyId: this.awsConfig.accessKeyId,\n        secretAccessKey: this.awsConfig.secretAccessKey,\n        sessionToken: this.awsConfig.sessionToken,\n      },\n\n      // S3 requires the URI path to be escaped\n      uriEscapePath: false,\n\n      // Signing S3 requests requires the payload to be hashed\n      // and the checksum to be included in the request headers.\n      applyChecksum: true,\n    });\n  }\n\n  /**\n   * Returns a list of all buckets owned by the authenticated sender of the request.\n   * To use this operation, you must have the s3:ListAllMyBuckets permission.\n   *\n   * @return  {Array.<S3Bucket>} buckets - An array of objects describing S3 buckets\n   *     with the following fields: name, and creationDate.\n   * @throws  {S3ServiceError}\n   * @throws  {InvalidSignatureError}\n   */\n  async listBuckets(): Promise<Array<S3Bucket>> {\n    const method = \"GET\";\n\n    const signedRequest: SignedHTTPRequest = this.signature.sign(\n      {\n        method: \"GET\",\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {},\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      method,\n      signedRequest.url,\n      signedRequest.body || null,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, \"ListBuckets\");\n\n    const buckets: Array<S3Bucket> = [];\n\n    const doc = parseHTML(res.body as string);\n\n    doc.find(\"Buckets\")\n      .children()\n      .each((_, bucketDefinition) => {\n        const bucket = {};\n\n        bucketDefinition.children().forEach((child) => {\n          switch (child.nodeName()) {\n            case \"name\":\n              Object.assign(bucket, { name: child.textContent() });\n              break;\n            case \"creationdate\":\n              Object.assign(bucket, {\n                creationDate: Date.parse(child.textContent()),\n              });\n          }\n        });\n\n        buckets.push(bucket as S3Bucket);\n      });\n\n    return buckets;\n  }\n\n  /**\n   * Returns some or all (up to 1,000) of the objects in a bucket.\n   *\n   * @param  {string} bucketName - Bucket name to list.\n   * @param  {string?} prefix='' - Limits the response to keys that begin with the specified prefix.\n   * @return {Array.<S3Object>} - returns an array of objects describing S3 objects\n   *     with the following fields: key, lastModified, etag, size and storageClass.\n   * @throws  {S3ServiceError}\n   * @throws  {InvalidSignatureError}\n   */\n  async listObjects(\n    bucketName: string,\n    prefix?: string,\n  ): Promise<Array<S3Object>> {\n    const method = \"GET\";\n\n    const signedRequest: SignedHTTPRequest = this.signature.sign(\n      {\n        method: method,\n        endpoint: this.endpoint,\n        path: encodeURI(`/${bucketName}/`),\n        query: {\n          \"list-type\": \"2\",\n          prefix: prefix || \"\",\n        },\n        headers: {},\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      method,\n      signedRequest.url,\n      signedRequest.body || null,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, \"ListObjectsV2\");\n\n    const objects: Array<S3Object> = [];\n\n    // Extract the objects definition from\n    // the XML response\n    parseHTML(res.body as string)\n      .find(\"Contents\")\n      .each((_, objectDefinition) => {\n        const obj = {};\n\n        objectDefinition.children().forEach((child) => {\n          switch (child.nodeName()) {\n            case \"key\":\n              Object.assign(obj, { key: child.textContent() });\n              break;\n            case \"lastmodified\":\n              Object.assign(obj, {\n                lastModified: Date.parse(child.textContent()),\n              });\n              break;\n            case \"etag\":\n              Object.assign(obj, { etag: child.textContent() });\n              break;\n            case \"size\":\n              Object.assign(obj, { size: parseInt(child.textContent()) });\n              break;\n            case \"storageclass\":\n              Object.assign(obj, { storageClass: child.textContent() });\n          }\n        });\n\n        objects.push(obj as S3Object);\n      });\n\n    return objects;\n  }\n  /**\n   * Retrieves an Object from Amazon S3.\n   *\n   * To use getObject, you must have `READ` access to the object.\n   *\n   * @param  {string} bucketName - The bucket name containing the object.\n   * @param  {string} objectKey - Key of the object to get.\n   * @return {S3Object} - returns the content of the fetched S3 Object.\n   * @throws  {S3ServiceError}\n   * @throws  {InvalidSignatureError}\n   */\n  async getObject(\n    bucketName: string,\n    objectKey: string,\n    additionalHeaders: object = {},\n  ): Promise<S3Object> {\n    // Prepare request\n    const method = \"GET\";\n\n    const signedRequest = this.signature.sign(\n      {\n        method: method,\n        endpoint: this.endpoint,\n        path: encodeURI(`/${bucketName}/${objectKey}`),\n        headers: {\n          ...additionalHeaders,\n        },\n      },\n      {},\n    );\n\n    // If the Accept header is set to 'application/octet-stream', we want to\n    // return the response as binary data.\n    let responseType: ResponseType = \"text\";\n    if (\n      \"Accept\" in additionalHeaders &&\n      additionalHeaders[\"Accept\"] !== undefined &&\n      additionalHeaders[\"Accept\"] === \"application/octet-stream\"\n    ) {\n      responseType = \"binary\";\n    }\n\n    const res = await http.asyncRequest(method, signedRequest.url, null, {\n      ...this.baseRequestParams,\n      headers: signedRequest.headers,\n      responseType: responseType as ResponseType,\n    });\n    this.handleError(res, \"GetObject\");\n\n    return new S3Object(\n      objectKey,\n      Date.parse(res.headers[\"Last-Modified\"]),\n      res.headers[\"ETag\"],\n      parseInt(res.headers[\"Content-Length\"]),\n      // The X-Amz-Storage-Class header is only set if the storage class is\n      // not the default 'STANDARD' one.\n      (res.headers[\"X-Amz-Storage-Class\"] ?? \"STANDARD\") as StorageClass,\n      res.body,\n    );\n  }\n  /**\n   * Adds an object to a bucket.\n   *\n   * You must have WRITE permissions on a bucket to add an object to it.\n   *\n   * @param  {string} bucketName - The bucket name containing the object.\n   * @param  {string} objectKey - Key of the object to put.\n   * @param  {string | ArrayBuffer} data - the content of the S3 Object to upload.\n   * @throws  {S3ServiceError}\n   * @throws  {InvalidSignatureError}\n   */\n  async putObject(\n    bucketName: string,\n    objectKey: string,\n    data: string | ArrayBuffer,\n    params?: PutObjectParams,\n  ): Promise<S3UploadedObject> {\n    // Prepare request\n    const method = \"PUT\";\n\n    const signedRequest = this.signature.sign(\n      {\n        method: method,\n        endpoint: this.endpoint,\n        path: encodeURI(`/${bucketName}/${objectKey}`),\n        headers: {\n          Host: this.endpoint.host,\n          ...(params?.contentDisposition && {\n            \"Content-Disposition\": params.contentDisposition,\n          }),\n          ...(params?.contentEncoding &&\n            { \"Content-Encoding\": params.contentEncoding }),\n          ...(params?.contentLength &&\n            { \"Content-Length\": params.contentLength }),\n          ...(params?.contentMD5 && { \"Content-MD5\": params.contentMD5 }),\n          ...(params?.contentType && { \"Content-Type\": params.contentType }),\n        },\n        body: data,\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n\n    this.handleError(res, \"PutObject\");\n\n    return S3UploadedObject.fromResponse(res, objectKey);\n  }\n\n  /**\n   * Removes the null version (if there is one) of an object and inserts a delete marker,\n   * which becomes the latest version of the object.\n   *\n   * @param  {string} bucketName - The bucket name containing the object.\n   * @param  {string} objectKey - Key of the object to delete.\n   * @throws  {S3ServiceError}\n   * @throws  {InvalidSignatureError}\n   */\n  async deleteObject(bucketName: string, objectKey: string): Promise<void> {\n    // Prepare request\n    const method = \"DELETE\";\n\n    const signedRequest = this.signature.sign(\n      {\n        method: method,\n        endpoint: this.endpoint,\n        path: encodeURI(`/${bucketName}/${objectKey}`),\n        headers: {},\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      method,\n      signedRequest.url,\n      signedRequest.body || null,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, \"DeleteObject\");\n  }\n\n  /**\n   * Copies an object from one bucket to another\n   *\n   * @param  {string} sourceBucket - The source bucket name containing the object.\n   * @param  {string} sourceKey - Key of the source object to copy.\n   * @param  {string} destinationBucket - The destination bucket name containing the object.\n   * @param  {string} destinationKey - Key of the destination object.\n   * @throws  {S3ServiceError}\n   * @throws  {InvalidSignatureError}\n   */\n  async copyObject(\n    sourceBucket: string,\n    sourceKey: string,\n    destinationBucket: string,\n    destinationKey: string,\n  ): Promise<void> {\n    const method = \"PUT\";\n\n    const bucketEndpoint = this.endpoint.copy();\n    bucketEndpoint.hostname = `${destinationBucket}.${this.endpoint.hostname}`;\n\n    const signedRequest = this.signature.sign(\n      {\n        method: method,\n        endpoint: bucketEndpoint,\n        path: encodeURI(`/${destinationKey}`),\n        headers: {\n          \"x-amz-copy-source\": `${sourceBucket}/${sourceKey}`,\n        },\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      method,\n      signedRequest.url,\n      signedRequest.body || null,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n\n    this.handleError(res, \"CopyObject\");\n  }\n\n  /**\n   * Creates a new multipart upload for a given objectKey.\n   * The uploadId returned can be used to upload parts to the object.\n   *\n   * @param  {string} bucketName - The bucket name containing the object.\n   * @param  {string} objectKey - Key of the object to upload.\n   * @return {S3MultipartUpload} - returns the uploadId of the newly created multipart upload.\n   * @throws  {S3ServiceError}\n   * @throws  {InvalidSignatureError}\n   */\n  async createMultipartUpload(\n    bucketName: string,\n    objectKey: string,\n  ): Promise<S3MultipartUpload> {\n    const method = \"POST\";\n\n    const bucketEndpoint = this.endpoint.copy();\n    bucketEndpoint.hostname = `${bucketName}.${this.endpoint.hostname}`;\n\n    const signedRequest = this.signature.sign(\n      {\n        method: method,\n        endpoint: bucketEndpoint,\n        path: encodeURI(`/${objectKey}`),\n        headers: {},\n        query: { uploads: \"\" },\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      method,\n      signedRequest.url,\n      signedRequest.body || null,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, \"CreateMultipartUpload\");\n\n    return new S3MultipartUpload(\n      objectKey,\n      parseHTML(res.body as string)\n        .find(\"UploadId\")\n        .text(),\n    );\n  }\n\n  /**\n   * Uploads a part in a multipart upload.\n   * @param {string} bucketName - The bucket name containing the object.\n   * @param {string} objectKey - Key of the object to upload.\n   * @param {string} uploadId - The uploadId of the multipart upload.\n   * @param {number} partNumber - The part number of the part to upload.\n   * @param {string | ArrayBuffer} data - The content of the part to upload.\n   * @return {S3Part} - returns the ETag of the uploaded part.\n   * @throws  {S3ServiceError}\n   */\n  async uploadPart(\n    bucketName: string,\n    objectKey: string,\n    uploadId: string,\n    partNumber: number,\n    data: string | ArrayBuffer,\n  ): Promise<S3Part> {\n    const method = \"PUT\";\n\n    const bucketEndpoint = this.endpoint.copy();\n    bucketEndpoint.hostname = `${bucketName}.${this.endpoint.hostname}`;\n\n    const signedRequest = this.signature.sign(\n      {\n        method: method,\n        endpoint: bucketEndpoint,\n        path: encodeURI(`/${objectKey}`),\n        headers: {},\n        body: data,\n        query: {\n          partNumber: `${partNumber}`,\n          uploadId: `${uploadId}`,\n        },\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      method,\n      signedRequest.url,\n      signedRequest.body || null,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, \"UploadPart\");\n\n    return new S3Part(partNumber, res.headers[\"Etag\"]);\n  }\n\n  /**\n   * Completes a multipart upload by assembling previously uploaded parts.\n   *\n   * @param  {string} bucketName - The bucket name containing the object.\n   * @param  {string} objectKey - Key of the object to delete.\n   * @param  {string} uploadId - The uploadId of the multipart upload to complete.\n   * @param  {S3Part[]} parts - The parts to assemble.\n   * @throws  {S3ServiceError}\n   * @throws  {InvalidSignatureError}\n   */\n  async completeMultipartUpload(\n    bucketName: string,\n    objectKey: string,\n    uploadId: string,\n    parts: S3Part[],\n  ) {\n    // Prepare request\n    const method = \"POST\";\n    const body = `<CompleteMultipartUpload>${\n      parts\n        .map(\n          (part) =>\n            `<Part><PartNumber>${part.partNumber}</PartNumber><ETag>${part.eTag}</ETag></Part>`,\n        )\n        .join(\"\")\n    }</CompleteMultipartUpload>`;\n\n    const bucketEndpoint = this.endpoint.copy();\n    bucketEndpoint.hostname = `${bucketName}.${this.endpoint.hostname}`;\n\n    const signedRequest = this.signature.sign(\n      {\n        method: method,\n        endpoint: bucketEndpoint,\n        path: encodeURI(`/${objectKey}`),\n        headers: {},\n        body: body,\n        query: {\n          uploadId: `${uploadId}`,\n        },\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      method,\n      signedRequest.url,\n      signedRequest.body || null,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, \"CompleteMultipartUpload\");\n  }\n\n  /**\n   * Aborts a multipart upload.\n   *\n   * @param  {string} bucketName - The bucket name containing the object.\n   * @param  {string} objectKey - Key of the object to delete.\n   * @param  {string} uploadId - The uploadId of the multipart upload to abort.\n   * @throws  {S3ServiceError}\n   * @throws  {InvalidSignatureError}\n   */\n  async abortMultipartUpload(\n    bucketName: string,\n    objectKey: string,\n    uploadId: string,\n  ) {\n    const method = \"DELETE\";\n\n    const bucketEndpoint = this.endpoint.copy();\n    bucketEndpoint.hostname = `${bucketName}.${this.endpoint.hostname}`;\n\n    const signedRequest = this.signature.sign(\n      {\n        method: method,\n        endpoint: bucketEndpoint,\n        path: encodeURI(`/${objectKey}`),\n        headers: {},\n        query: {\n          uploadId: `${uploadId}`,\n        },\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      method,\n      signedRequest.url,\n      signedRequest.body || null,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, \"AbortMultipartUpload\");\n  }\n\n  protected override handleError(\n    response: RefinedResponse<ResponseType | undefined>,\n    operation?: string,\n  ): boolean {\n    // As we are overriding the AWSClient method: call the parent class handleError method\n    const errored = super.handleError(response);\n    if (!errored) {\n      return false;\n    }\n\n    // A 301 response is returned when the bucket is not found.\n    // Generally meaning that either the bucket name is wrong or the\n    // region is wrong.\n    //\n    // See: https://github.com/grafana/k6/issues/2474\n    // See: https://github.com/golang/go/issues/49281\n    const errorMessage: string = response.error;\n    if (\n      response.status == 301 || (errorMessage && errorMessage.startsWith(\"301\"))\n    ) {\n      throw new S3ServiceError(\n        \"Resource not found\",\n        \"ResourceNotFound\",\n        operation as S3Operation,\n      );\n    }\n\n    const awsError = AWSError.parseXML(response.body as string);\n    switch (awsError.code) {\n      case \"AuthorizationHeaderMalformed\":\n        throw new InvalidSignatureError(awsError.message, awsError.code);\n      default:\n        throw new S3ServiceError(\n          awsError.message,\n          awsError.code || \"unknown\",\n          operation as S3Operation,\n        );\n    }\n  }\n}\n\n/** Class representing a S3 Bucket */\nexport class S3Bucket {\n  name: string;\n  creationDate: Date;\n\n  /**\n   * Create an S3 Bucket\n   *\n   * @param  {string} name - S3 bucket's name\n   * @param  {Date} creationDate - S3 bucket's creation date\n   */\n  constructor(name: string, creationDate: Date) {\n    this.name = name;\n    this.creationDate = creationDate;\n  }\n}\n\n/** Class representing an S3 Object */\nexport class S3Object {\n  key: string;\n  lastModified: number;\n  etag: string;\n  size: number;\n  storageClass: StorageClass;\n  data?: string | ArrayBuffer | null;\n\n  /**\n   * Create an S3 Object\n   *\n   * @param  {string} key - S3 object's key\n   * @param  {Date} lastModified - S3 object last modification date\n   * @param  {string} etag - S3 object's etag\n   * @param  {number} size - S3 object's size\n   * @param  {StorageClass} storageClass - S3 object's storage class\n   * @param  {string | ArrayBuffer | null} data=null - S3 Object's data\n   */\n  constructor(\n    key: string,\n    lastModified: number,\n    etag: string,\n    size: number,\n    storageClass: StorageClass,\n    data?: string | ArrayBuffer | null,\n  ) {\n    this.key = key;\n    this.lastModified = lastModified;\n    this.etag = etag;\n    this.size = size;\n    this.storageClass = storageClass;\n    this.data = data;\n  }\n}\n\n/**\n * Class representing an uploaded S3 Object, resulting from putObject operation.\n */\nexport class S3UploadedObject {\n  key: string;\n\n  /**\n   * Entity tag for the uploaded object.\n   *\n   * General purpose buckets - To ensure that data is not corrupted traversing the network, for objects where the ETag is the MD5 digest of the object, you can calculate the MD5 while putting an object to Amazon S3 and compare the returned ETag to the calculated MD5 value.\n   *\n   * Directory buckets - The ETag for the object in a directory bucket isn't the MD5 digest of the object.\n   */\n  etag: string;\n\n  /**\n   * The Base64 encoded, 32-bit CRC32C checksum of the object. This checksum is only present if the checksum was uploaded with the object.\n   */\n  crc32?: string;\n\n  /**\n   * The Base64 encoded, 32-bit CRC32C checksum of the object. This checksum is only present if the checksum was uploaded with the object.\n   */\n  crc32c?: string;\n\n  /**\n   * The Base64 encoded, 64-bit CRC64NVME checksum of the object.\n   *\n   * This header is present if the object was uploaded with the CRC64NVME checksum algorithm, or if it was uploaded without a checksum.\n   */\n  crc64nvme?: string;\n\n  /**\n   * The Base64 encoded, 160-bit SHA1 digest of the object. This will only be present if the object was uploaded with the SHA1 checksum algorithm.\n   */\n  sha1?: string;\n\n  /**\n   * The Base64 encoded, 256-bit SHA256 digest of the object. This will only be present if the object was uploaded with the SHA256 checksum algorithm.\n   */\n  sha256?: string;\n\n  /**\n   * The type of checksum used to upload the object.\n   */\n  checksumType: S3ChecksumType;\n\n  /**\n   * The size of the object in bytes. The value is only present if you append to an object.\n   */\n  size?: number;\n\n  constructor(\n    key: string,\n    etag: string,\n    options?: {\n      crc32?: string;\n      crc32c?: string;\n      crc64nvme?: string;\n      sha1?: string;\n      sha256?: string;\n      checksumType?: S3ChecksumType;\n      size?: number;\n    },\n  ) {\n    this.key = key;\n    this.etag = etag;\n    this.crc32 = options?.crc32;\n    this.crc32c = options?.crc32c;\n    this.crc64nvme = options?.crc64nvme;\n    this.sha1 = options?.sha1;\n    this.sha256 = options?.sha256;\n    this.checksumType = options?.checksumType || \"FULL_OBJECT\";\n    this.size = options?.size;\n  }\n\n  /**\n   * Creates an S3UploadedObject from a k6 HTTP response\n   *\n   * @param {RefinedResponse<ResponseType>} response - The HTTP response from a PutObject operation\n   * @param {string} key - The key of the uploaded object\n   * @returns {S3UploadedObject} A new S3UploadedObject instance\n   */\n  static fromResponse(\n    response: RefinedResponse<ResponseType>,\n    key: string,\n  ): S3UploadedObject {\n    const options: {\n      crc32?: string;\n      crc32c?: string;\n      crc64nvme?: string;\n      sha1?: string;\n      sha256?: string;\n      checksumType?: S3ChecksumType;\n      size?: number;\n    } = {};\n\n    // Extract checksum values from headers\n    if (response.headers[\"x-amz-checksum-crc32\"]) {\n      options.crc32 = response.headers[\"x-amz-checksum-crc32\"];\n    }\n\n    if (response.headers[\"x-amz-checksum-crc32c\"]) {\n      options.crc32c = response.headers[\"x-amz-checksum-crc32c\"];\n    }\n\n    if (response.headers[\"x-amz-checksum-crc64nvme\"]) {\n      options.crc64nvme = response.headers[\"x-amz-checksum-crc64nvme\"];\n    }\n\n    if (response.headers[\"x-amz-checksum-sha1\"]) {\n      options.sha1 = response.headers[\"x-amz-checksum-sha1\"];\n    }\n\n    if (response.headers[\"x-amz-checksum-sha256\"]) {\n      options.sha256 = response.headers[\"x-amz-checksum-sha256\"];\n    }\n\n    // Extract checksum algorithm type\n    if (response.headers[\"x-amz-checksum-algorithm\"]) {\n      options.checksumType =\n        response.headers[\"x-amz-checksum-algorithm\"] === \"COMPOSITE\"\n          ? \"COMPOSITE\"\n          : \"FULL_OBJECT\";\n    }\n\n    // Extract content length if available\n    if (response.headers[\"x-amz-object-size\"]) {\n      options.size = parseInt(response.headers[\"x-amz-object-size\"]);\n    }\n\n    // Get ETag from response headers\n    const etag = response.headers[\"ETag\"] || \"\";\n\n    return new S3UploadedObject(key, etag, options);\n  }\n}\n\n/** Class representing a S3 Multipart Upload */\nexport class S3MultipartUpload {\n  key: string;\n  uploadId: string;\n\n  /**\n   * Create an S3 Multipart Upload\n   * @param  {string} key - S3 object's key\n   * @param  {string} uploadId - S3 multipart upload id\n   */\n\n  constructor(key: string, uploadId: string) {\n    this.key = key;\n    this.uploadId = uploadId;\n  }\n}\n\n/** Class representing a S3 Part */\nexport class S3Part {\n  partNumber: number;\n  eTag: string;\n\n  /**\n   * Create an S3 Part\n   * @param  {number} partNumber - Part number\n   * @param  {string} eTag - Part's etag\n   */\n\n  constructor(partNumber: number, eTag: string) {\n    this.partNumber = partNumber;\n    this.eTag = eTag;\n  }\n}\n\n/**\n * Error indicating a S3 operation failed\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class S3ServiceError extends AWSError {\n  operation: string;\n\n  /**\n   * Constructs a S3ServiceError\n   *\n   * @param  {string} message - human readable error message\n   * @param  {string} code - A unique short code representing the error that was emitted\n   * @param  {string} operation - Name of the failed Operation\n   */\n  constructor(message: string, code: string, operation: string) {\n    super(message, code);\n    this.name = \"S3ServiceError\";\n    this.operation = operation;\n  }\n}\n\n/**\n * S3Operation describes possible values for S3 API operations,\n * as defined by AWS APIs.\n */\ntype S3Operation =\n  | \"ListBuckets\"\n  | \"ListObjectsV2\"\n  | \"GetObject\"\n  | \"PutObject\"\n  | \"DeleteObject\"\n  | \"CopyObject\"\n  | \"CreateMultipartUpload\"\n  | \"CompleteMultipartUpload\"\n  | \"UploadPart\"\n  | \"AbortMultipartUpload\";\n\n/**\n * The type of checksum used to upload the object.\n */\ntype S3ChecksumType = \"COMPOSITE\" | \"FULL_OBJECT\";\n\n/**\n * Describes the class of storage used to store a S3 object.\n */\ntype StorageClass =\n  | \"STANDARD\"\n  | \"REDUCED_REDUNDANCY\"\n  | \"GLACIER\"\n  | \"STANDARD_IA\"\n  | \"INTELLIGENT_TIERING\"\n  | \"DEEP_ARCHIVE\"\n  | \"OUTPOSTS\"\n  | \"GLACIER_IR\"\n  | undefined;\n\n/**\n * PutObjectParams describes the parameters that can be passed to the PutObject operation.\n */\nexport interface PutObjectParams {\n  /**\n   * Specifies presentational information for the object.\n   *\n   * For more information, see https://www.rfc-editor.org/rfc/rfc6266#section-4.\n   */\n  contentDisposition?: string;\n\n  /**\n   * Specifies what content encodings have been applied to the object and thus\n   * what decoding mechanisms must be applied to obtain the media-type referenced\n   * by the ContentType option.\n   *\n   * For more information, see https://www.rfc-editor.org/rfc/rfc9110.html#field.content-encoding.\n   */\n  contentEncoding?: string;\n\n  /**\n   * Size of the body in bytes. This parameter is useful when the size of the body cannot be\n   * determined automatically.\n   *\n   * For more information, see https://www.rfc-editor.org/rfc/rfc9110.html#name-content-length.\n   */\n  contentLength?: string;\n\n  /**\n   * The base64-encoded 128-bit MD5 digest of the message (without the headers) according to RFC 1864.\n   * This header can be used as a message integrity check to verify that the data is the same data that\n   * was originally sent.\n   *\n   * Although it is optional, we recommend using the Content-MD5 mechanism as an end-to-end integrity\n   * check.\n   */\n  contentMD5?: string;\n\n  /**\n   * A standard MIME type describing the format of the contents.\n   *\n   * For more information, see https://www.rfc-editor.org/rfc/rfc9110.html#name-content-type.\n   */\n  contentType?: string;\n}\n", "import { JSONArray, JSONObject } from \"k6\";\nimport http, { RefinedResponse, ResponseType } from \"k6/http\";\n\nimport { AWSClient } from \"./client.ts\";\nimport { AWSConfig } from \"./config.ts\";\nimport { AMZ_TARGET_HEADER } from \"./constants.ts\";\nimport { AWSError } from \"./error.ts\";\nimport { HTTPHeaders, HTTPMethod } from \"./http.ts\";\nimport { InvalidSignatureError, SignatureV4 } from \"./signature.ts\";\n\n/**\n * Class allowing to interact with Amazon AWS's SecretsManager service\n */\nexport class SecretsManagerClient extends AWSClient {\n  private readonly signature: SignatureV4;\n  private readonly method: HTTPMethod;\n  private readonly commonHeaders: HTTPHeaders;\n\n  /**\n   * Create a SecretsManagerClient\n   * @param  {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n   */\n  constructor(awsConfig: AWSConfig) {\n    super(awsConfig, \"secretsmanager\");\n\n    this.signature = new SignatureV4({\n      service: this.serviceName,\n      region: this.awsConfig.region,\n      credentials: {\n        accessKeyId: this.awsConfig.accessKeyId,\n        secretAccessKey: this.awsConfig.secretAccessKey,\n        sessionToken: this.awsConfig.sessionToken,\n      },\n      uriEscapePath: true,\n      applyChecksum: false,\n    });\n\n    // All interactions with the Secrets Manager service\n    // are made via the GET or POST method.\n    this.method = \"POST\";\n    this.commonHeaders = {\n      \"Content-Type\": \"application/x-amz-json-1.1\",\n    };\n  }\n\n  /**\n   * Returns a list of all secrets owned by the authenticated sender of the request.\n   * To use this operation, you must have the secretsmanager:ListSecrets permission.\n   *\n   * @return  {Array.<Secret>} secrets - An array of objects describing Secret Manager's secrets\n   * @throws  {SecretsManagerServiceError}\n   * @throws  {InvalidSignatureError}\n   */\n  async listSecrets(): Promise<Array<Secret>> {\n    const signedRequest = this.signature.sign(\n      {\n        method: this.method,\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          [AMZ_TARGET_HEADER]: `${this.serviceName}.ListSecrets`,\n        },\n        body: JSON.stringify({}),\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      this.method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, SecretsManagerOperation.ListSecrets);\n    const json: JSONArray = res.json(\"SecretList\") as JSONArray;\n\n    return json.map((s) => Secret.fromJSON(s as JSONObject));\n  }\n\n  /**\n   * Retrieves a secret from Amazon Sercets Manager\n   *\n   * @param {string} id - The ARN or name of the secret to retrieve.\n   * @returns {Secret} - returns the content of the fetched Secret object.\n   * @throws {SecretsManagerServiceError}\n   * @throws {InvalidSignatureError}\n   */\n  async getSecret(id: string): Promise<Secret | undefined> {\n    const signedRequest = this.signature.sign(\n      {\n        method: this.method,\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          [AMZ_TARGET_HEADER]: `${this.serviceName}.GetSecretValue`,\n        },\n        body: JSON.stringify({ SecretId: id }),\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      this.method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n\n    this.handleError(res, SecretsManagerOperation.GetSecretValue);\n\n    return Secret.fromJSON(res.json() as JSONObject);\n  }\n\n  /**\n   * Creates a new secret\n   *\n   * Note that this method only supports string-based values at the moment.\n   *\n   * @param  {string} name - The name of the new secret.\n   *     The secret name can contain ASCII letters, numbers, and the following characters: /_+=.@\n   * @param  {string} secret - The text data to encrypt and store in this new version of the secret.\n   * @param  {string} description - The description of the secret.\n   * @param  {string} versionID=null - Version of the secret. This value helps ensure idempotency.\n   *     As a default, if no versionID is provided, one will be created for you using the UUID v4\n   *     algorithm.\n   * @param  {Array.<Object>} tags=[] - A list of tags to attach to the secret. Each tag is a key and\n   *     value pair of strings in a JSON text string. Note that tag key names are case sensitive.\n   * @returns {Secret} - returns the created secret\n   * @throws {SecretsManagerServiceError}\n   * @throws {InvalidSignatureError}\n   */\n  async createSecret(\n    name: string,\n    secret: string,\n    description: string,\n    versionID?: string,\n    tags?: Array<object>,\n  ): Promise<Secret> {\n    versionID = versionID ?? crypto.randomUUID();\n\n    const signedRequest = this.signature.sign(\n      {\n        method: this.method,\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          [AMZ_TARGET_HEADER]: `${this.serviceName}.CreateSecret`,\n        },\n        body: JSON.stringify({\n          Name: name,\n          Description: description,\n          SecretString: secret,\n          ClientRequestToken: versionID,\n          Tags: tags,\n        }),\n      },\n      {},\n    );\n\n    // Ensure to include the desired 'Action' in the X-Amz-Target\n    // header field, as documented by the AWS API docs.\n    // headers['X-Amz-Target'] = `${this.serviceName}.CreateSecret`\n\n    const res = await http.asyncRequest(\n      this.method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, SecretsManagerOperation.CreateSecret);\n\n    return Secret.fromJSON(res.json() as JSONObject);\n  }\n  /**\n   * Update a secret's value.\n   *\n   * Note that this method only support string-based values at the moment.\n   *\n   * @param  {string} id - The ARN or name of the secret to update.\n   * @param  {string} secret - The text data to encrypt and store in this new version of the secret.\n   * @param  {} versionID=null  - A unique identifier for the new version of the secret. This value helps ensure idempotency.\n   *     As a default, if no versionID is provided, one will be created for you using the UUID v4\n   * @throws {SecretsManagerServiceError}\n   * @throws {InvalidSignatureError}\n   */\n  async putSecretValue(\n    id: string,\n    secret: string,\n    versionID?: string,\n  ): Promise<Secret> {\n    versionID = versionID ?? crypto.randomUUID();\n\n    const signedRequest = this.signature.sign(\n      {\n        method: this.method,\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          [AMZ_TARGET_HEADER]: `${this.serviceName}.PutSecretValue`,\n        },\n        body: JSON.stringify({\n          SecretId: id,\n          SecretString: secret,\n          ClientRequestToken: versionID,\n        }),\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      this.method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, SecretsManagerOperation.PutSecretValue);\n\n    return Secret.fromJSON(res.json() as JSONObject);\n  }\n\n  /**\n   * Deletes a secret and all of its versions.\n   *\n   * You can specify a recovery window during which you can restore the secret.\n   * The minimum recovery window is 7 days. The default recovery window is 30 days.\n   *\n   * @param {string} secretID - The ARN or name of the secret to delete.\n   * @param {number} recoveryWindow - The number of days from 7 to 30 that Secrets Manager\n   *     waits before permanently deleting the secret.\n   * @throws {SecretsManagerServiceError}\n   * @throws {InvalidSignatureError}\n   */\n  async deleteSecret(\n    id: string,\n    { recoveryWindow = 30, noRecovery = false }: {\n      recoveryWindow: number;\n      noRecovery: boolean;\n    },\n  ): Promise<void> {\n    const payload: { [key: string]: string | boolean | number } = {\n      SecretId: id,\n    };\n\n    // noRecovery and recoveryWindow are exclusive parameters\n    if (noRecovery === true) {\n      payload[\"ForceDeleteWithoutRecovery\"] = true;\n    } else {\n      payload[\"RecoveryWindowInDays\"] = recoveryWindow;\n    }\n\n    const signedRequest = this.signature.sign(\n      {\n        method: this.method,\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          [AMZ_TARGET_HEADER]: `${this.serviceName}.DeleteSecret`,\n        },\n        body: JSON.stringify(payload),\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      this.method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, SecretsManagerOperation.DeleteSecret);\n  }\n\n  protected override handleError(\n    response: RefinedResponse<ResponseType | undefined>,\n    operation?: string,\n  ): boolean {\n    const errored = super.handleError(response, operation);\n    if (!errored) {\n      return false;\n    }\n\n    const errorCode = response.error_code;\n    const error = response.json() as JSONObject;\n    if (errorCode >= 1400 && errorCode <= 1499) {\n      // In the event of certain errors, the message is not set.\n      // Also, note the inconsistency in casing...\n      const errorMessage: string = (error.Message as string) ||\n        (error.message as string) || (error.__type as string);\n\n      // Handle specifically the case of an invalid signature\n      if (error.__type === \"InvalidSignatureException\") {\n        throw new InvalidSignatureError(errorMessage, error.__type);\n      }\n\n      // Otherwise throw a standard service error\n      throw new SecretsManagerServiceError(\n        errorMessage,\n        error.__type as string,\n        operation as SecretsManagerOperation,\n      );\n    }\n\n    if (errorCode === 1500) {\n      throw new SecretsManagerServiceError(\n        \"An error occured on the server side\",\n        \"InternalServiceError\",\n        operation as SecretsManagerOperation,\n      );\n    }\n\n    return true;\n  }\n}\n\n// TODO: create a Tags type\n\n/**\n * Class representing a Secret Manager's secret\n */\nexport class Secret {\n  name: string;\n  arn: string;\n  secret: string;\n  createdDate: number;\n  lastAccessedDate: number;\n  lastChangedDate: number;\n  tags: Array<{ [key: string]: string }>;\n\n  /**\n   * Constructs a Secret Manager's Secret\n   *\n   * @param  {string} name - The friendly name of the secret.\n   * @param  {string} arn - The ARN of the secret.\n   * @param  {number} createdDate - The date and time that this version of the secret was created.\n   * @param  {number} lastAccessedDate - The last date that this secret was accessed. This value is\n   *     truncated to midnight of the date and therefore shows only the date, not the time.\n   * @param  {number} lastChangedDate - The last date and time that this secret was modified in any way.\n   * @param  {Array.<Object>} tags - The list of user-defined tags associated with the secret.\n   */\n  constructor(\n    name: string,\n    arn: string,\n    secretString: string,\n    createdDate: number,\n    lastAccessedDate: number,\n    lastChangedDate: number,\n    tags: Array<{ [key: string]: string }> = [],\n  ) {\n    this.name = name;\n    this.arn = arn;\n    this.secret = secretString;\n    this.createdDate = createdDate;\n    this.lastAccessedDate = lastAccessedDate;\n    this.lastChangedDate = lastChangedDate;\n    this.tags = tags;\n  }\n\n  /**\n   * Parses and constructs a Secret Manager's Secret from the content\n   * of a JSON response returned by the AWS service\n   *\n   * @param  {Object} json - JSON object as returned and parsed from\n   *     the AWS service's API call.\n   * @returns {Secret}\n   */\n  static fromJSON(json: JSONObject) {\n    return new Secret(\n      json.Name as string,\n      json.ARN as string,\n      json.SecretString as string,\n      json.CreatedDate as number,\n      json.LastAccessedDate as number,\n      json.LastChangedDate as number,\n      json.Tags as Array<{ [key: string]: string }>,\n    );\n  }\n}\n\nexport class SecretsManagerServiceError extends AWSError {\n  operation: SecretsManagerOperation;\n\n  /**\n   * Constructs a SecretsManagerServiceError\n   *\n   * @param  {string} message - human readable error message\n   * @param  {string} code - A unique short code representing the error that was emitted\n   * @param  {string} operation - Name of the failed Operation\n   */\n  constructor(\n    message: string,\n    code: string,\n    operation: SecretsManagerOperation,\n  ) {\n    super(message, code);\n    this.name = \"SecretsManagerServiceError\";\n    this.operation = operation;\n  }\n}\n\n/**\n *  SecretsManagerOperation defines all currently implemented Secrets Manager Service operations.\n */\nenum SecretsManagerOperation {\n  ListSecrets = \"ListSecrets\",\n  GetSecretValue = \"GetSecretValue\",\n  CreateSecret = \"CreateSecret\",\n  PutSecretValue = \"PutSecretValue\",\n  DeleteSecret = \"DeleteSecret\",\n}\n", "import { JSONObject } from \"k6\";\nimport http, { RefinedResponse, ResponseType } from \"k6/http\";\n\nimport { AWSClient } from \"./client.ts\";\nimport { AWSConfig } from \"./config.ts\";\nimport { AMZ_TARGET_HEADER } from \"./constants.ts\";\nimport { AWSError } from \"./error.ts\";\nimport { HTTPHeaders, HTTPMethod } from \"./http.ts\";\nimport { InvalidSignatureError, SignatureV4 } from \"./signature.ts\";\n\n/**\n * Class allowing to interact with Amazon AWS's Systems Manager service\n */\nexport class SystemsManagerClient extends AWSClient {\n  private readonly signature: SignatureV4;\n  private readonly method: HTTPMethod;\n  private readonly commonHeaders: HTTPHeaders;\n\n  /**\n   * Create a SystemsManagerClient\n   * @param  {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n   */\n  constructor(awsConfig: AWSConfig) {\n    super(awsConfig, \"ssm\");\n\n    // All interactions with the Systems Manager service\n    // are made via the POST method.\n    this.method = \"POST\";\n    this.commonHeaders = {\n      \"Content-Type\": \"application/x-amz-json-1.1\",\n    };\n\n    this.signature = new SignatureV4({\n      service: this.serviceName,\n      region: awsConfig.region,\n      credentials: {\n        accessKeyId: awsConfig.accessKeyId,\n        secretAccessKey: awsConfig.secretAccessKey,\n        sessionToken: awsConfig.sessionToken,\n      },\n      uriEscapePath: true,\n      applyChecksum: false,\n    });\n  }\n\n  /**\n   * Retrieves a parameter from Amazon Systems Manager\n   *\n   * @param {string} name - The ARN or name of the parameter to retrieve.\n   * @param {boolean} withDecryption - whether returned secure string parameters should be decrypted.\n   * @returns {SystemsManagerParameter} - returns the fetched Parameter object.\n   * @throws {SystemsManagerServiceError}\n   * @throws {InvalidSignatureError}\n   */\n  async getParameter(\n    name: string,\n    withDecryption: boolean = false,\n  ): Promise<SystemsManagerParameter | undefined> {\n    const signedRequest = this.signature.sign(\n      {\n        method: this.method,\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          [AMZ_TARGET_HEADER]: `AmazonSSM.GetParameter`,\n        },\n        body: JSON.stringify({ Name: name, WithDecryption: withDecryption }),\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      this.method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, SystemsManagerOperation.GetParameter);\n\n    return SystemsManagerParameter.fromJSON(res.json() as JSONObject);\n  }\n\n  protected override handleError(\n    response: RefinedResponse<ResponseType | undefined>,\n    operation?: string,\n  ): boolean {\n    const errored = super.handleError(response, operation);\n    if (!errored) {\n      return false;\n    }\n\n    const errorCode = response.error_code;\n    const error = response.json() as JSONObject;\n    if (errorCode >= 1400 && errorCode <= 1499) {\n      // In the event of certain errors, the message is not set.\n      // Also, note the inconsistency in casing...\n      const errorMessage: string = (error.Message as string) ||\n        (error.message as string) || (error.__type as string);\n\n      // Handle specifically the case of an invalid signature\n      if (error.__type === \"InvalidSignatureException\") {\n        throw new InvalidSignatureError(errorMessage, error.__type);\n      }\n\n      // Otherwise throw a standard service error\n      throw new SystemsManagerServiceError(\n        errorMessage,\n        error.__type as string,\n        operation as SystemsManagerOperation,\n      );\n    }\n\n    if (errorCode === 1500) {\n      throw new SystemsManagerServiceError(\n        \"An error occured on the server side\",\n        \"InternalServiceError\",\n        operation as SystemsManagerOperation,\n      );\n    }\n\n    return true;\n  }\n}\n\n/**\n * Class representing a Systems Manager's Parameter\n */\nexport class SystemsManagerParameter {\n  /**\n   * The Amazon Resource Name (ARN) of the parameter.\n   */\n  arn: string;\n\n  /**\n   * The data type of the parameter, such as text or aws:ec2:image.\n   * The default is text.\n   */\n  dataType: string;\n\n  /**\n   * Date the parameter was last changed or updated and the parameter version was created.\n   */\n  lastModifiedDate: number;\n\n  /**\n   * The friendly name of the parameter.\n   */\n  name: string;\n\n  /**\n   * Either the version number or the label used to retrieve the parameter value. Specify selectors by using one of the following formats:\n   *  parameter_name:version\n   *  parameter_name:label\n   */\n  selector: string;\n\n  /**\n   * plies to parameters that reference information in other AWS services. SourceResult is the raw result or response from the source.\n   */\n  sourceResult: string;\n\n  /**\n   * The type of parameter. Valid values include the following: String, StringList, and SecureString.\n   */\n  type: string;\n\n  /**\n   * The parameter value.\n   */\n  value: string;\n\n  /**\n   * The parameter version.\n   */\n  version: number;\n\n  /**\n   * Constructs a Systems Manager's Parameter\n   *\n   * @param  {string} arn - The Amazon Resource Name (ARN) of the parameter.\n   * @param  {string} dataType - The data type of the parameter, such as text or aws:ec2:image. The default is text.\n   * @param  {number} lastModifiedDate - Date the parameter was last changed or updated and the parameter version was created.\n   * @param  {string} name - The friendly name of the parameter.\n   * @param  {string} selector - Either the version number or the label used to retrieve the parameter value. Specify selectors by using one of the following formats:\n   *  parameter_name:version\n   *  parameter_name:label\n   * @param  {string} sourceResult - Applies to parameters that reference information in other AWS services. SourceResult is the raw result or response from the source.\n   * @param  {string} type - The type of parameter. Valid values include the following: String, StringList, and SecureString.\n   * @param  {string} value - The parameter value.\n   * @param  {number} version - The parameter version.\n   */\n  constructor(\n    arn: string,\n    dataType: string,\n    lastModifiedDate: number,\n    name: string,\n    selector: string,\n    sourceResult: string,\n    type: string,\n    value: string,\n    version: number,\n  ) {\n    this.arn = arn;\n    this.dataType = dataType;\n    this.lastModifiedDate = lastModifiedDate;\n    this.name = name;\n    this.selector = selector;\n    this.sourceResult = sourceResult;\n    this.type = type;\n    this.value = value;\n    this.version = version;\n  }\n\n  /**\n   * Parses and constructs a Systems Manager's Parameter from the content\n   * of a JSON response returned by the AWS service\n   *\n   * @param  {Object} json - JSON object as returned and parsed from\n   *     the AWS service's API call.\n   * @returns {SystemsManagerParameter}\n   */\n  static fromJSON(json: JSONObject): SystemsManagerParameter {\n    const parameter = json.Parameter as JSONObject;\n\n    return new SystemsManagerParameter(\n      parameter.ARN as string,\n      parameter.DataType as string,\n      parameter.LastModifiedDate as number,\n      parameter.Name as string,\n      parameter.Selector as string,\n      parameter.SourceResult as string,\n      parameter.Type as string,\n      parameter.Value as string,\n      parameter.Version as number,\n    );\n  }\n}\n\nexport class SystemsManagerServiceError extends AWSError {\n  operation: SystemsManagerOperation;\n\n  /**\n   * Constructs a SystemsManagerServiceError\n   *\n   * @param  {string} message - human readable error message\n   * @param  {string} code - A unique short code representing the error that was emitted\n   * @param  {SystemsManagerOperation} operation - Name of the failed Operation\n   */\n  constructor(\n    message: string,\n    code: string,\n    operation: SystemsManagerOperation,\n  ) {\n    super(message, code);\n    this.name = \"SystemsManagerServiceError\";\n    this.operation = operation;\n  }\n}\n\n/**\n *  SystemsManagerOperation defines all currently implemented Systems Manager operations.\n */\nenum SystemsManagerOperation {\n  GetParameter = \"GetParameter\",\n}\n", "import http, { RefinedResponse, ResponseType } from \"k6/http\";\n\nimport { AWSClient } from \"./client.ts\";\nimport { AWSConfig } from \"./config.ts\";\nimport { InvalidSignatureError, SignatureV4 } from \"./signature.ts\";\nimport { HTTPHeaders } from \"./http.ts\";\nimport { AWSError } from \"./error.ts\";\nimport { AMZ_TARGET_HEADER } from \"./constants.ts\";\nimport { JSONArray, JSONObject } from \"./json.ts\";\n\nexport class SQSClient extends AWSClient {\n  private readonly signature: SignatureV4;\n  private readonly commonHeaders: HTTPHeaders;\n\n  private readonly serviceVersion: string;\n\n  constructor(awsConfig: AWSConfig) {\n    super(awsConfig, \"sqs\");\n\n    this.serviceVersion = \"AmazonSQS\";\n\n    this.signature = new SignatureV4({\n      service: this.serviceName,\n      region: this.awsConfig.region,\n      credentials: {\n        accessKeyId: this.awsConfig.accessKeyId,\n        secretAccessKey: this.awsConfig.secretAccessKey,\n        sessionToken: this.awsConfig.sessionToken,\n      },\n      uriEscapePath: true,\n      applyChecksum: true,\n    });\n\n    this.commonHeaders = {\n      \"Content-Type\": \"application/x-amz-json-1.0\",\n    };\n  }\n\n  /**\n   * Deletes a specific AWS SQS message with a unique, most-recent receipt handle for the message.\n   *\n   * @see https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_DeleteMessage.html\n   * @param {string} queueUrl - The URL of the Amazon SQS queue from which the message should be deleted from.\n   * @param {string} receiptHandle The unique, most-recent receipt handle for the message to delete\n   */\n  async deleteMessage(queueUrl: string, receiptHandle: string) {\n    const action = \"DeleteMessage\";\n\n    const body = {\n      QueueUrl: queueUrl,\n      ReceiptHandle: receiptHandle,\n    };\n\n    await this._sendRequest(action, body);\n  }\n\n  /**\n   * Receives messages from the specified AWS SQS queue.\n   *\n   * @see https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_ReceiveMessage.html\n   * @param {string} queueUrl - The URL of the Amazon SQS queue from which messages should be received. Queue URLs and names are case-sensitive.\n   * @param {string[]} messageAttributeNames - List of message attributes to receive.\n   * @param {string[]} messageSystemAttributeNames - List of attributes that must be returned with each message.\n   * @param {number} maxNumberOfMessages - The maximum number of messages to receive from the Amazon SQS queue.\n   * @param {number} visibilityTimeout - Number of seconds to \"hide\" the received messages from subsequent ReceiveMessage requests.\n   * @param {number} waitTimeSeconds - Number of seconds to wait for messages from the Amazon SQS queue.\n   * @param {string | undefined} receiveRequestAttemptId - Value to use for ReceiveMessage deduplication on FIFO queues.\n   * @returns {ReceivedMessage[]} - The list of received messages.\n   */\n  async receiveMessages(\n    queueUrl: string,\n    messageAttributeNames: string[] = [\"All\"],\n    messageSystemAttributeNames: string[] = [\"All\"],\n    maxNumberOfMessages: number = 1,\n    visibilityTimeout: number = 30,\n    waitTimeSeconds: number = 10,\n    receiveRequestAttemptId: string | undefined,\n  ): Promise<ReceivedMessage[]> {\n    const action = \"ReceiveMessage\";\n\n    const body = {\n      MaxNumberOfMessages: maxNumberOfMessages,\n      MessageAttributeNames: messageAttributeNames,\n      MessageSystemAttributeNames: messageSystemAttributeNames,\n      QueueUrl: queueUrl,\n      VisibilityTimeout: visibilityTimeout,\n      WaitTimeSeconds: waitTimeSeconds,\n      ReceiveRequestAttemptId: receiveRequestAttemptId,\n    };\n\n    const res = await this._sendRequest(action, body);\n\n    const parsed = res.json() as JSONObject;\n    const messagesArray = parsed[\"Messages\"] as JSONArray;\n\n    const messages = [] as ReceivedMessage[];\n    messagesArray?.forEach((msg) =>\n      messages.push(new ReceivedMessage(msg as JSONObject))\n    );\n\n    return messages;\n  }\n\n  /**\n   * Delivers a message to the specified queue.\n   *\n   * @param {string} queueUrl - The URL of the Amazon SQS queue to which a message is sent. Queue URLs and names are case-sensitive.\n   * @param {string} messageBody - The message to send. The minimum size is one character. The maximum size is 256 KB.\n   * @param {Object} options - Options for the request\n   * @param {string} [options.messageDeduplicationId] - The message deduplication id.\n   * @param {string} [options.messageGroupId] - The message group ID for FIFO queues\n   * @returns {MessageResponse} - The message that was sent.\n   */\n  async sendMessage(\n    queueUrl: string,\n    messageBody: string,\n    options: SendMessageOptions = {},\n  ): Promise<MessageResponse> {\n    const action = \"SendMessage\";\n\n    const body = {\n      QueueUrl: queueUrl,\n      ...this._combineQueueMessageBodyAndOptions(messageBody, options),\n    };\n\n    const res = await this._sendRequest(action, body);\n\n    const parsed = res.json() as JSONObject;\n    return new MessageResponse(\n      parsed[\"MessageId\"] as string,\n      parsed[\"MD5OfMessageBody\"] as string,\n    );\n  }\n\n  /**\n   * Delivers up to ten messages to the specified queue.\n   *\n   * @param {string} queueUrl - The URL of the Amazon SQS queue to which a message is sent. Queue URLs and names are case-sensitive.\n   * @param {SendMessageBatchEntry[]} entries - A list of up to ten messages to send.\n   * @returns {MessageBatchResponse} - The messages that were sent.\n   */\n  async sendMessageBatch(\n    queueUrl: string,\n    entries: SendMessageBatchEntry[],\n  ): Promise<MessageBatchResponse> {\n    const action = \"SendMessageBatch\";\n\n    const requestMessageEntries = entries.map((entry) => {\n      let requestMessageEntry = this._combineQueueMessageBodyAndOptions(\n        entry.messageBody,\n        entry.messageOptions,\n      );\n      requestMessageEntry = { ...requestMessageEntry, Id: entry.messageId };\n      return requestMessageEntry;\n    });\n\n    const body = { QueueUrl: queueUrl, Entries: requestMessageEntries };\n\n    const res = await this._sendRequest(action, body);\n\n    const parsed = res.json() as JSONObject;\n    const successful: JSONObject[] = (parsed[\"Successful\"] as JSONObject[]) ||\n      [];\n    const failed: JSONObject[] = (parsed[\"Failed\"] as JSONObject[]) || [];\n\n    return {\n      successful: successful.map(\n        (entry) =>\n          new MessageResponse(\n            entry[\"MessageId\"] as string,\n            entry[\"MD5OfMessageBody\"] as string,\n          ),\n      ),\n      failed: failed.map(\n        (entry) =>\n          new SQSServiceError(\n            entry[\"Message\"] as string,\n            entry[\"Code\"] as string,\n            action,\n          ),\n      ),\n    };\n  }\n\n  /**\n   * Returns a list of your queues in the current region.\n   *\n   * @param {ListQueuesRequestParameters} [parameters={}] request parameters\n   * @param {number} [ListQueuesRequestParameters.maxResults] Maximum number of results to include in the response. Value range is 1 to 1000. You must set maxResults to receive a value for nextToken in the response.\n   * @param {string} [ListQueuesRequestParameters.nextToken] Pagination token to request the next set of results.\n   * @param {string} [ListQueuesRequestParameters.queueNamePrefix] A string to use for filtering the list results. Only those queues whose name begins with the specified string are returned.\n   * @returns {Object}\n   * @returns {string[]} Object.queueUrls - A list of queue URLs, up to 1000 entries.\n   * @returns {string} [Object.nextToken] - In the future, you can use NextToken to request the next set of results.\n   */\n  async listQueues(\n    parameters: ListQueuesRequestParameters = {},\n  ): Promise<ListQueuesResponse> {\n    const action = \"ListQueues\";\n\n    let body: object = {};\n\n    if (typeof parameters?.maxResults !== \"undefined\") {\n      body = { ...body, MaxResults: parameters.maxResults };\n    }\n\n    if (typeof parameters?.nextToken !== \"undefined\") {\n      body = { ...body, NextToken: parameters.nextToken };\n    }\n\n    if (typeof parameters?.queueNamePrefix !== \"undefined\") {\n      body = { ...body, QueueNamePrefix: parameters.queueNamePrefix };\n    }\n\n    const res = await this._sendRequest(action, body);\n\n    const parsed = res.json() as JSONObject;\n    return {\n      urls: parsed[\"QueueUrls\"] as string[],\n      nextToken: parsed?.NextToken as string,\n    };\n  }\n\n  private _combineQueueMessageBodyAndOptions(\n    messageBody: string,\n    options?: SendMessageOptions,\n  ): object {\n    let body: object = { MessageBody: messageBody };\n\n    if (options === undefined) {\n      return body;\n    }\n\n    if (typeof options.messageDeduplicationId !== \"undefined\") {\n      body = {\n        ...body,\n        MessageDeduplicationId: options.messageDeduplicationId,\n      };\n    }\n\n    if (typeof options.messageGroupId !== \"undefined\") {\n      body = { ...body, MessageGroupId: options.messageGroupId };\n    }\n\n    if (typeof options.messageAttributes !== \"undefined\") {\n      const messageAttributes: Record<string, Record<string, string>> = {};\n\n      for (\n        const [name, attribute] of Object.entries(options.messageAttributes)\n      ) {\n        const valueParameterSuffix = attribute.type === \"Binary\"\n          ? \"BinaryValue\"\n          : \"StringValue\";\n        messageAttributes[name] = {\n          DataType: attribute.type,\n        };\n        messageAttributes[name][valueParameterSuffix] = attribute.value;\n      }\n\n      body = { ...body, MessageAttributes: messageAttributes };\n    }\n\n    if (typeof options.delaySeconds !== \"undefined\") {\n      body = { ...body, DelaySeconds: options.delaySeconds };\n    }\n\n    return body;\n  }\n\n  private async _sendRequest(\n    action: SQSOperation,\n    body: object,\n  ): Promise<RefinedResponse<ResponseType>> {\n    const signedRequest = this.signature.sign(\n      {\n        method: \"POST\",\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          [AMZ_TARGET_HEADER]: `${this.serviceVersion}.${action}`,\n        },\n        body: JSON.stringify(body),\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      \"POST\",\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n\n    this._handleError(action, res);\n    return res;\n  }\n\n  private _handleError(\n    operation: SQSOperation,\n    response: RefinedResponse<ResponseType | undefined>,\n  ) {\n    const errorCode: number = response.error_code;\n\n    if (errorCode === 0) {\n      return;\n    }\n\n    const error = response.json() as JSONObject;\n\n    const errorMessage: string = (error.Message as string) ||\n      (error.message as string) || (error.__type as string);\n\n    switch (error.__type) {\n      case \"InvalidSignatureException\":\n        throw new InvalidSignatureError(errorMessage, error.__type);\n      default:\n        throw new SQSServiceError(\n          errorMessage,\n          error.__type as string,\n          operation,\n        );\n    }\n  }\n\n  protected override handleError(\n    response: RefinedResponse<ResponseType | undefined>,\n    operation?: string,\n  ): boolean {\n    const errored = super.handleError(response);\n    if (!errored) {\n      return false;\n    }\n\n    const errorCode: number = response.error_code;\n\n    if (errorCode === 0) {\n      return false;\n    }\n\n    const error = response.json() as JSONObject;\n\n    const errorMessage: string = (error.Message as string) ||\n      (error.message as string) || (error.__type as string);\n\n    switch (error.__type) {\n      case \"InvalidSignatureException\":\n        throw new InvalidSignatureError(errorMessage, error.__type);\n      default:\n        throw new SQSServiceError(\n          errorMessage,\n          error.__type as string,\n          operation as SQSOperation,\n        );\n    }\n  }\n}\n\n/**\n * Attributes of a {@link ReceivedMessage} object from an Amazon SQS queue.\n */\nexport class ReceivedMessageAttributes {\n  /**\n   * A tag that specifies which specific message group the message belongs to.\n   */\n  MessageGroupId: string;\n\n  /**\n   * The AWS X-Ray trace header string.\n   */\n  AWSTraceHeader: string;\n\n  /**\n   * The user ID or IAM role which sent the message.\n   */\n  SenderId: string;\n\n  /**\n   * The approximate epoch time (in milliseconds) the message was first received from the queue.\n   */\n  ApproximateFirstReceiveTimestamp: string;\n\n  /**\n   * The approximate number of times the message has been received across all queues but not deleted.\n   */\n  ApproximateReceiveCount: string;\n\n  /**\n   * The epoch time (in milliseconds) the message was sent to the AWS SQS queue.\n   */\n  SentTimestamp: string;\n\n  /**\n   * The value provided by Amazon SQS.\n   */\n  SequenceNumber: string;\n\n  /**\n   * The token used for deduplication of sent messages.\n   * This field only applies to FIFO queues.\n   */\n  MessageDeduplicationId: string;\n\n  /**\n   * Instantiates a new ReceivedMessageAttributes object.\n   *\n   * @param capturedMessageAttributes\n   */\n  constructor(capturedMessageAttributes: JSONObject) {\n    this.MessageGroupId = capturedMessageAttributes\n      ?.[\"MessageGroupId\"] as string;\n    this.AWSTraceHeader = capturedMessageAttributes\n      ?.[\"AWSTraceHeader\"] as string;\n    this.SenderId = capturedMessageAttributes?.[\"SenderId\"] as string;\n    this.ApproximateFirstReceiveTimestamp = capturedMessageAttributes?.[\n      \"ApproximateFirstReceiveTimestamp\"\n    ] as string;\n    this.ApproximateReceiveCount = capturedMessageAttributes?.[\n      \"ApproximateReceiveCount\"\n    ] as string;\n    this.SentTimestamp = capturedMessageAttributes?.[\"SentTimestamp\"] as string;\n    this.SequenceNumber = capturedMessageAttributes\n      ?.[\"SequenceNumber\"] as string;\n    this.MessageDeduplicationId = capturedMessageAttributes?.[\n      \"MessageDeduplicationId\"\n    ] as string;\n  }\n}\n\n/**\n * A received message while monitoring an Amazon SQS queue.\n */\nexport class ReceivedMessage {\n  /**\n   * Tag to identify the class\n   */\n  toStringTag: string = \"ReceivedMessage\";\n\n  /**\n   * A unique identifier for the message.\n   * A MessageId is considered unique across all AWS accounts for an extended period of time.\n   */\n  id: string;\n\n  /**\n   * An MD5 digest of the non-URL-encoded message body string.\n   */\n  BodyMD5: string;\n\n  /**\n   * An identifier associated with the act of receiving the message.\n   * A new receipt handle is returned every time you receive a message.\n   * When deleting a message, you provide the last received receipt handle to delete the message.\n   */\n  ReceiptHandle: string;\n\n  /**\n   * The message's contents (not URL-encoded).\n   */\n  Body: string;\n\n  /**\n   * A map of the requested attributes to their respective values.\n   */\n  Attributes: ReceivedMessageAttributes;\n\n  /**\n   * Instantiates a new Message object.\n   *\n   * @param capturedMessage\n   */\n  constructor(capturedMessage: JSONObject) {\n    this.id = capturedMessage[\"MessageId\"] as string;\n    this.BodyMD5 = capturedMessage[\"BodyMD5\"] as string;\n    this.ReceiptHandle = capturedMessage[\"ReceiptHandle\"] as string;\n    this.Body = capturedMessage[\"Body\"] as string;\n    this.Attributes = new ReceivedMessageAttributes(\n      capturedMessage[\"Attributes\"]! as JSONObject,\n    );\n  }\n}\n\n/**\n * An Amazon SQS message.\n */\nexport class MessageResponse {\n  /**\n   * A unique identifier for the message.\n   * A MessageId is considered unique across all AWS accounts for an extended period of time.\n   */\n  id: string;\n\n  /**\n   * An MD5 digest of the non-URL-encoded message body string.\n   */\n  bodyMD5: string;\n\n  /**\n   * Instantiates a new Message object.\n   *\n   * @param id\n   * @param md5Ofbody\n   */\n  constructor(id: string, bodyMD5: string) {\n    this.id = id;\n    this.bodyMD5 = bodyMD5;\n  }\n}\n\n/**\n * An Amazon SQS message Batch Response.\n */\nexport class MessageBatchResponse {\n  /**\n   * A list of successful messages.\n   */\n  successful: MessageResponse[];\n\n  /**\n   * A list of failed messages.\n   */\n  failed: SQSServiceError[];\n\n  /**\n   * Instantiates a new MessageBatchResponse object.\n   *\n   * @param successful\n   * @param failed\n   */\n  constructor(successful: MessageResponse[], failed: SQSServiceError[]) {\n    this.successful = successful;\n    this.failed = failed;\n  }\n}\n\n/**\n * SQSServiceError indicates an error occurred while interacting with the SQS API.\n */\nexport class SQSServiceError extends AWSError {\n  operation: SQSOperation;\n\n  constructor(message: string, code: string, operation: SQSOperation) {\n    super(message, code);\n    this.name = \"SQSServiceError\";\n    this.operation = operation;\n  }\n}\n\n/**\n * SQSOperation describes possible SQS operations.\n */\ntype SQSOperation =\n  | \"DeleteMessage\"\n  | \"ListQueues\"\n  | \"ReceiveMessage\"\n  | \"SendMessage\"\n  | \"SendMessageBatch\";\n\nexport interface SendMessageOptions {\n  /**\n   * The message deduplication ID for FIFO queues\n   */\n  messageDeduplicationId?: string;\n\n  /**\n   * The message group ID for FIFO queues\n   */\n  messageGroupId?: string;\n\n  /**\n   * The message attributes\n   */\n  messageAttributes?: {\n    [name: string]: { type: \"String\" | \"Number\" | \"Binary\"; value: string };\n  };\n\n  /**\n   * The length of time, in seconds, for which to delay a specific message.\n   */\n  delaySeconds?: number;\n}\n\nexport interface SendMessageBatchEntry {\n  messageId: string;\n  messageBody: string;\n  messageOptions?: SendMessageOptions;\n}\n\nexport interface ListQueuesRequestParameters {\n  /**\n   * Maximum number of results to include in the response. Value range is 1 to 1000.\n   */\n  maxResults?: number;\n  /**\n   * Pagination token to request the next set of results.\n   */\n  nextToken?: string;\n  /**\n   * A string to use for filtering the list results. Only those queues whose name begins with the specified string are returned.\n   * Queue URLs and names are case-sensitive.\n   */\n  queueNamePrefix?: string;\n}\n\nexport interface ListQueuesResponse {\n  /**\n   * A list of queue URLs, up to 1,000 entries, or the value of MaxResults you sent in the request.\n   */\n  urls: string[];\n  /**\n   * Pagination token to include in the next request.\n   */\n  nextToken?: string;\n}\n", "import http, { RefinedResponse, ResponseType } from \"k6/http\";\n\nimport { AWSClient } from \"./client.ts\";\n\nimport { AWSConfig } from \"./config.ts\";\nimport { AMZ_TARGET_HEADER } from \"./constants.ts\";\nimport { AWSError } from \"./error.ts\";\nimport { JSONObject } from \"./json.ts\";\nimport { HTTPHeaders } from \"./http.ts\";\nimport { InvalidSignatureError, SignatureV4 } from \"./signature.ts\";\n\n/**\nThis API is based on\nhttps://docs.aws.amazon.com/kinesis/latest/APIReference/API_Operations.html\n*/\n\n/**\n * Allows interacting with the Kinesis API.\n */\nexport class KinesisClient extends AWSClient {\n  private readonly signature: SignatureV4;\n  private readonly commonHeaders: HTTPHeaders;\n  private readonly serviceVersion: string;\n\n  /**\n   * A constructor function that creates a new instance of the Kinesis class.\n   * @param {AWSConfig} awsConfig - AWSConfig - This is the configuration object that is passed to\n   * the constructor.\n   * @returns A Proxy object.\n   */\n  constructor(awsConfig: AWSConfig) {\n    super(awsConfig, \"kinesis\");\n\n    this.serviceVersion = \"Kinesis_20131202\";\n\n    this.signature = new SignatureV4({\n      service: this.serviceName,\n      region: this.awsConfig.region,\n      credentials: {\n        accessKeyId: this.awsConfig.accessKeyId,\n        secretAccessKey: this.awsConfig.secretAccessKey,\n        sessionToken: this.awsConfig.sessionToken,\n      },\n      uriEscapePath: false,\n      applyChecksum: true,\n    });\n\n    this.commonHeaders = {\n      \"Content-Type\": \"application/x-amz-json-1.1\",\n    };\n  }\n\n  /**\n   * Creates a new Kinesis stream with the specified name and options.\n   *\n   * @param {string} streamName - The name of the stream to create.\n   * @param {{\n   *   shardCount?: number;\n   *   streamModeDetails?: {\n   *     streamMode: StreamMode;\n   *   };\n   * }} [options={}] - An optional object containing configuration options for the stream.\n   * @param {number} [options.shardCount] - The number of shards for the stream. If not provided, the default value will be used.\n   * @param {{streamMode: StreamMode}} [options.streamModeDetails] - An optional object containing the stream mode details.\n   * @param {StreamMode} [options.streamModeDetails.streamMode] - The mode of the stream. If not provided, the default mode will be used.\n   *\n   * @throws {Error} Throws an error if the stream creation request fails.\n   * @returns {void}\n   */\n  async createStream(\n    streamName: string,\n    options: {\n      shardCount?: number;\n      streamModeDetails?: { streamMode: StreamMode };\n    } = {},\n  ): Promise<void> {\n    const body = {\n      StreamName: streamName,\n      ...(options.shardCount && { ShardCount: options.shardCount }),\n      ...(options.streamModeDetails &&\n        { StreamMode: options.streamModeDetails.streamMode }),\n    };\n\n    await this._send_request(\"CreateStream\", body);\n  }\n\n  /**\n   * Deletes a Kinesis stream with the specified parameters.\n   *\n   * @param {string} streamName - The name of the stream to delete.\n   * @param {{\n   *   streamARN?: string;\n   *   enforceConsumerDeletion?: boolean;\n   * }} [parameters={}] - An optional object containing configuration options for the stream deletion.\n   * @param {string} [parameters.streamARN] - The Amazon Resource Name (ARN) of the stream. If not provided, the ARN will be derived from the stream name.\n   * @param {boolean} [parameters.enforceConsumerDeletion] - Whether to enforce the deletion of all registered consumers before deleting the stream. Defaults to false.\n   *\n   * @throws {Error} Throws an error if the stream deletion request fails.\n   * @returns {void}\n   */\n  async deleteStream(\n    streamName: string,\n    parameters: { streamARN?: string; enforceConsumerDeletion?: boolean } = {},\n  ): Promise<void> {\n    const body = {\n      StreamName: streamName,\n      ...(parameters.streamARN && { StreamARN: parameters.streamARN }),\n      ...(parameters.enforceConsumerDeletion && {\n        EnforceConsumerDeletion: parameters.enforceConsumerDeletion,\n      }),\n    };\n\n    await this._send_request(\"DeleteStream\", body);\n  }\n\n  /**\n   * Returns a list of Kinesis streams with the specified parameters.\n   *\n   * @param {{\n   *   exclusiveStartStreamName?: string;\n   *   limit?: number;\n   *   nextToken?: string;\n   * }} [parameters={}] - An optional object containing configuration options for listing the streams.\n   * @param {string} [parameters.exclusiveStartStreamName] - The name of the stream to start listing from. If not provided, the listing starts from the beginning.\n   * @param {number} [parameters.limit] - The maximum number of streams to list. If not provided, the default value will be used.\n   * @param {string} [parameters.nextToken] - A token to paginate the list of streams. If not provided, the first page will be returned.\n   *\n   * @throws {Error} Throws an error if the list streams request fails.\n   * @returns {Partial<ListStreamsResponse>} A partial of the ListStreamsResponse class.\n   */\n  async listStreams(\n    parameters: {\n      exclusiveStartStreamName?: string;\n      limit?: number;\n      nextToken?: string;\n    } = {},\n  ): Promise<ListStreamsResponse> {\n    const body = {\n      ...(parameters.exclusiveStartStreamName && {\n        ExclusiveStartStreamName: parameters.exclusiveStartStreamName,\n      }),\n      ...(parameters.limit && { Limit: parameters.limit }),\n      ...(parameters.nextToken && { NextToken: parameters.nextToken }),\n    };\n\n    const res = await this._send_request(\"ListStreams\", body);\n    return ListStreamsResponse.fromJson(res?.json() as JSONObject);\n  }\n\n  /**\n   * Sends multiple records to a Kinesis stream in a single request.\n   *\n   * @param {string} streamName - The name of the stream to put records into.\n   * @param {PutRecordsRequestEntry[]} records - An array of records to put into the stream.\n   *\n   * @throws {Error} Throws an error if the put records request fails.\n   * @returns {Partial<PutRecordsResponse>} A partial of the PutRecordsResponse class.\n   */\n  async putRecords(\n    records: PutRecordsRequestEntry[],\n    parameters: { streamName?: string; streamARN?: string } = {},\n  ): Promise<PutRecordsResponse> {\n    if (!parameters.streamName && !parameters.streamARN) {\n      throw new Error(\"Either streamName or streamARN must be provided\");\n    }\n\n    const body = {\n      Records: records,\n      ...(parameters.streamName && { StreamName: parameters.streamName }),\n      ...(parameters.streamARN && { StreamARN: parameters.streamARN }),\n    };\n\n    const res = await this._send_request(\"PutRecords\", body);\n    return PutRecordsResponse.fromJson(res?.json() as JSONObject);\n  }\n\n  /**\n   * Retrieves records from a Kinesis stream.\n   *\n   * @param {string} shardIterator - The shard iterator to start retrieving records from.\n   * @param {number} [limit] - The maximum number of records to return. If not provided, the default value will be used.\n   *\n   * @throws {Error} Throws an error if the get records request fails.\n   * @returns {Partial<GetRecordsResponse>} A partial of the GetRecordsResponse class.\n   */\n  async getRecords(\n    shardIterator: string,\n    parameters: { limit?: number; streamARN?: string } = {},\n  ): Promise<GetRecordsResponse> {\n    const body = {\n      ShardIterator: shardIterator,\n      ...(parameters.limit && { Limit: parameters.limit }),\n      ...(parameters.streamARN && { StreamARN: parameters.streamARN }),\n    };\n\n    const res = await this._send_request(\"GetRecords\", body);\n    return GetRecordsResponse.fromJson(res?.json() as JSONObject);\n  }\n\n  /**\n   * Lists the shards in a Kinesis stream.\n   *\n   * @param {string} streamName - The name of the stream to list shards from.\n   * @param {{\n   *   nextToken?: string;\n   *   maxResults?: number;\n   * }} [parameters={}] - An optional object containing configuration options for listing shards.\n   * @param {string} [parameters.nextToken] - A token to specify where to start paginating the shard list. If not provided, the first page will be returned.\n   * @param {number} [parameters.maxResults] - The maximum number of shards to return. If not provided, the default value will be used.\n   *\n   * @throws {Error} Throws an error if the list shards request fails.\n   * @returns {ListShardsResponse} A ListShardsResponse class instance.\n   */\n  async listShards(\n    streamName: string,\n    parameters: { nextToken?: string; maxResults?: number } = {},\n  ): Promise<ListShardsResponse> {\n    const body = {\n      StreamName: streamName,\n      ...(parameters.nextToken && { NextToken: parameters.nextToken }),\n      ...(parameters.maxResults && {\n        MaxResults: parameters.maxResults,\n      }),\n    };\n\n    const res = await this._send_request(\"ListShards\", body);\n    return ListShardsResponse.fromJson(res?.json() as JSONObject);\n  }\n\n  /**\n   * Retrieves a shard iterator for the specified shard in a Kinesis stream.\n   *\n   * @param {string} streamName - The name of the stream.\n   * @param {string} shardId - The shard ID for which to get the iterator.\n   * @param {string} shardIteratorType - The shard iterator type. One of 'AT_SEQUENCE_NUMBER', 'AFTER_SEQUENCE_NUMBER', 'TRIM_HORIZON', 'LATEST', or 'AT_TIMESTAMP'.\n   * @param {{\n   *   startingSequenceNumber?: string;\n   *   timestamp?: number;\n   * }} [parameters={}] - An optional object containing configuration options for the shard iterator.\n   * @param {string} [parameters.startingSequenceNumber] - The sequence number to start with when using 'AT_SEQUENCE_NUMBER' or 'AFTER_SEQUENCE_NUMBER' iterator types.\n   * @param {number} [parameters.timestamp] - The timestamp to start with when using the 'AT_TIMESTAMP' iterator type.\n   *\n   * @throws {Error} Throws an error if the get shard iterator request fails.\n   * @returns {string} The next position in the shard from which to start sequentially reading data records. If set to null, the shard has been closed and the requested iterator does not return any more data.\n   */\n  async getShardIterator(\n    streamName: string,\n    shardId: string,\n    shardIteratorType: ShardIteratorKind,\n    parameters: { startingSequenceNumber?: string; timestamp?: number } = {},\n  ): Promise<GetShardIteratorResponse> {\n    const body = {\n      StreamName: streamName,\n      ShardId: shardId,\n      ShardIteratorType: shardIteratorType,\n      ...(parameters.startingSequenceNumber && {\n        StartingSequenceNumber: parameters.startingSequenceNumber,\n      }),\n      ...(parameters.timestamp && { Timestamp: parameters.timestamp }),\n    };\n\n    const res = await this._send_request(\"GetShardIterator\", body);\n    return GetShardIteratorResponse.fromJson(res?.json() as JSONObject);\n  }\n\n  private async _send_request<R extends ResponseType>(\n    action: string,\n    body: unknown,\n  ): Promise<RefinedResponse<R>> {\n    const signedRequest = this.signature.sign(\n      {\n        method: \"POST\",\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          [AMZ_TARGET_HEADER]: `${this.serviceVersion}.${action}`,\n        },\n        body: JSON.stringify(body),\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      \"POST\",\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n\n    this.handleError(res, action);\n    return res;\n  }\n\n  protected override handleError(\n    response: RefinedResponse<ResponseType | undefined>,\n    operation?: string,\n  ): boolean {\n    const errored = super.handleError(response, operation);\n    if (!errored) {\n      return false;\n    }\n\n    const errorCode = response.error_code;\n    const error = response.json() as JSONObject;\n    if (errorCode >= 1400 && errorCode <= 1499) {\n      // In the event of certain errors, the message is not set.\n      // Also, note the inconsistency in casing...\n      const errorMessage: string = (error.Message as string) ||\n        (error.message as string) || (error.__type as string);\n\n      // Handle specifically the case of an invalid signature\n      if (error.__type === \"InvalidSignatureException\") {\n        throw new InvalidSignatureError(errorMessage, error.__type);\n      }\n\n      // Otherwise throw a standard service error\n      throw new KinesisServiceError(\n        errorMessage,\n        error.__type as string,\n        operation || \"Unknown\",\n      );\n    }\n\n    if (errorCode === 1500) {\n      throw new KinesisServiceError(\n        \"An error occured on the server side\",\n        \"InternalServiceError\",\n        operation || \"Unknown\",\n      );\n    }\n\n    return true;\n  }\n}\n\n/* `KinesisServiceError` is a subclass of `AWSError` that adds an `operation` property */\nexport class KinesisServiceError extends AWSError {\n  operation: string;\n\n  /**\n   * Constructs a KinesisServiceError\n   *\n   * @param  {string} message - human readable error message\n   * @param  {string} code - A unique short code representing the error that was emitted\n   * @param  {string} operation - Name of the failed Operation\n   */\n  constructor(message: string, code: string, operation: string) {\n    super(message, code);\n    this.name = \"KinesisServiceError\";\n    this.operation = operation;\n  }\n}\n\n/**\n * Describes the options for a Kinesis stream.\n */\ntype StreamMode = \"PROVISIONED\" | \"ON_DEMAND\";\n\n/**\n * Determines how the shard iterator is used to start reading data records from the shard.\n */\nexport type ShardIteratorKind =\n  | \"AT_SEQUENCE_NUMBER\"\n  | \"AFTER_SEQUENCE_NUMBER\"\n  | \"TRIM_HORIZON\"\n  | \"LATEST\"\n  | \"AT_TIMESTAMP\";\n\n/**\n * Describes the status of a Kinesis data stream.\n */\nexport type StreamStatus = \"CREATING\" | \"DELETING\" | \"ACTIVE\" | \"UPDATING\";\n\nexport type StreamModeDetails = {\n  /**\n   * Specifies the capacity mode to which you want to set your data stream.\n   */\n  SteamMode: \"PROVISIONED\" | \"ON_DEMAND\";\n};\n\nexport class ListStreamsResponse {\n  /**\n   * Indicates whether there are more streams available to list.\n   */\n  hasMoreStreams: boolean;\n\n  /**\n   * The token that identifies which batch of results you can retrieve.\n   */\n  nextToken?: string;\n\n  /**\n   * The names of the streams that are associated with the AWS account making the ListStreams request.\n   */\n  streamNames: string[];\n\n  /**\n   * A list of StreamSummary objects.\n   */\n  streamSummaries: StreamSummary[];\n\n  constructor(\n    HasMoreStreams: boolean,\n    NextToken: string,\n    StreamNames: string[],\n    StreamSummaries: StreamSummary[],\n  ) {\n    this.hasMoreStreams = HasMoreStreams;\n    this.nextToken = NextToken;\n    this.streamNames = StreamNames;\n    this.streamSummaries = StreamSummaries;\n  }\n\n  static fromJson(result: JSONObject): ListStreamsResponse {\n    const {\n      HasMoreStreams = false,\n      NextToken = \"\",\n      StreamNames = [],\n      StreamSummaries = [],\n    } = result;\n\n    return new ListStreamsResponse(\n      HasMoreStreams as boolean,\n      NextToken as string,\n      StreamNames as string[],\n      (StreamSummaries as JSONObject[])?.map(\n        StreamSummary.fromJson,\n      ) as StreamSummary[],\n    );\n  }\n}\n\n/**\n * Summarizes a Stream\n */\nexport class StreamSummary {\n  /**\n   * The Amazon Resource Name (ARN) for the stream.\n   */\n  streamARN: string;\n\n  /**\n   * The time at which the stream was created.\n   */\n  streamCreationTimestamp: number;\n\n  /**\n   * Specify the capacity mode to which you want to set your data stream.\n   */\n  streamModeDetails: StreamModeDetails;\n\n  /**\n   * The name of the stream.\n   */\n  streamName: string;\n\n  /**\n   * The current status of the stream being described.\n   */\n  streamStatus: StreamStatus;\n\n  constructor(\n    StreamARN: string,\n    StreamCreationTimestamp: number,\n    StreamMode: StreamModeDetails,\n    StreamName: string,\n    StreamStatus: StreamStatus,\n  ) {\n    this.streamARN = StreamARN;\n    this.streamCreationTimestamp = StreamCreationTimestamp;\n    this.streamModeDetails = StreamMode;\n    this.streamName = StreamName;\n    this.streamStatus = StreamStatus;\n  }\n\n  static fromJson(summary: JSONObject): StreamSummary {\n    const {\n      StreamARN = \"\",\n      StreamCreationTimestamp = 0,\n      StreamModeDetails = {},\n      StreamName = \"\",\n      StreamStatus = \"\",\n    } = summary;\n\n    return new StreamSummary(\n      StreamARN as string,\n      StreamCreationTimestamp as number,\n      StreamModeDetails as StreamModeDetails,\n      StreamName as string,\n      StreamStatus as StreamStatus,\n    );\n  }\n}\n\n/**\n * Represents the output for PutRecords.\n */\nexport interface PutRecordsRequestEntry {\n  /**\n   * The data blob to put into the record, which is base64-encoded when the blob is serialized.\n   */\n  Data: string | ArrayBuffer;\n\n  /**\n   * Determines which share in the stream the data record is assigned to.\n   */\n  PartitionKey: string;\n}\n\n// Response class for PutRecords API\nexport class PutRecordsResponse {\n  /**\n   * The encryption type used on the records. This parameter can be one of the following values:\n   *   - NONE: Do not encrypt the records.\n   *   - KMS: Use server-side encryption on the records using a customer-managed AWS KMS key.\n   */\n  encryptionType: EncryptionType;\n\n  /**\n   * The number of unsuccessfully processed records in a PutRecords request.\n   */\n  failedRecordCount: number;\n\n  /**\n   * An array of successfully and unsuccessfully processed record results.\n   */\n  records: PutRecordsResultEntry[];\n\n  constructor(\n    encryptionType: \"NONE\" | \"KMS\",\n    failedRecordCount: number,\n    records: PutRecordsResultEntry[],\n  ) {\n    this.encryptionType = encryptionType;\n    this.failedRecordCount = failedRecordCount;\n    this.records = records;\n  }\n\n  static fromJson(json: JSONObject): PutRecordsResponse {\n    const { EncryptionType = \"NONE\", FailedRecordCount = 0, Records = [] } =\n      json;\n    const records = (Records as JSONObject[]).map(\n      PutRecordsResultEntry.fromJson,\n    );\n\n    return new PutRecordsResponse(\n      EncryptionType as EncryptionType,\n      FailedRecordCount as number,\n      records,\n    );\n  }\n}\n\ntype EncryptionType = \"NONE\" | \"KMS\";\n\n/**\n * Represents the result of an individual record from a PutRecords request.\n */\nexport class PutRecordsResultEntry {\n  /**\n   * The sequence number for an individual record result.\n   */\n  sequenceNumber: string;\n\n  /**\n   * The shard ID for an individual record result.\n   */\n  shardId: string;\n\n  constructor(sequenceNumber: string, shardId: string) {\n    this.sequenceNumber = sequenceNumber;\n    this.shardId = shardId;\n  }\n\n  static fromJson(json: JSONObject): PutRecordsResultEntry {\n    return new PutRecordsResultEntry(\n      json.SequenceNumber as string,\n      json.ShardId as string,\n    );\n  }\n}\n\n/**\n * Represents the response format of the GetRecords operation.\n */\nexport class GetRecordsResponse {\n  /**\n   * The next position in the shard from which to start sequentially reading data records.\n   */\n  nextShardIterator: string;\n\n  /**\n   * The data records retrieved from the shard.\n   */\n  records: Record[];\n\n  /**\n   * The number of milliseconds the GetRecords response is from the\n   * tip of the stream, indicating how far behind current time the\n   * consumer is.\n   *\n   * A value of zero indicates that record processing is caught\n   * up, and there are no new records to process at this moment.\n   */\n  millisBehindLatest: number;\n\n  constructor(\n    nextShardIterator: string,\n    records: Record[],\n    millisBehindLatest: number,\n  ) {\n    this.nextShardIterator = nextShardIterator;\n    this.records = records;\n    this.millisBehindLatest = millisBehindLatest;\n  }\n\n  static fromJson(json: JSONObject): GetRecordsResponse {\n    const { NextShardIterator = \"\", Records = [], MillisBehindLatest = 0 } =\n      json;\n    const records = (Records as JSONObject[]).map(Record.fromJson);\n\n    return new GetRecordsResponse(\n      NextShardIterator as string,\n      records as Record[],\n      MillisBehindLatest as number,\n    );\n  }\n}\n\n/**\n * The unit of data of the Kinesis data stream, which is composed of a sequence\n * number, a partition key, and a data blob.\n */\nclass Record {\n  /**\n   * The data blob.\n   */\n  data: string | ArrayBuffer;\n\n  /**\n   * Identifies which shard in the stream the data record is assigned to.\n   */\n  partitionKey: string;\n\n  /**\n   * The unique identifier of the record in the stream.\n   */\n  sequenceNumber: string;\n\n  constructor(\n    data: string | ArrayBuffer,\n    partitionKey: string,\n    sequenceNumber: string,\n  ) {\n    this.data = data;\n    this.partitionKey = partitionKey;\n    this.sequenceNumber = sequenceNumber;\n  }\n\n  static fromJson(json: JSONObject): Record {\n    return new Record(\n      json.Data as string | ArrayBuffer,\n      json.PartitionKey as string,\n      json.SequenceNumber as string,\n    );\n  }\n}\n\n// Response class for ListShards API\nexport class ListShardsResponse {\n  /**\n   * An array of JSON objects.\n   *\n   * Each object represents one shard and specifies the IDs of the shard, the\n   * shard's parent, and the shard that's adjacent to the shard's parent.\n   */\n  shards: Shard[];\n\n  /**\n   * When the number of shards in the data stream is greater than the\n   * default value for the MaxResults parameter, or if you explicitly specify\n   * a value for MaxResults that is less than the number of shards in the data\n   * stream, the response includes a pagination token named NextToken.\n   */\n  nextToken?: string;\n\n  constructor(shards: Shard[], nextToken?: string) {\n    this.shards = shards;\n    this.nextToken = nextToken;\n  }\n\n  static fromJson(json: JSONObject): ListShardsResponse {\n    const { Shards = [], NextToken } = json;\n    const shards = (Shards as JSONObject[]).map(Shard.fromJson);\n\n    return new ListShardsResponse(shards, NextToken as string | undefined);\n  }\n}\n\n/**\n * A uniquely identified group of data records in a Kinesis data stream.\n */\nexport class Shard {\n  /**\n   * The unique identifier of the shard within the stream.\n   */\n  id: string;\n\n  /**\n   * The shard ID of the shard's parent.\n   */\n  parentShardId?: string;\n\n  /**\n   * The shard ID of the shard adjacent to the shard's parent.\n   */\n  adjacentParentShardId?: string;\n\n  /**\n   * The range of possible hash key values for the shard, which is a set of ordered contiguous positive integers.\n   */\n  hashKeyRange: HashKeyRange;\n\n  sequenceNumberRange: SequenceNumberRange;\n\n  constructor(\n    id: string,\n    hashKeyRange: HashKeyRange,\n    sequenceNumberRange: SequenceNumberRange,\n    parentShardId?: string,\n    adjacentParentShardId?: string,\n  ) {\n    this.id = id;\n    this.parentShardId = parentShardId;\n    this.adjacentParentShardId = adjacentParentShardId;\n    this.hashKeyRange = hashKeyRange;\n    this.sequenceNumberRange = sequenceNumberRange;\n  }\n\n  static fromJson(json: JSONObject): Shard {\n    return new Shard(\n      json.ShardId as string,\n      json.HashKeyRange as unknown as HashKeyRange,\n      json.SequenceNumberRange as unknown as SequenceNumberRange,\n      json.ParentShardId as string | undefined,\n      json.AdjacentParentShardId as string | undefined,\n    );\n  }\n}\n\n/**\n * Describes the range of possible hash key values for the shard, which is\n * a set of ordered contiguous positive integers.\n */\nexport interface HashKeyRange {\n  /**\n   * The starting hash key of the hash key range.\n   */\n  startingHashKey: string;\n\n  /**\n   * The ending hash key of the hash key range.\n   */\n  endingHashKey: string;\n}\n\n/**\n * The range of possible sequence numbers for the shard.\n */\nexport interface SequenceNumberRange {\n  /**\n   * The ending sequence number for the range.\n   *\n   * Shards that are in the OPEN state have an ending sequence number of null.\n   */\n  endingSequenceNumber?: string;\n\n  /**\n   * The starting sequence number for the range.\n   */\n  startingSequenceNumber: string;\n}\n\n/**\n * Describes a shard iterator response.\n */\nclass GetShardIteratorResponse {\n  /**\n   * The position in the shard from which to start reading data records sequentially.\n   */\n  shardIterator: string;\n\n  constructor(shardIterator: string) {\n    this.shardIterator = shardIterator;\n  }\n\n  static fromJson(json: JSONObject): GetShardIteratorResponse {\n    return new GetShardIteratorResponse(json.ShardIterator as string);\n  }\n}\n", "import http, { type RefinedResponse, type ResponseType } from \"k6/http\";\n\nimport { AWSClient } from \"./client.ts\";\nimport { AWSConfig } from \"./config.ts\";\nimport { AWSError } from \"./error.ts\";\nimport { JSONObject } from \"./json.ts\";\nimport { InvalidSignatureError, SignatureV4 } from \"./signature.ts\";\nimport { AMZ_TARGET_HEADER } from \"./constants.ts\";\nimport { HTTPHeaders, HTTPMethod } from \"./http.ts\";\n\n/**\n * Class allowing to interact with Amazon AWS's Event Bridge service\n */\nexport class EventBridgeClient extends AWSClient {\n  private readonly signature: SignatureV4;\n  private readonly method: HTTPMethod;\n  private readonly commonHeaders: HTTPHeaders;\n\n  constructor(awsConfig: AWSConfig) {\n    super(awsConfig, \"events\");\n\n    this.signature = new SignatureV4({\n      service: this.serviceName,\n      region: this.awsConfig.region,\n      credentials: {\n        accessKeyId: this.awsConfig.accessKeyId,\n        secretAccessKey: this.awsConfig.secretAccessKey,\n        sessionToken: this.awsConfig.sessionToken,\n      },\n      uriEscapePath: true,\n      applyChecksum: false,\n    });\n\n    this.method = \"POST\";\n    this.commonHeaders = {\n      \"Content-Type\": \"application/x-amz-json-1.1\",\n    };\n  }\n\n  /**\n   * Sends custom events to Amazon EventBridge so that they can be matched to rules.\n   *\n   * @param {PutEventsInput} input - The input for the PutEvents operation.\n   * @throws {EventBridgeServiceError}\n   * @throws {InvalidSignatureError}\n   */\n  async putEvents(input: PutEventsInput) {\n    const parsedEvent = {\n      ...input,\n      Entries: input.Entries.map((entry) => ({\n        ...entry,\n        Detail: JSON.stringify(entry.Detail),\n      })),\n    };\n\n    const signedRequest = this.signature.sign(\n      {\n        method: this.method,\n        endpoint: this.endpoint,\n        path: \"/\",\n        headers: {\n          ...this.commonHeaders,\n          [AMZ_TARGET_HEADER]: `AWSEvents.PutEvents`,\n        },\n        body: JSON.stringify(parsedEvent),\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      this.method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res, EventBridgeOperation.PutEvents);\n  }\n\n  protected override handleError(\n    response: RefinedResponse<ResponseType | undefined>,\n    operation?: string,\n  ): boolean {\n    const errored = super.handleError(response, operation);\n    if (!errored) {\n      return false;\n    }\n\n    const errorCode = response.error_code;\n    const error = response.json() as JSONObject;\n    if (errorCode >= 1400 && errorCode <= 1499) {\n      // In the event of certain errors, the message is not set.\n      // Also, note the inconsistency in casing...\n      const errorMessage: string = (error.Message as string) ||\n        (error.message as string) || (error.__type as string);\n\n      // Handle specifically the case of an invalid signature\n      if (error.__type === \"InvalidSignatureException\") {\n        throw new InvalidSignatureError(errorMessage, error.__type);\n      }\n\n      // Otherwise throw a standard service error\n      throw new EventBridgeServiceError(\n        errorMessage,\n        error.__type as string,\n        operation as EventBridgeOperation,\n      );\n    }\n\n    if (errorCode === 1500) {\n      throw new EventBridgeServiceError(\n        \"An error occured on the server side\",\n        \"InternalServiceError\",\n        operation as EventBridgeOperation,\n      );\n    }\n\n    return true;\n  }\n}\n\nenum EventBridgeOperation {\n  PutEvents = \"PutEvents\",\n}\n\n/**\n * Represents an event to be submitted.\n *\n * @typedef {Object} PutEventEntry\n *\n * @property {string} Detail - A valid serialized JSON object. There is no other schema imposed. The JSON object may contain fields and nested sub-objects.\n * @property {string} DetailType - Free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.\n * @property {string} EventBusName - The name or ARN of the event bus to receive the event. Only the rules that are associated with this event bus are used to match the event. If you omit this, the default event bus is used.\n * @property {string[]} Resources - AWS resources, identified by Amazon Resource Name (ARN), which the event primarily concerns. Any number, including zero, may be present.\n * @property {string} Source - The source of the event.\n */\ninterface PutEventEntry {\n  Source: string;\n  Detail: JSONObject;\n  DetailType: string;\n  EventBusName?: string;\n  Resources?: [string];\n}\n\n/**\n * Represents the input for a put events operation.\n *\n * @typedef {Object} PutEventsInput\n *\n * @property {string} [EndpointId] - The optional URL subdomain of the endpoint.\n * @property {PutEventEntry[]} Entries - An array of entries that defines an event in your system.\n */\ninterface PutEventsInput {\n  EndpointId?: string;\n  Entries: PutEventEntry[];\n}\n\nexport class EventBridgeServiceError extends AWSError {\n  operation: EventBridgeOperation;\n\n  /**\n   * Constructs a EventBridgeServiceError\n   *\n   * @param  {string} message - human readable error message\n   * @param  {string} code - A unique short code representing the error that was emitted\n   * @param  {string} operation - Name of the failed Operation\n   */\n  constructor(message: string, code: string, operation: EventBridgeOperation) {\n    super(message, code);\n    this.name = \"EventBridgeServiceError\";\n    this.operation = operation;\n  }\n}\n", "import http, { RefinedResponse, ResponseType } from \"k6/http\";\nimport encoding from \"k6/encoding\";\n\nimport { AWSClient } from \"./client.ts\";\nimport { AWSConfig } from \"./config.ts\";\nimport { AWSError } from \"./error.ts\";\nimport { InvalidSignatureError, SignatureV4 } from \"./signature.ts\";\nimport { AMZ_TARGET_HEADER } from \"./constants.ts\";\nimport { HTTPHeaders, HTTPMethod, QueryParameterBag } from \"./http.ts\";\n\n/**\n * Class allowing to interact with Amazon AWS's Lambda service\n */\nexport class LambdaClient extends AWSClient {\n  private readonly signature: SignatureV4;\n  private readonly commonHeaders: HTTPHeaders;\n  private readonly method: HTTPMethod;\n\n  constructor(awsConfig: AWSConfig) {\n    super(awsConfig, \"lambda\");\n\n    this.signature = new SignatureV4({\n      service: this.serviceName,\n      region: this.awsConfig.region,\n      credentials: {\n        accessKeyId: this.awsConfig.accessKeyId,\n        secretAccessKey: this.awsConfig.secretAccessKey,\n        sessionToken: this.awsConfig.sessionToken,\n      },\n      uriEscapePath: true,\n      applyChecksum: false,\n    });\n\n    this.method = \"POST\";\n    this.commonHeaders = {\n      \"Content-Type\": \"application/x-amz-json-1.1\",\n    };\n  }\n\n  /**\n   * Invoke an AWS Lambda function\n   *\n   * @param {string} name - The name of the function\n   * @param {string} payload - The payload to send to function\n   * @param {InvocationOptions} options - Additional options to customize invocation\n   *\n   * @throws {LambdaInvocationError}\n   */\n  async invoke(\n    name: string,\n    payload: string,\n    options: InvocationOptions = {},\n  ): Promise<InvocationResponse> {\n    const query: QueryParameterBag = {};\n    const invocationType = options.invocationType || \"RequestResponse\";\n    const headers = {\n      ...this.commonHeaders,\n      [AMZ_TARGET_HEADER]: `AWSLambda.${invocationType}`,\n      \"X-Amz-Invocation-Type\": invocationType,\n      \"X-Amz-Log-Type\": options.logType || \"None\",\n    };\n    if (options.clientContext) {\n      headers[\"X-Amz-Client-Context\"] = options.clientContext;\n    }\n    if (options.qualifier) {\n      query[\"Qualifier\"] = options.qualifier;\n    }\n\n    const signedRequest = this.signature.sign(\n      {\n        method: this.method,\n        endpoint: this.endpoint,\n        path: `/2015-03-31/functions/${name}/invocations`,\n        query,\n        headers,\n        body: payload || \"\",\n      },\n      {},\n    );\n\n    const res = await http.asyncRequest(\n      this.method,\n      signedRequest.url,\n      signedRequest.body,\n      {\n        ...this.baseRequestParams,\n        headers: signedRequest.headers,\n      },\n    );\n    this.handleError(res);\n\n    const logResult = res.headers[\"X-Amz-Log-Result\"];\n    const response = {\n      executedVersion: res.headers[\"X-Amz-Executed-Version\"],\n      logResult: logResult\n        ? encoding.b64decode(logResult, \"std\", \"s\")\n        : undefined,\n      statusCode: res.status,\n      payload: res.body as string,\n    };\n\n    const functionError = res.headers[\"X-Amz-Function-Error\"];\n    if (functionError) {\n      throw new LambdaInvocationError(functionError, response);\n    } else {\n      return response;\n    }\n  }\n\n  protected override handleError(\n    response: RefinedResponse<ResponseType | undefined>,\n    operation?: string,\n  ): boolean {\n    const errored = super.handleError(response, operation);\n    if (!errored) {\n      return false;\n    }\n\n    const awsError = AWSError.parse(response);\n    switch (awsError.code) {\n      case \"AuthorizationHeaderMalformed\":\n      case \"InvalidSignatureException\":\n        throw new InvalidSignatureError(awsError.message, awsError.code);\n      default:\n        throw awsError;\n    }\n  }\n}\n\nexport class LambdaInvocationError extends Error {\n  response: InvocationResponse;\n\n  constructor(message: string, response: InvocationResponse) {\n    super(`${message}: ${response.payload}`);\n    this.response = response;\n  }\n}\n\ninterface InvocationOptions {\n  /**\n   * Defines whether the function is invoked synchronously or asynchronously.\n   * - `RequestResponse` (default): Invoke the function synchronously.\n   * - `Event`: Invoke the function asynchronously.\n   * - `DryRun`: Validate parameter values and verify that the user or role has permission to invoke the function.\n   */\n  invocationType?: \"RequestResponse\" | \"Event\" | \"DryRun\";\n  /**\n   * Set to `Tail` to include the execution log in the response. Applies to synchronously invoked functions only.\n   */\n  logType?: \"None\" | \"Tail\";\n  /**\n   * Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the context object.\n   */\n  clientContext?: string;\n  /**\n   * Specify a version or alias to invoke a published version of the function.\n   */\n  qualifier?: string;\n}\n\ninterface InvocationResponse {\n  statusCode: number;\n  executedVersion?: string;\n  logResult?: string;\n  payload?: string;\n}\n"],
  "mappings": "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",
  "names": ["parseHTML", "AWSError", "_AWSError", "message", "code", "xmlDocument", "doc", "response", "error", "NetworkError", "name", "ErrorMessages", "GeneralError", "DNSError", "TCPError", "TLSError", "HTTP2Error", "ErrorMessages", "crypto", "AMZ_ALGORITHM_QUERY_PARAM", "AMZ_CREDENTIAL_QUERY_PARAM", "AMZ_DATE_QUERY_PARAM", "AMZ_EXPIRES_QUERY_PARAM", "AMZ_SIGNATURE_QUERY_PARAM", "AMZ_SIGNED_HEADERS_QUERY_PARAM", "AMZ_TARGET_QUERY_PARAM", "AMZ_TOKEN_QUERY_PARAM", "AMZ_CONTENT_SHA256_HEADER", "AMZ_DATE_HEADER", "AMZ_SIGNATURE_HEADER", "AMZ_TARGET_HEADER", "AMZ_TOKEN_HEADER", "AUTHORIZATION_HEADER", "DATE_HEADER", "GENERATED_HEADERS", "HOST_HEADER", "ALWAYS_UNSIGNABLE_HEADERS", "KEY_TYPE_IDENTIFIER", "SIGNING_ALGORITHM_IDENTIFIER", "MAX_PRESIGNED_TTL", "EMPTY_SHA256", "UNSIGNED_PAYLOAD", "hasHeader", "soughtHeader", "headers", "headerName", "isArrayBuffer", "value", "SignatureV4", "service", "region", "credentials", "uriEscapePath", "applyChecksum", "request", "options", "finalOptions", "longDate", "shortDate", "formatDate", "scope", "KEY_TYPE_IDENTIFIER", "HOST_HEADER", "headerName", "GENERATED_HEADERS", "AMZ_DATE_HEADER", "AMZ_TOKEN_HEADER", "payloadHash", "hasHeader", "AMZ_CONTENT_SHA256_HEADER", "canonicalHeaders", "signature", "AUTHORIZATION_HEADER", "SIGNING_ALGORITHM_IDENTIFIER", "url", "originalRequest", "signingDate", "expiresIn", "unsignableHeaders", "unhoistableHeaders", "signableHeaders", "signingRegion", "signingService", "MAX_PRESIGNED_TTL", "InvalidSignatureError", "AMZ_TOKEN_QUERY_PARAM", "AMZ_ALGORITHM_QUERY_PARAM", "AMZ_CREDENTIAL_QUERY_PARAM", "AMZ_DATE_QUERY_PARAM", "AMZ_EXPIRES_QUERY_PARAM", "AMZ_SIGNED_HEADERS_QUERY_PARAM", "signingKey", "canonicalRequest", "AMZ_SIGNATURE_QUERY_PARAM", "sortedHeaders", "sortedCanonicalHeaders", "name", "signedHeaders", "credentialScope", "hashedCanonicalRequest", "crypto", "stringToSign", "kSecret", "kDateBytes", "kDate", "bytesToUint8Array", "kRegionBytes", "uint8ArrayToArrayBuffer", "kRegion", "kServiceBytes", "kService", "kSigningBytes", "path", "normalizedURISegments", "URISegment", "leading", "URI", "trailing", "normalizedURI", "query", "keys", "serialized", "key", "AMZ_SIGNATURE_HEADER", "value", "escapeURI", "encoded", "headers", "canonicalHeaderName", "ALWAYS_UNSIGNABLE_HEADERS", "body", "EMPTY_SHA256", "isArrayBuffer", "UNSIGNED_PAYLOAD", "requestCopy", "lowerCaseName", "ignoreKeys", "AWSError", "message", "code", "bytes", "uint8Array", "hexEncode", "c", "date", "iso8601", "time", "toDate", "Endpoint", "_Endpoint", "endpoint", "completeUrl", "protocolMatch", "hostAndPath", "hostnameWithPort", "value", "hostname", "port", "withoutProtocol", "AWSConfig", "_AWSConfig", "options", "region", "accessKeyId", "secretAccessKey", "sessionToken", "endpoint", "InvalidAWSConfigError", "Endpoint", "message", "http", "AWSClient", "awsConfig", "serviceName", "Endpoint", "endpoint", "response", "_operation", "status", "errorCode", "errorMessage", "GeneralError", "DNSError", "TCPError", "TLSError", "HTTP2Error", "KMSClient", "AWSClient", "awsConfig", "SignatureV4", "signedRequest", "AMZ_TARGET_HEADER", "res", "http", "k", "KMSKey", "id", "size", "KMSDataKey", "response", "operation", "errorCode", "error", "errorMessage", "InvalidSignatureError", "KMSServiceError", "_KMSKey", "keyArn", "KeyId", "json", "_KMSDataKey", "CiphertextBlob", "Plaintext", "AWSError", "message", "code", "parseHTML", "http", "S3Client", "AWSClient", "awsConfig", "SignatureV4", "method", "signedRequest", "res", "http", "buckets", "parseHTML", "_", "bucketDefinition", "bucket", "child", "bucketName", "prefix", "objects", "objectDefinition", "obj", "objectKey", "additionalHeaders", "responseType", "S3Object", "data", "params", "S3UploadedObject", "sourceBucket", "sourceKey", "destinationBucket", "destinationKey", "bucketEndpoint", "S3MultipartUpload", "uploadId", "partNumber", "S3Part", "parts", "body", "part", "response", "operation", "errorMessage", "S3ServiceError", "awsError", "AWSError", "InvalidSignatureError", "S3Bucket", "name", "creationDate", "key", "lastModified", "etag", "size", "storageClass", "_S3UploadedObject", "options", "eTag", "message", "code", "http", "SecretsManagerClient", "AWSClient", "awsConfig", "SignatureV4", "signedRequest", "AMZ_TARGET_HEADER", "res", "http", "Secret", "id", "name", "secret", "description", "versionID", "tags", "recoveryWindow", "noRecovery", "payload", "response", "operation", "errorCode", "error", "errorMessage", "InvalidSignatureError", "SecretsManagerServiceError", "_Secret", "arn", "secretString", "createdDate", "lastAccessedDate", "lastChangedDate", "json", "AWSError", "message", "code", "http", "SystemsManagerClient", "AWSClient", "awsConfig", "SignatureV4", "name", "withDecryption", "signedRequest", "AMZ_TARGET_HEADER", "res", "http", "SystemsManagerParameter", "response", "operation", "errorCode", "error", "errorMessage", "InvalidSignatureError", "SystemsManagerServiceError", "_SystemsManagerParameter", "arn", "dataType", "lastModifiedDate", "selector", "sourceResult", "type", "value", "version", "json", "parameter", "AWSError", "message", "code", "http", "SQSClient", "AWSClient", "awsConfig", "SignatureV4", "queueUrl", "receiptHandle", "action", "body", "messageAttributeNames", "messageSystemAttributeNames", "maxNumberOfMessages", "visibilityTimeout", "waitTimeSeconds", "receiveRequestAttemptId", "messagesArray", "messages", "msg", "ReceivedMessage", "messageBody", "options", "parsed", "MessageResponse", "entries", "requestMessageEntries", "entry", "requestMessageEntry", "successful", "failed", "SQSServiceError", "parameters", "messageAttributes", "name", "attribute", "valueParameterSuffix", "signedRequest", "AMZ_TARGET_HEADER", "res", "http", "operation", "response", "error", "errorMessage", "InvalidSignatureError", "ReceivedMessageAttributes", "capturedMessageAttributes", "capturedMessage", "id", "bodyMD5", "SQSServiceError", "AWSError", "message", "code", "operation", "http", "KinesisClient", "AWSClient", "awsConfig", "SignatureV4", "streamName", "options", "body", "parameters", "res", "ListStreamsResponse", "records", "PutRecordsResponse", "shardIterator", "GetRecordsResponse", "ListShardsResponse", "shardId", "shardIteratorType", "GetShardIteratorResponse", "action", "signedRequest", "AMZ_TARGET_HEADER", "http", "response", "operation", "errorCode", "error", "errorMessage", "InvalidSignatureError", "KinesisServiceError", "AWSError", "message", "code", "_ListStreamsResponse", "HasMoreStreams", "NextToken", "StreamNames", "StreamSummaries", "result", "StreamSummary", "_StreamSummary", "StreamARN", "StreamCreationTimestamp", "StreamMode", "StreamName", "StreamStatus", "summary", "StreamModeDetails", "_PutRecordsResponse", "encryptionType", "failedRecordCount", "json", "EncryptionType", "FailedRecordCount", "Records", "PutRecordsResultEntry", "_PutRecordsResultEntry", "sequenceNumber", "_GetRecordsResponse", "nextShardIterator", "millisBehindLatest", "NextShardIterator", "MillisBehindLatest", "Record", "_Record", "data", "partitionKey", "_ListShardsResponse", "shards", "nextToken", "Shards", "Shard", "_Shard", "id", "hashKeyRange", "sequenceNumberRange", "parentShardId", "adjacentParentShardId", "_GetShardIteratorResponse", "http", "EventBridgeClient", "AWSClient", "awsConfig", "SignatureV4", "input", "parsedEvent", "entry", "signedRequest", "AMZ_TARGET_HEADER", "res", "http", "response", "operation", "errorCode", "error", "errorMessage", "InvalidSignatureError", "EventBridgeServiceError", "EventBridgeServiceError", "AWSError", "message", "code", "operation", "http", "encoding", "LambdaClient", "AWSClient", "awsConfig", "SignatureV4", "name", "payload", "options", "query", "invocationType", "headers", "AMZ_TARGET_HEADER", "signedRequest", "res", "http", "logResult", "response", "encoding", "functionError", "LambdaInvocationError", "operation", "awsError", "AWSError", "InvalidSignatureError", "message"]
}
