var M="X-Amz-Algorithm",w="X-Amz-Credential",D="X-Amz-Date",k="X-Amz-Expires",I="X-Amz-Signature",U="X-Amz-SignedHeaders",ie="X-Amz-Target",N="X-Amz-Security-Token",_="x-amz-content-sha256",x=D.toLowerCase(),z=I.toLowerCase(),Ae=ie.toLowerCase(),F=N.toLowerCase(),b="authorization",ae="date",X=[b,x,ae],y="host",q={authorization:!0,"cache-control":!0,connection:!0,expect:!0,from:!0,"keep-alive":!0,"max-forwards":!0,pragma:!0,referer:!0,te:!0,trailer:!0,"transfer-encoding":!0,upgrade:!0,"user-agent":!0,"x-amzn-trace-id":!0},G="aws4_request",S="AWS4-HMAC-SHA256",V=60*60*24*7,J="e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";var L="UNSIGNED-PAYLOAD";var H=class n{_protocol;_hostname;_port;static DEFAULT_PROTOCOL="https";constructor(e){let o=!e.startsWith("http://")&&!e.startsWith("https://")?`${n.DEFAULT_PROTOCOL}://${e}`:e,r=o.match(/^https?:/),s=o.replace(/^https?:\/\//,""),[i]=s.split("/");this._protocol=r?r[0].slice(0,-1):n.DEFAULT_PROTOCOL,this._hostname=i.split(":")[0],this._port=i.split(":")[1]?parseInt(i.split(":")[1]):void 0}copy(){return new n(this.href)}get host(){return this._port?`${this._hostname}:${this._port}`:this._hostname}set host(e){let[t,o]=e.split(":");this._hostname=t,this._port=o?parseInt(o):void 0}get hostname(){return this._hostname}set hostname(e){this._hostname=e}get href(){return`${this.protocol}://${this.host}`}set href(e){let t=e.match(/^https?:/),o=e.replace(/^https?:\/\//,""),[r]=o.split("/");this._protocol=t?t[0].slice(0,-1):n.DEFAULT_PROTOCOL,this._hostname=r.split(":")[0],this._port=r.split(":")[1]?parseInt(r.split(":")[1]):void 0}get port(){return this._port}set port(e){this._port=e}get protocol(){return this._protocol}set protocol(e){this._protocol=e}};var v=class n{region;accessKeyId;secretAccessKey;sessionToken;endpoint;static fromEnvironment(e){let t=__ENV.AWS_REGION,o=__ENV.AWS_ACCESS_KEY_ID,r=__ENV.AWS_SECRET_ACCESS_KEY,s=__ENV.AWS_SESSION_TOKEN,i=e?.endpoint;return new n({region:t,accessKeyId:o,secretAccessKey:r,sessionToken:s,endpoint:i})}constructor(e){if(!e.region||e.region==="")throw new E(`invalid AWS region; reason: expected a valid AWS region name (e.g. "us-east-1"), got \`${e.region}\``);if(!e.accessKeyId||e.accessKeyId==="")throw new E(`invalid AWS access key ID; reason: expected a non empty string, got \`${e.accessKeyId}\``);if(e.accessKeyId.length<16||e.accessKeyId.length>128&&e.sessionToken!=null)throw new E(`invalid AWS access key ID; reason: size should be between 16 and 128 characters, got ${e.accessKeyId.length}`);if(!e.secretAccessKey||e.secretAccessKey==="")throw new E(`invalid AWS secret access key; reason: expected a non empty string, got \`${e.secretAccessKey}\``);this.region=e.region,this.accessKeyId=e.accessKeyId,this.secretAccessKey=e.secretAccessKey,e.sessionToken!==void 0&&(this.sessionToken=e.sessionToken),e.endpoint!==void 0&&(typeof e.endpoint=="string"?this.endpoint=new H(e.endpoint):this.endpoint=e.endpoint)}},E=class extends Error{constructor(e){super(e)}};import{parseHTML as pe}from"k6/html";var P=class n extends Error{code;constructor(e,t){super(e),this.name="AWSError",this.code=t}static parseXML(e){let t=pe(e);return new n(t.find("Message").text(),t.find("Code").text())}static parse(e){if(e.headers["Content-Type"]==="application/json"){let t=e.json()||{},o=t.Message||t.message||t.__type||"An error occurred on the server side",r=e.headers["X-Amzn-Errortype"]||t.__type;return new n(o,r)}else return n.parseXML(e.body)}},d=class extends Error{code;name;constructor(e,t){super(ge[t]||"An unknown error occurred"),this.name=e,this.code=t}},$=class extends d{constructor(e){super("GeneralError",e)}},B=class extends d{constructor(e){super("DNSError",e)}},Z=class extends d{constructor(e){super("TCPError",e)}},K=class extends d{constructor(e){super("TLSError",e)}},Y=class extends d{constructor(e){super("HTTP2Error",e)}};var ge={1e3:"A generic error that isn\u2019t any of the ones listed below",1010:"A non-TCP network error - this is a placeholder and there is no error currently known to trigger it",1020:"An invalid URL was specified",1050:"The HTTP request has timed out",1100:"A generic DNS error that isn\u2019t any of the ones listed below",1101:"No IP for the provided host was found",1110:"Blacklisted IP was resolved or a connection to such was tried to be established",1111:"Blacklisted hostname using The Block Hostnames option",1200:"A generic TCP error that isn\u2019t any of the ones listed below",1201:"A \u201Cbroken pipe\u201D on write - the other side has likely closed the connection",1202:"An unknown TCP error - We got an error that we don\u2019t recognize but it is from the operating system and has errno set on it. The message in error includes the operation(write,read) and the errno, the OS, and the original message of the error",1210:"General TCP dial error",1211:"Dial timeout error - the timeout for the dial was reached",1212:"Dial connection refused - the connection was refused by the other party on dial",1213:"Dial unknown error",1220:"Reset by peer - the connection was reset by the other party, most likely a server",1300:"General TLS error",1310:"Unknown authority - the certificate issuer is unknown",1311:"The certificate doesn\u2019t match the hostname",1600:"A generic HTTP/2 error that isn\u2019t any of the ones listed below",1610:"A general HTTP/2 GoAway error"};import u from"k6/crypto";function ee(n,e){n=n.toLowerCase();for(let t of Object.keys(e))if(n===t.toLowerCase())return!0;return!1}function te(n){return typeof ArrayBuffer=="function"&&(n instanceof ArrayBuffer||Object.prototype.toString.call(n)==="[object ArrayBuffer]")}var Q=class{service;region;credentials;uriEscapePath;applyChecksum;constructor({service:e,region:t,credentials:o,uriEscapePath:r,applyChecksum:s}){this.service=e,this.region=t,this.credentials=o,this.uriEscapePath=typeof r=="boolean"?r:!0,this.applyChecksum=typeof s=="boolean"?s:!0}sign(e,t={}){let r={...{signingDate:new Date,unsignableHeaders:new Set,signableHeaders:new Set},...t},{longDate:s,shortDate:i}=re(r.signingDate),a=r.signingService||this.service,p=r.signingRegion||this.region,T=`${i}/${p}/${a}/${G}`;e.headers[y]||(e.headers[y]=e.endpoint.hostname);for(let R of Object.keys(e.headers))X.indexOf(R.toLowerCase())>-1&&delete e.headers[R];e.headers[x]=s,this.credentials.sessionToken&&(e.headers[F]=this.credentials.sessionToken),ArrayBuffer.isView(e.body)&&(e.body=e.body.buffer),e.body||(e.body="");let l=this.computePayloadHash(e);!ee(_,e.headers)&&this.applyChecksum&&(e.headers[_]=l);let h=this.computeCanonicalHeaders(e,r.unsignableHeaders,r.signableHeaders),f=this.calculateSignature(s,T,this.deriveSigningKey(this.credentials,a,p,i),this.createCanonicalRequest(e,h,l));e.headers[b]=`${S} Credential=${this.credentials.accessKeyId}/${T}, SignedHeaders=${Object.keys(h).sort().join(";")}, Signature=${f}`;let g=e.endpoint.href;return e.path&&(!g.endsWith("/")&&!e.path.startsWith("/")&&(g+="/"),g+=e.path),e.query&&(g+=`?${this.serializeQueryParameters(e.query)}`),{url:g,...e}}presign(e,t={}){let{signingDate:o=new Date,expiresIn:r=3600,unsignableHeaders:s,unhoistableHeaders:i,signableHeaders:a,signingRegion:p,signingService:T}=t,{longDate:l,shortDate:h}=re(o),f=p||this.region,g=T||this.service;if(r>V)throw new C("Signature version 4 presigned URLs can't be valid for more than 7 days");let R=`${h}/${f}/${g}/${G}`,c=this.moveHeadersToQuery(e,{unhoistableHeaders:i});c.headers[y]||(c.headers[y]=e.endpoint.hostname),this.credentials.sessionToken&&(c.query[N]=this.credentials.sessionToken),c.query[M]=S,c.query[w]=`${this.credentials.accessKeyId}/${R}`,c.query[D]=l,c.query[k]=r.toString(10);let j=this.computeCanonicalHeaders(c,s,a);c.query[U]=Object.keys(j).sort().join(";");let ne=this.deriveSigningKey(this.credentials,g,f,h),se=this.computePayloadHash(e),oe=this.createCanonicalRequest(c,j,se);c.query[I]=this.calculateSignature(l,R,ne,oe);let m=e.endpoint.href;return c.path&&(!m.endsWith("/")&&!c.path.startsWith("/")&&(m+="/"),m+=c.path),c.query&&(m+=`?${this.serializeQueryParameters(c.query)}`),{url:m,...c}}createCanonicalRequest(e,t,o){let r=Object.keys(t).sort(),s=r.map(a=>`${a}:${t[a]}`).join(`
`),i=r.join(";");return`${e.method}
${this.computeCanonicalURI(e)}
${this.computeCanonicalQuerystring(e)}
${s}

${i}
${o}`}createStringToSign(e,t,o){let r=u.sha256(o,"hex");return`${S}
${e}
${t}
${r}`}calculateSignature(e,t,o,r){let s=this.createStringToSign(e,t,r);return u.hmac("sha256",o,s,"hex")}deriveSigningKey(e,t,o,r){let s=e.secretAccessKey,i=u.hmac("sha256","AWS4"+s,r,"binary"),a=O(i),p=u.hmac("sha256",W(a),o,"binary"),T=O(p),l=u.hmac("sha256",W(T),t,"binary"),h=O(l),f=u.hmac("sha256",W(h),"aws4_request","binary");return O(f)}computeCanonicalURI({path:e}){if(this.uriEscapePath){let t=[];for(let p of e.split("/"))p?.length!==0&&p!=="."&&(p===".."?t.pop():t.push(p));let o=e?.startsWith("/")?"/":"",r=t.join("/"),s=t.length>0&&e?.endsWith("/")?"/":"",i=`${o}${r}${s}`;return encodeURIComponent(i).replace(/%2F/g,"/")}return e}computeCanonicalQuerystring({query:e={}}){let t=[],o={};for(let r of Object.keys(e).sort()){if(r.toLowerCase()===z)continue;t.push(r);let s=e[r];typeof s=="string"?o[r]=`${A(r)}=${A(s)}`:Array.isArray(s)&&(o[r]=s.slice(0).sort().reduce((i,a)=>i.concat([`${A(r)}=${A(a)}`]),[]).join("&"))}return t.map(r=>o[r]).filter(r=>r).join("&")}computeCanonicalHeaders({headers:e},t,o){let r={};for(let s of Object.keys(e).sort()){if(e[s]==null)continue;let i=s.toLowerCase();(i in q||t?.has(i))&&(!o||o&&!o.has(i))||typeof e[s]=="string"&&(r[i]=e[s]=e[s].trim().replace(/\s+/g," "))}return r}computePayloadHash({headers:e,body:t}){return e[_]?e[_]:t==null?J:typeof t=="string"||te(t)?u.sha256(t,"hex").toLowerCase():ArrayBuffer.isView(t)?u.sha256(t.buffer,"hex").toLowerCase():L}moveHeadersToQuery(e,t={}){let o=JSON.parse(JSON.stringify(e)),{headers:r,query:s={}}=o;for(let i of Object.keys(r)){let a=i.toLowerCase();a.slice(0,6)==="x-amz-"&&!t.unhoistableHeaders?.has(a)&&(s[i]=r[i],delete r[i])}return{...o,headers:r,query:s}}serializeQueryParameters(e,t){let o=[],r={};for(let s of Object.keys(e).sort()){if(t?.includes(s.toLowerCase()))continue;o.push(s);let i=e[s];typeof i=="string"?r[s]=`${A(s)}=${A(i)}`:Array.isArray(i)&&(r[s]=i.slice(0).sort().reduce((a,p)=>a.concat([`${A(s)}=${A(p)}`]),[]).join("&"))}return o.map(s=>r[s]).filter(s=>s).join("&")}},C=class extends P{constructor(e,t){super(e,t),this.name="InvalidSignatureError"}};function O(n){return new Uint8Array(n)}function W(n){return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}function A(n){let e=t=>`%${t.charCodeAt(0).toString(16).toUpperCase()}`;return encodeURIComponent(n).replace(/[!'()*]/g,e)}function re(n){let e=de(n).replace(/[-:]/g,"");return{longDate:e,shortDate:e.slice(0,8)}}function de(n){return ue(n).toISOString().replace(/\.\d{3}Z$/,"Z")}function ue(n){return typeof n=="number"?new Date(n*1e3):typeof n=="string"?Number(n)?new Date(Number(n)*1e3):new Date(n):n}export{M as AMZ_ALGORITHM_QUERY_PARAM,_ as AMZ_CONTENT_SHA256_HEADER,w as AMZ_CREDENTIAL_QUERY_PARAM,x as AMZ_DATE_HEADER,D as AMZ_DATE_QUERY_PARAM,k as AMZ_EXPIRES_QUERY_PARAM,I as AMZ_SIGNATURE_QUERY_PARAM,U as AMZ_SIGNED_HEADERS_QUERY_PARAM,N as AMZ_TOKEN_QUERY_PARAM,b as AUTHORIZATION_HEADER,v as AWSConfig,P as AWSError,B as DNSError,H as Endpoint,$ as GeneralError,y as HOST_HEADER,Y as HTTP2Error,E as InvalidAWSConfigError,C as InvalidSignatureError,d as NetworkError,S as SIGNING_ALGORITHM_IDENTIFIER,Q as SignatureV4,Z as TCPError,K as TLSError,L as UNSIGNED_PAYLOAD};
//# sourceMappingURL=signature.js.map
