import{parseHTML as Ve}from"k6/html";var g=class i extends Error{code;constructor(e,t){super(e),this.name="AWSError",this.code=t}static parseXML(e){let t=Ve(e);return new i(t.find("Message").text(),t.find("Code").text())}static parse(e){if(e.headers["Content-Type"]==="application/json"){let t=e.json()||{},r=t.Message||t.message||t.__type||"An error occurred on the server side",s=e.headers["X-Amzn-Errortype"]||t.__type;return new i(r,s)}else return i.parseXML(e.body)}},T=class extends Error{code;name;constructor(e,t){super(Ze[t]||"An unknown error occurred"),this.name=e,this.code=t}},P=class extends T{constructor(e){super("GeneralError",e)}},x=class extends T{constructor(e){super("DNSError",e)}},_=class extends T{constructor(e){super("TCPError",e)}},I=class extends T{constructor(e){super("TLSError",e)}},C=class extends T{constructor(e){super("HTTP2Error",e)}};var Ze={1e3:"A generic error that isn\u2019t any of the ones listed below",1010:"A non-TCP network error - this is a placeholder and there is no error currently known to trigger it",1020:"An invalid URL was specified",1050:"The HTTP request has timed out",1100:"A generic DNS error that isn\u2019t any of the ones listed below",1101:"No IP for the provided host was found",1110:"Blacklisted IP was resolved or a connection to such was tried to be established",1111:"Blacklisted hostname using The Block Hostnames option",1200:"A generic TCP error that isn\u2019t any of the ones listed below",1201:"A \u201Cbroken pipe\u201D on write - the other side has likely closed the connection",1202:"An unknown TCP error - We got an error that we don\u2019t recognize but it is from the operating system and has errno set on it. The message in error includes the operation(write,read) and the errno, the OS, and the original message of the error",1210:"General TCP dial error",1211:"Dial timeout error - the timeout for the dial was reached",1212:"Dial connection refused - the connection was refused by the other party on dial",1213:"Dial unknown error",1220:"Reset by peer - the connection was reset by the other party, most likely a server",1300:"General TLS error",1310:"Unknown authority - the certificate issuer is unknown",1311:"The certificate doesn\u2019t match the hostname",1600:"A generic HTTP/2 error that isn\u2019t any of the ones listed below",1610:"A general HTTP/2 GoAway error"};import b from"k6/crypto";var He="X-Amz-Algorithm",De="X-Amz-Credential",te="X-Amz-Date",ve="X-Amz-Expires",re="X-Amz-Signature",Me="X-Amz-SignedHeaders",Ye="X-Amz-Target",se="X-Amz-Security-Token",D="x-amz-content-sha256",ne=te.toLowerCase(),ke=re.toLowerCase(),m=Ye.toLowerCase(),qe=se.toLowerCase(),oe="authorization",Fe="date",je=[oe,ne,Fe],k="host",Le={authorization:!0,"cache-control":!0,connection:!0,expect:!0,from:!0,"keep-alive":!0,"max-forwards":!0,pragma:!0,referer:!0,te:!0,trailer:!0,"transfer-encoding":!0,upgrade:!0,"user-agent":!0,"x-amzn-trace-id":!0},ie="aws4_request",$="AWS4-HMAC-SHA256",Ue=60*60*24*7,Je="e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";var ae="UNSIGNED-PAYLOAD";function Ge(i,e){i=i.toLowerCase();for(let t of Object.keys(e))if(i===t.toLowerCase())return!0;return!1}function Ke(i){return typeof ArrayBuffer=="function"&&(i instanceof ArrayBuffer||Object.prototype.toString.call(i)==="[object ArrayBuffer]")}var p=class{service;region;credentials;uriEscapePath;applyChecksum;constructor({service:e,region:t,credentials:r,uriEscapePath:s,applyChecksum:n}){this.service=e,this.region=t,this.credentials=r,this.uriEscapePath=typeof s=="boolean"?s:!0,this.applyChecksum=typeof n=="boolean"?n:!0}sign(e,t={}){let s={...{signingDate:new Date,unsignableHeaders:new Set,signableHeaders:new Set},...t},{longDate:n,shortDate:o}=Be(s.signingDate),a=s.signingService||this.service,c=s.signingRegion||this.region,d=`${o}/${c}/${a}/${ie}`;e.headers[k]||(e.headers[k]=e.endpoint.hostname);for(let N of Object.keys(e.headers))je.indexOf(N.toLowerCase())>-1&&delete e.headers[N];e.headers[ne]=n,this.credentials.sessionToken&&(e.headers[qe]=this.credentials.sessionToken),ArrayBuffer.isView(e.body)&&(e.body=e.body.buffer),e.body||(e.body="");let u=this.computePayloadHash(e);!Ge(D,e.headers)&&this.applyChecksum&&(e.headers[D]=u);let S=this.computeCanonicalHeaders(e,s.unsignableHeaders,s.signableHeaders),A=this.calculateSignature(n,d,this.deriveSigningKey(this.credentials,a,c,o),this.createCanonicalRequest(e,S,u));e.headers[oe]=`${$} Credential=${this.credentials.accessKeyId}/${d}, SignedHeaders=${Object.keys(S).sort().join(";")}, Signature=${A}`;let f=e.endpoint.href;return e.path&&(!f.endsWith("/")&&!e.path.startsWith("/")&&(f+="/"),f+=e.path),e.query&&(f+=`?${this.serializeQueryParameters(e.query)}`),{url:f,...e}}presign(e,t={}){let{signingDate:r=new Date,expiresIn:s=3600,unsignableHeaders:n,unhoistableHeaders:o,signableHeaders:a,signingRegion:c,signingService:d}=t,{longDate:u,shortDate:S}=Be(r),A=c||this.region,f=d||this.service;if(s>Ue)throw new h("Signature version 4 presigned URLs can't be valid for more than 7 days");let N=`${S}/${A}/${f}/${ie}`,y=this.moveHeadersToQuery(e,{unhoistableHeaders:o});y.headers[k]||(y.headers[k]=e.endpoint.hostname),this.credentials.sessionToken&&(y.query[se]=this.credentials.sessionToken),y.query[He]=$,y.query[De]=`${this.credentials.accessKeyId}/${N}`,y.query[te]=u,y.query[ve]=s.toString(10);let we=this.computeCanonicalHeaders(y,n,a);y.query[Me]=Object.keys(we).sort().join(";");let We=this.deriveSigningKey(this.credentials,f,A,S),ze=this.computePayloadHash(e),Qe=this.createCanonicalRequest(y,we,ze);y.query[re]=this.calculateSignature(u,N,We,Qe);let M=e.endpoint.href;return y.path&&(!M.endsWith("/")&&!y.path.startsWith("/")&&(M+="/"),M+=y.path),y.query&&(M+=`?${this.serializeQueryParameters(y.query)}`),{url:M,...y}}createCanonicalRequest(e,t,r){let s=Object.keys(t).sort(),n=s.map(a=>`${a}:${t[a]}`).join(`
`),o=s.join(";");return`${e.method}
${this.computeCanonicalURI(e)}
${this.computeCanonicalQuerystring(e)}
${n}

${o}
${r}`}createStringToSign(e,t,r){let s=b.sha256(r,"hex");return`${$}
${e}
${t}
${s}`}calculateSignature(e,t,r,s){let n=this.createStringToSign(e,t,s);return b.hmac("sha256",r,n,"hex")}deriveSigningKey(e,t,r,s){let n=e.secretAccessKey,o=b.hmac("sha256","AWS4"+n,s,"binary"),a=W(o),c=b.hmac("sha256",ce(a),r,"binary"),d=W(c),u=b.hmac("sha256",ce(d),t,"binary"),S=W(u),A=b.hmac("sha256",ce(S),"aws4_request","binary");return W(A)}computeCanonicalURI({path:e}){if(this.uriEscapePath){let t=[];for(let c of e.split("/"))c?.length!==0&&c!=="."&&(c===".."?t.pop():t.push(c));let r=e?.startsWith("/")?"/":"",s=t.join("/"),n=t.length>0&&e?.endsWith("/")?"/":"",o=`${r}${s}${n}`;return encodeURIComponent(o).replace(/%2F/g,"/")}return e}computeCanonicalQuerystring({query:e={}}){let t=[],r={};for(let s of Object.keys(e).sort()){if(s.toLowerCase()===ke)continue;t.push(s);let n=e[s];typeof n=="string"?r[s]=`${O(s)}=${O(n)}`:Array.isArray(n)&&(r[s]=n.slice(0).sort().reduce((o,a)=>o.concat([`${O(s)}=${O(a)}`]),[]).join("&"))}return t.map(s=>r[s]).filter(s=>s).join("&")}computeCanonicalHeaders({headers:e},t,r){let s={};for(let n of Object.keys(e).sort()){if(e[n]==null)continue;let o=n.toLowerCase();(o in Le||t?.has(o))&&(!r||r&&!r.has(o))||typeof e[n]=="string"&&(s[o]=e[n]=e[n].trim().replace(/\s+/g," "))}return s}computePayloadHash({headers:e,body:t}){return e[D]?e[D]:t==null?Je:typeof t=="string"||Ke(t)?b.sha256(t,"hex").toLowerCase():ArrayBuffer.isView(t)?b.sha256(t.buffer,"hex").toLowerCase():ae}moveHeadersToQuery(e,t={}){let r=JSON.parse(JSON.stringify(e)),{headers:s,query:n={}}=r;for(let o of Object.keys(s)){let a=o.toLowerCase();a.slice(0,6)==="x-amz-"&&!t.unhoistableHeaders?.has(a)&&(n[o]=s[o],delete s[o])}return{...r,headers:s,query:n}}serializeQueryParameters(e,t){let r=[],s={};for(let n of Object.keys(e).sort()){if(t?.includes(n.toLowerCase()))continue;r.push(n);let o=e[n];typeof o=="string"?s[n]=`${O(n)}=${O(o)}`:Array.isArray(o)&&(s[n]=o.slice(0).sort().reduce((a,c)=>a.concat([`${O(n)}=${O(c)}`]),[]).join("&"))}return r.map(n=>s[n]).filter(n=>n).join("&")}},h=class extends g{constructor(e,t){super(e,t),this.name="InvalidSignatureError"}};function W(i){return new Uint8Array(i)}function ce(i){return i.buffer.slice(i.byteOffset,i.byteOffset+i.byteLength)}function O(i){let e=t=>`%${t.charCodeAt(0).toString(16).toUpperCase()}`;return encodeURIComponent(i).replace(/[!'()*]/g,e)}function Be(i){let e=et(i).replace(/[-:]/g,"");return{longDate:e,shortDate:e.slice(0,8)}}function et(i){return tt(i).toISOString().replace(/\.\d{3}Z$/,"Z")}function tt(i){return typeof i=="number"?new Date(i*1e3):typeof i=="string"?Number(i)?new Date(Number(i)*1e3):new Date(i):i}var w=class i{_protocol;_hostname;_port;static DEFAULT_PROTOCOL="https";constructor(e){let r=!e.startsWith("http://")&&!e.startsWith("https://")?`${i.DEFAULT_PROTOCOL}://${e}`:e,s=r.match(/^https?:/),n=r.replace(/^https?:\/\//,""),[o]=n.split("/");this._protocol=s?s[0].slice(0,-1):i.DEFAULT_PROTOCOL,this._hostname=o.split(":")[0],this._port=o.split(":")[1]?parseInt(o.split(":")[1]):void 0}copy(){return new i(this.href)}get host(){return this._port?`${this._hostname}:${this._port}`:this._hostname}set host(e){let[t,r]=e.split(":");this._hostname=t,this._port=r?parseInt(r):void 0}get hostname(){return this._hostname}set hostname(e){this._hostname=e}get href(){return`${this.protocol}://${this.host}`}set href(e){let t=e.match(/^https?:/),r=e.replace(/^https?:\/\//,""),[s]=r.split("/");this._protocol=t?t[0].slice(0,-1):i.DEFAULT_PROTOCOL,this._hostname=s.split(":")[0],this._port=s.split(":")[1]?parseInt(s.split(":")[1]):void 0}get port(){return this._port}set port(e){this._port=e}get protocol(){return this._protocol}set protocol(e){this._protocol=e}};var q=class i{region;accessKeyId;secretAccessKey;sessionToken;endpoint;static fromEnvironment(e){let t=__ENV.AWS_REGION,r=__ENV.AWS_ACCESS_KEY_ID,s=__ENV.AWS_SECRET_ACCESS_KEY,n=__ENV.AWS_SESSION_TOKEN,o=e?.endpoint;return new i({region:t,accessKeyId:r,secretAccessKey:s,sessionToken:n,endpoint:o})}constructor(e){if(!e.region||e.region==="")throw new R(`invalid AWS region; reason: expected a valid AWS region name (e.g. "us-east-1"), got \`${e.region}\``);if(!e.accessKeyId||e.accessKeyId==="")throw new R(`invalid AWS access key ID; reason: expected a non empty string, got \`${e.accessKeyId}\``);if(e.accessKeyId.length<16||e.accessKeyId.length>128&&e.sessionToken!=null)throw new R(`invalid AWS access key ID; reason: size should be between 16 and 128 characters, got ${e.accessKeyId.length}`);if(!e.secretAccessKey||e.secretAccessKey==="")throw new R(`invalid AWS secret access key; reason: expected a non empty string, got \`${e.secretAccessKey}\``);this.region=e.region,this.accessKeyId=e.accessKeyId,this.secretAccessKey=e.secretAccessKey,e.sessionToken!==void 0&&(this.sessionToken=e.sessionToken),e.endpoint!==void 0&&(typeof e.endpoint=="string"?this.endpoint=new w(e.endpoint):this.endpoint=e.endpoint)}},R=class extends Error{constructor(e){super(e)}};import $e from"k6/http";var l=class{awsConfig;serviceName;baseRequestParams={responseType:"text"};_endpoint;constructor(e,t){this.awsConfig=e,this.serviceName=t,e.endpoint!=null&&(this._endpoint=e.endpoint)}get endpoint(){return this._endpoint==null&&(this._endpoint=new w(`https://${this.serviceName}.${this.awsConfig.region}.amazonaws.com`)),this._endpoint}set endpoint(e){this._endpoint=e}handleError(e,t){let r=e.status,s=e.error_code,n=e.error;if(r>=200&&r<300&&n==""&&s===0)return!1;switch(s){case 1e3:case 1010:case 1020:case 1050:throw new P(s);case 1100:case 1101:case 1110:case 1111:throw new x(s);case 1200:case 1201:case 1202:case 1210:case 1211:case 1212:case 1213:case 1220:throw new _(s);case 1300:case 1310:case 1311:throw new I(s);case 1600:case 1610:throw new C(s)}return!0}};var de=class extends l{signature;method;commonHeaders;constructor(e){super(e,"kms"),this.signature=new p({service:this.serviceName,region:e.region,credentials:{accessKeyId:e.accessKeyId,secretAccessKey:e.secretAccessKey,sessionToken:e.sessionToken},uriEscapePath:!0,applyChecksum:!1}),this.method="POST",this.commonHeaders={"Content-Type":"application/x-amz-json-1.1"}}async listKeys(){let e=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:"TrentService.ListKeys"},body:JSON.stringify({})},{}),t=await $e.asyncRequest(this.method,e.url,e.body,{...this.baseRequestParams,headers:e.headers});return this.handleError(t,"ListKeys"),t.json("Keys").map(s=>ue.fromJSON(s))}async generateDataKey(e,t=32){let r=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:"TrentService.GenerateDataKey"},body:JSON.stringify({KeyId:e,NumberOfBytes:t})},{}),s=await $e.asyncRequest(this.method,r.url,r.body,{...this.baseRequestParams,headers:r.headers});return this.handleError(s,"GenerateDataKey"),z.fromJSON(s.json())}handleError(e,t){if(!super.handleError(e,t))return!1;let s=e.error_code,n=e.json();if(s>=1400&&s<=1499){let o=n.Message||n.message||n.__type;throw n.__type==="InvalidSignatureException"?new h(o,n.__type):new j(o,n.__type,t)}if(s===1500)throw new j("An error occured on the server side","InternalServiceError",t);return!0}},ue=class i{keyArn;keyId;constructor(e,t){this.keyArn=e,this.keyId=t}static fromJSON(e){return new i(e.KeyArn,e.KeyId)}},z=class i{id;ciphertextBlob;plaintext;constructor(e,t,r){this.ciphertextBlob=e,this.id=t,this.plaintext=r}static fromJSON(e){return new i(e.CiphertextBlob,e.KeyId,e.Plaintext)}},j=class extends g{operation;constructor(e,t,r){super(e,t),this.name="KMSServiceError",this.operation=r}};import{parseHTML as ge}from"k6/html";import E from"k6/http";var he=class extends l{signature;constructor(e){super(e,"s3"),this.signature=new p({service:this.serviceName,region:this.awsConfig.region,credentials:{accessKeyId:this.awsConfig.accessKeyId,secretAccessKey:this.awsConfig.secretAccessKey,sessionToken:this.awsConfig.sessionToken},uriEscapePath:!1,applyChecksum:!0})}async listBuckets(){let e="GET",t=this.signature.sign({method:"GET",endpoint:this.endpoint,path:"/",headers:{}},{}),r=await E.asyncRequest(e,t.url,t.body||null,{...this.baseRequestParams,headers:t.headers});this.handleError(r,"ListBuckets");let s=[];return ge(r.body).find("Buckets").children().each((o,a)=>{let c={};a.children().forEach(d=>{switch(d.nodeName()){case"name":Object.assign(c,{name:d.textContent()});break;case"creationdate":Object.assign(c,{creationDate:Date.parse(d.textContent())})}}),s.push(c)}),s}async listObjects(e,t){let r="GET",s=this.signature.sign({method:r,endpoint:this.endpoint,path:encodeURI(`/${e}/`),query:{"list-type":"2",prefix:t||""},headers:{}},{}),n=await E.asyncRequest(r,s.url,s.body||null,{...this.baseRequestParams,headers:s.headers});this.handleError(n,"ListObjectsV2");let o=[];return ge(n.body).find("Contents").each((a,c)=>{let d={};c.children().forEach(u=>{switch(u.nodeName()){case"key":Object.assign(d,{key:u.textContent()});break;case"lastmodified":Object.assign(d,{lastModified:Date.parse(u.textContent())});break;case"etag":Object.assign(d,{etag:u.textContent()});break;case"size":Object.assign(d,{size:parseInt(u.textContent())});break;case"storageclass":Object.assign(d,{storageClass:u.textContent()})}}),o.push(d)}),o}async getObject(e,t,r={}){let s="GET",n=this.signature.sign({method:s,endpoint:this.endpoint,path:encodeURI(`/${e}/${t}`),headers:{...r}},{}),o="text";"Accept"in r&&r.Accept!==void 0&&r.Accept==="application/octet-stream"&&(o="binary");let a=await E.asyncRequest(s,n.url,null,{...this.baseRequestParams,headers:n.headers,responseType:o});return this.handleError(a,"GetObject"),new Q(t,Date.parse(a.headers["Last-Modified"]),a.headers.ETag,parseInt(a.headers["Content-Length"]),a.headers["X-Amz-Storage-Class"]??"STANDARD",a.body)}async putObject(e,t,r,s){let n="PUT",o=this.signature.sign({method:n,endpoint:this.endpoint,path:encodeURI(`/${e}/${t}`),headers:{Host:this.endpoint.host,...s?.contentDisposition&&{"Content-Disposition":s.contentDisposition},...s?.contentEncoding&&{"Content-Encoding":s.contentEncoding},...s?.contentLength&&{"Content-Length":s.contentLength},...s?.contentMD5&&{"Content-MD5":s.contentMD5},...s?.contentType&&{"Content-Type":s.contentType}},body:r},{}),a=await E.asyncRequest(n,o.url,o.body,{...this.baseRequestParams,headers:o.headers});return this.handleError(a,"PutObject"),pe.fromResponse(a,t)}async deleteObject(e,t){let r="DELETE",s=this.signature.sign({method:r,endpoint:this.endpoint,path:encodeURI(`/${e}/${t}`),headers:{}},{}),n=await E.asyncRequest(r,s.url,s.body||null,{...this.baseRequestParams,headers:s.headers});this.handleError(n,"DeleteObject")}async copyObject(e,t,r,s){let n="PUT",o=this.endpoint.copy();o.hostname=`${r}.${this.endpoint.hostname}`;let a=this.signature.sign({method:n,endpoint:o,path:encodeURI(`/${s}`),headers:{"x-amz-copy-source":`${e}/${t}`}},{}),c=await E.asyncRequest(n,a.url,a.body||null,{...this.baseRequestParams,headers:a.headers});this.handleError(c,"CopyObject")}async createMultipartUpload(e,t){let r="POST",s=this.endpoint.copy();s.hostname=`${e}.${this.endpoint.hostname}`;let n=this.signature.sign({method:r,endpoint:s,path:encodeURI(`/${t}`),headers:{},query:{uploads:""}},{}),o=await E.asyncRequest(r,n.url,n.body||null,{...this.baseRequestParams,headers:n.headers});return this.handleError(o,"CreateMultipartUpload"),new le(t,ge(o.body).find("UploadId").text())}async uploadPart(e,t,r,s,n){let o="PUT",a=this.endpoint.copy();a.hostname=`${e}.${this.endpoint.hostname}`;let c=this.signature.sign({method:o,endpoint:a,path:encodeURI(`/${t}`),headers:{},body:n,query:{partNumber:`${s}`,uploadId:`${r}`}},{}),d=await E.asyncRequest(o,c.url,c.body||null,{...this.baseRequestParams,headers:c.headers});return this.handleError(d,"UploadPart"),new ye(s,d.headers.Etag)}async completeMultipartUpload(e,t,r,s){let n="POST",o=`<CompleteMultipartUpload>${s.map(u=>`<Part><PartNumber>${u.partNumber}</PartNumber><ETag>${u.eTag}</ETag></Part>`).join("")}</CompleteMultipartUpload>`,a=this.endpoint.copy();a.hostname=`${e}.${this.endpoint.hostname}`;let c=this.signature.sign({method:n,endpoint:a,path:encodeURI(`/${t}`),headers:{},body:o,query:{uploadId:`${r}`}},{}),d=await E.asyncRequest(n,c.url,c.body||null,{...this.baseRequestParams,headers:c.headers});this.handleError(d,"CompleteMultipartUpload")}async abortMultipartUpload(e,t,r){let s="DELETE",n=this.endpoint.copy();n.hostname=`${e}.${this.endpoint.hostname}`;let o=this.signature.sign({method:s,endpoint:n,path:encodeURI(`/${t}`),headers:{},query:{uploadId:`${r}`}},{}),a=await E.asyncRequest(s,o.url,o.body||null,{...this.baseRequestParams,headers:o.headers});this.handleError(a,"AbortMultipartUpload")}handleError(e,t){if(!super.handleError(e))return!1;let s=e.error;if(e.status==301||s&&s.startsWith("301"))throw new L("Resource not found","ResourceNotFound",t);let n=g.parseXML(e.body);switch(n.code){case"AuthorizationHeaderMalformed":throw new h(n.message,n.code);default:throw new L(n.message,n.code||"unknown",t)}}},me=class{name;creationDate;constructor(e,t){this.name=e,this.creationDate=t}},Q=class{key;lastModified;etag;size;storageClass;data;constructor(e,t,r,s,n,o){this.key=e,this.lastModified=t,this.etag=r,this.size=s,this.storageClass=n,this.data=o}},pe=class i{key;etag;crc32;crc32c;crc64nvme;sha1;sha256;checksumType;size;constructor(e,t,r){this.key=e,this.etag=t,this.crc32=r?.crc32,this.crc32c=r?.crc32c,this.crc64nvme=r?.crc64nvme,this.sha1=r?.sha1,this.sha256=r?.sha256,this.checksumType=r?.checksumType||"FULL_OBJECT",this.size=r?.size}static fromResponse(e,t){let r={};e.headers["x-amz-checksum-crc32"]&&(r.crc32=e.headers["x-amz-checksum-crc32"]),e.headers["x-amz-checksum-crc32c"]&&(r.crc32c=e.headers["x-amz-checksum-crc32c"]),e.headers["x-amz-checksum-crc64nvme"]&&(r.crc64nvme=e.headers["x-amz-checksum-crc64nvme"]),e.headers["x-amz-checksum-sha1"]&&(r.sha1=e.headers["x-amz-checksum-sha1"]),e.headers["x-amz-checksum-sha256"]&&(r.sha256=e.headers["x-amz-checksum-sha256"]),e.headers["x-amz-checksum-algorithm"]&&(r.checksumType=e.headers["x-amz-checksum-algorithm"]==="COMPOSITE"?"COMPOSITE":"FULL_OBJECT"),e.headers["x-amz-object-size"]&&(r.size=parseInt(e.headers["x-amz-object-size"]));let s=e.headers.ETag||"";return new i(t,s,r)}},le=class{key;uploadId;constructor(e,t){this.key=e,this.uploadId=t}},ye=class{partNumber;eTag;constructor(e,t){this.partNumber=e,this.eTag=t}},L=class extends g{operation;constructor(e,t,r){super(e,t),this.name="S3ServiceError",this.operation=r}};import U from"k6/http";var Se=class extends l{signature;method;commonHeaders;constructor(e){super(e,"secretsmanager"),this.signature=new p({service:this.serviceName,region:this.awsConfig.region,credentials:{accessKeyId:this.awsConfig.accessKeyId,secretAccessKey:this.awsConfig.secretAccessKey,sessionToken:this.awsConfig.sessionToken},uriEscapePath:!0,applyChecksum:!1}),this.method="POST",this.commonHeaders={"Content-Type":"application/x-amz-json-1.1"}}async listSecrets(){let e=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:`${this.serviceName}.ListSecrets`},body:JSON.stringify({})},{}),t=await U.asyncRequest(this.method,e.url,e.body,{...this.baseRequestParams,headers:e.headers});return this.handleError(t,"ListSecrets"),t.json("SecretList").map(s=>H.fromJSON(s))}async getSecret(e){let t=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:`${this.serviceName}.GetSecretValue`},body:JSON.stringify({SecretId:e})},{}),r=await U.asyncRequest(this.method,t.url,t.body,{...this.baseRequestParams,headers:t.headers});return this.handleError(r,"GetSecretValue"),H.fromJSON(r.json())}async createSecret(e,t,r,s,n){s=s??crypto.randomUUID();let o=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:`${this.serviceName}.CreateSecret`},body:JSON.stringify({Name:e,Description:r,SecretString:t,ClientRequestToken:s,Tags:n})},{}),a=await U.asyncRequest(this.method,o.url,o.body,{...this.baseRequestParams,headers:o.headers});return this.handleError(a,"CreateSecret"),H.fromJSON(a.json())}async putSecretValue(e,t,r){r=r??crypto.randomUUID();let s=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:`${this.serviceName}.PutSecretValue`},body:JSON.stringify({SecretId:e,SecretString:t,ClientRequestToken:r})},{}),n=await U.asyncRequest(this.method,s.url,s.body,{...this.baseRequestParams,headers:s.headers});return this.handleError(n,"PutSecretValue"),H.fromJSON(n.json())}async deleteSecret(e,{recoveryWindow:t=30,noRecovery:r=!1}){let s={SecretId:e};r===!0?s.ForceDeleteWithoutRecovery=!0:s.RecoveryWindowInDays=t;let n=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:`${this.serviceName}.DeleteSecret`},body:JSON.stringify(s)},{}),o=await U.asyncRequest(this.method,n.url,n.body,{...this.baseRequestParams,headers:n.headers});this.handleError(o,"DeleteSecret")}handleError(e,t){if(!super.handleError(e,t))return!1;let s=e.error_code,n=e.json();if(s>=1400&&s<=1499){let o=n.Message||n.message||n.__type;throw n.__type==="InvalidSignatureException"?new h(o,n.__type):new J(o,n.__type,t)}if(s===1500)throw new J("An error occured on the server side","InternalServiceError",t);return!0}},H=class i{name;arn;secret;createdDate;lastAccessedDate;lastChangedDate;tags;constructor(e,t,r,s,n,o,a=[]){this.name=e,this.arn=t,this.secret=r,this.createdDate=s,this.lastAccessedDate=n,this.lastChangedDate=o,this.tags=a}static fromJSON(e){return new i(e.Name,e.ARN,e.SecretString,e.CreatedDate,e.LastAccessedDate,e.LastChangedDate,e.Tags)}},J=class extends g{operation;constructor(e,t,r){super(e,t),this.name="SecretsManagerServiceError",this.operation=r}};import rt from"k6/http";var fe=class extends l{signature;method;commonHeaders;constructor(e){super(e,"ssm"),this.method="POST",this.commonHeaders={"Content-Type":"application/x-amz-json-1.1"},this.signature=new p({service:this.serviceName,region:e.region,credentials:{accessKeyId:e.accessKeyId,secretAccessKey:e.secretAccessKey,sessionToken:e.sessionToken},uriEscapePath:!0,applyChecksum:!1})}async getParameter(e,t=!1){let r=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:"AmazonSSM.GetParameter"},body:JSON.stringify({Name:e,WithDecryption:t})},{}),s=await rt.asyncRequest(this.method,r.url,r.body,{...this.baseRequestParams,headers:r.headers});return this.handleError(s,"GetParameter"),V.fromJSON(s.json())}handleError(e,t){if(!super.handleError(e,t))return!1;let s=e.error_code,n=e.json();if(s>=1400&&s<=1499){let o=n.Message||n.message||n.__type;throw n.__type==="InvalidSignatureException"?new h(o,n.__type):new G(o,n.__type,t)}if(s===1500)throw new G("An error occured on the server side","InternalServiceError",t);return!0}},V=class i{arn;dataType;lastModifiedDate;name;selector;sourceResult;type;value;version;constructor(e,t,r,s,n,o,a,c,d){this.arn=e,this.dataType=t,this.lastModifiedDate=r,this.name=s,this.selector=n,this.sourceResult=o,this.type=a,this.value=c,this.version=d}static fromJSON(e){let t=e.Parameter;return new i(t.ARN,t.DataType,t.LastModifiedDate,t.Name,t.Selector,t.SourceResult,t.Type,t.Value,t.Version)}},G=class extends g{operation;constructor(e,t,r){super(e,t),this.name="SystemsManagerServiceError",this.operation=r}};import st from"k6/http";var Z=class extends l{signature;commonHeaders;serviceVersion;constructor(e){super(e,"sqs"),this.serviceVersion="AmazonSQS",this.signature=new p({service:this.serviceName,region:this.awsConfig.region,credentials:{accessKeyId:this.awsConfig.accessKeyId,secretAccessKey:this.awsConfig.secretAccessKey,sessionToken:this.awsConfig.sessionToken},uriEscapePath:!0,applyChecksum:!0}),this.commonHeaders={"Content-Type":"application/x-amz-json-1.0"}}async deleteMessage(e,t){let r="DeleteMessage",s={QueueUrl:e,ReceiptHandle:t};await this._sendRequest(r,s)}async receiveMessages(e,t=["All"],r=["All"],s=1,n=30,o=10,a){let c="ReceiveMessage",d={MaxNumberOfMessages:s,MessageAttributeNames:t,MessageSystemAttributeNames:r,QueueUrl:e,VisibilityTimeout:n,WaitTimeSeconds:o,ReceiveRequestAttemptId:a},A=(await this._sendRequest(c,d)).json().Messages,f=[];return A?.forEach(N=>f.push(new K(N))),f}async sendMessage(e,t,r={}){let s="SendMessage",n={QueueUrl:e,...this._combineQueueMessageBodyAndOptions(t,r)},a=(await this._sendRequest(s,n)).json();return new Y(a.MessageId,a.MD5OfMessageBody)}async sendMessageBatch(e,t){let r="SendMessageBatch",s=t.map(u=>{let S=this._combineQueueMessageBodyAndOptions(u.messageBody,u.messageOptions);return S={...S,Id:u.messageId},S}),n={QueueUrl:e,Entries:s},a=(await this._sendRequest(r,n)).json(),c=a.Successful||[],d=a.Failed||[];return{successful:c.map(u=>new Y(u.MessageId,u.MD5OfMessageBody)),failed:d.map(u=>new v(u.Message,u.Code,r))}}async listQueues(e={}){let t="ListQueues",r={};typeof e?.maxResults<"u"&&(r={...r,MaxResults:e.maxResults}),typeof e?.nextToken<"u"&&(r={...r,NextToken:e.nextToken}),typeof e?.queueNamePrefix<"u"&&(r={...r,QueueNamePrefix:e.queueNamePrefix});let n=(await this._sendRequest(t,r)).json();return{urls:n.QueueUrls,nextToken:n?.NextToken}}_combineQueueMessageBodyAndOptions(e,t){let r={MessageBody:e};if(t===void 0)return r;if(typeof t.messageDeduplicationId<"u"&&(r={...r,MessageDeduplicationId:t.messageDeduplicationId}),typeof t.messageGroupId<"u"&&(r={...r,MessageGroupId:t.messageGroupId}),typeof t.messageAttributes<"u"){let s={};for(let[n,o]of Object.entries(t.messageAttributes)){let a=o.type==="Binary"?"BinaryValue":"StringValue";s[n]={DataType:o.type},s[n][a]=o.value}r={...r,MessageAttributes:s}}return typeof t.delaySeconds<"u"&&(r={...r,DelaySeconds:t.delaySeconds}),r}async _sendRequest(e,t){let r=this.signature.sign({method:"POST",endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:`${this.serviceVersion}.${e}`},body:JSON.stringify(t)},{}),s=await st.asyncRequest("POST",r.url,r.body,{...this.baseRequestParams,headers:r.headers});return this._handleError(e,s),s}_handleError(e,t){if(t.error_code===0)return;let s=t.json(),n=s.Message||s.message||s.__type;switch(s.__type){case"InvalidSignatureException":throw new h(n,s.__type);default:throw new v(n,s.__type,e)}}handleError(e,t){if(!super.handleError(e)||e.error_code===0)return!1;let n=e.json(),o=n.Message||n.message||n.__type;switch(n.__type){case"InvalidSignatureException":throw new h(o,n.__type);default:throw new v(o,n.__type,t)}}},Te=class{MessageGroupId;AWSTraceHeader;SenderId;ApproximateFirstReceiveTimestamp;ApproximateReceiveCount;SentTimestamp;SequenceNumber;MessageDeduplicationId;constructor(e){this.MessageGroupId=e?.MessageGroupId,this.AWSTraceHeader=e?.AWSTraceHeader,this.SenderId=e?.SenderId,this.ApproximateFirstReceiveTimestamp=e?.ApproximateFirstReceiveTimestamp,this.ApproximateReceiveCount=e?.ApproximateReceiveCount,this.SentTimestamp=e?.SentTimestamp,this.SequenceNumber=e?.SequenceNumber,this.MessageDeduplicationId=e?.MessageDeduplicationId}},K=class{toStringTag="ReceivedMessage";id;BodyMD5;ReceiptHandle;Body;Attributes;constructor(e){this.id=e.MessageId,this.BodyMD5=e.BodyMD5,this.ReceiptHandle=e.ReceiptHandle,this.Body=e.Body,this.Attributes=new Te(e.Attributes)}},Y=class{id;bodyMD5;constructor(e,t){this.id=e,this.bodyMD5=t}};var v=class extends g{operation;constructor(e,t,r){super(e,t),this.name="SQSServiceError",this.operation=r}};import nt from"k6/http";var Ee=class extends l{signature;commonHeaders;serviceVersion;constructor(e){super(e,"kinesis"),this.serviceVersion="Kinesis_20131202",this.signature=new p({service:this.serviceName,region:this.awsConfig.region,credentials:{accessKeyId:this.awsConfig.accessKeyId,secretAccessKey:this.awsConfig.secretAccessKey,sessionToken:this.awsConfig.sessionToken},uriEscapePath:!1,applyChecksum:!0}),this.commonHeaders={"Content-Type":"application/x-amz-json-1.1"}}async createStream(e,t={}){let r={StreamName:e,...t.shardCount&&{ShardCount:t.shardCount},...t.streamModeDetails&&{StreamMode:t.streamModeDetails.streamMode}};await this._send_request("CreateStream",r)}async deleteStream(e,t={}){let r={StreamName:e,...t.streamARN&&{StreamARN:t.streamARN},...t.enforceConsumerDeletion&&{EnforceConsumerDeletion:t.enforceConsumerDeletion}};await this._send_request("DeleteStream",r)}async listStreams(e={}){let t={...e.exclusiveStartStreamName&&{ExclusiveStartStreamName:e.exclusiveStartStreamName},...e.limit&&{Limit:e.limit},...e.nextToken&&{NextToken:e.nextToken}},r=await this._send_request("ListStreams",t);return Re.fromJson(r?.json())}async putRecords(e,t={}){if(!t.streamName&&!t.streamARN)throw new Error("Either streamName or streamARN must be provided");let r={Records:e,...t.streamName&&{StreamName:t.streamName},...t.streamARN&&{StreamARN:t.streamARN}},s=await this._send_request("PutRecords",r);return be.fromJson(s?.json())}async getRecords(e,t={}){let r={ShardIterator:e,...t.limit&&{Limit:t.limit},...t.streamARN&&{StreamARN:t.streamARN}},s=await this._send_request("GetRecords",r);return Ne.fromJson(s?.json())}async listShards(e,t={}){let r={StreamName:e,...t.nextToken&&{NextToken:t.nextToken},...t.maxResults&&{MaxResults:t.maxResults}},s=await this._send_request("ListShards",r);return xe.fromJson(s?.json())}async getShardIterator(e,t,r,s={}){let n={StreamName:e,ShardId:t,ShardIteratorType:r,...s.startingSequenceNumber&&{StartingSequenceNumber:s.startingSequenceNumber},...s.timestamp&&{Timestamp:s.timestamp}},o=await this._send_request("GetShardIterator",n);return Ie.fromJson(o?.json())}async _send_request(e,t){let r=this.signature.sign({method:"POST",endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:`${this.serviceVersion}.${e}`},body:JSON.stringify(t)},{}),s=await nt.asyncRequest("POST",r.url,r.body,{...this.baseRequestParams,headers:r.headers});return this.handleError(s,e),s}handleError(e,t){if(!super.handleError(e,t))return!1;let s=e.error_code,n=e.json();if(s>=1400&&s<=1499){let o=n.Message||n.message||n.__type;throw n.__type==="InvalidSignatureException"?new h(o,n.__type):new F(o,n.__type,t||"Unknown")}if(s===1500)throw new F("An error occured on the server side","InternalServiceError",t||"Unknown");return!0}},F=class extends g{operation;constructor(e,t,r){super(e,t),this.name="KinesisServiceError",this.operation=r}},Re=class i{hasMoreStreams;nextToken;streamNames;streamSummaries;constructor(e,t,r,s){this.hasMoreStreams=e,this.nextToken=t,this.streamNames=r,this.streamSummaries=s}static fromJson(e){let{HasMoreStreams:t=!1,NextToken:r="",StreamNames:s=[],StreamSummaries:n=[]}=e;return new i(t,r,s,n?.map(Ae.fromJson))}},Ae=class i{streamARN;streamCreationTimestamp;streamModeDetails;streamName;streamStatus;constructor(e,t,r,s,n){this.streamARN=e,this.streamCreationTimestamp=t,this.streamModeDetails=r,this.streamName=s,this.streamStatus=n}static fromJson(e){let{StreamARN:t="",StreamCreationTimestamp:r=0,StreamModeDetails:s={},StreamName:n="",StreamStatus:o=""}=e;return new i(t,r,s,n,o)}},be=class i{encryptionType;failedRecordCount;records;constructor(e,t,r){this.encryptionType=e,this.failedRecordCount=t,this.records=r}static fromJson(e){let{EncryptionType:t="NONE",FailedRecordCount:r=0,Records:s=[]}=e,n=s.map(Oe.fromJson);return new i(t,r,n)}},Oe=class i{sequenceNumber;shardId;constructor(e,t){this.sequenceNumber=e,this.shardId=t}static fromJson(e){return new i(e.SequenceNumber,e.ShardId)}},Ne=class i{nextShardIterator;records;millisBehindLatest;constructor(e,t,r){this.nextShardIterator=e,this.records=t,this.millisBehindLatest=r}static fromJson(e){let{NextShardIterator:t="",Records:r=[],MillisBehindLatest:s=0}=e,n=r.map(Pe.fromJson);return new i(t,n,s)}},Pe=class i{data;partitionKey;sequenceNumber;constructor(e,t,r){this.data=e,this.partitionKey=t,this.sequenceNumber=r}static fromJson(e){return new i(e.Data,e.PartitionKey,e.SequenceNumber)}},xe=class i{shards;nextToken;constructor(e,t){this.shards=e,this.nextToken=t}static fromJson(e){let{Shards:t=[],NextToken:r}=e,s=t.map(_e.fromJson);return new i(s,r)}},_e=class i{id;parentShardId;adjacentParentShardId;hashKeyRange;sequenceNumberRange;constructor(e,t,r,s,n){this.id=e,this.parentShardId=s,this.adjacentParentShardId=n,this.hashKeyRange=t,this.sequenceNumberRange=r}static fromJson(e){return new i(e.ShardId,e.HashKeyRange,e.SequenceNumberRange,e.ParentShardId,e.AdjacentParentShardId)}},Ie=class i{shardIterator;constructor(e){this.shardIterator=e}static fromJson(e){return new i(e.ShardIterator)}};import ot from"k6/http";var Ce=class extends l{signature;method;commonHeaders;constructor(e){super(e,"events"),this.signature=new p({service:this.serviceName,region:this.awsConfig.region,credentials:{accessKeyId:this.awsConfig.accessKeyId,secretAccessKey:this.awsConfig.secretAccessKey,sessionToken:this.awsConfig.sessionToken},uriEscapePath:!0,applyChecksum:!1}),this.method="POST",this.commonHeaders={"Content-Type":"application/x-amz-json-1.1"}}async putEvents(e){let t={...e,Entries:e.Entries.map(n=>({...n,Detail:JSON.stringify(n.Detail)}))},r=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[m]:"AWSEvents.PutEvents"},body:JSON.stringify(t)},{}),s=await ot.asyncRequest(this.method,r.url,r.body,{...this.baseRequestParams,headers:r.headers});this.handleError(s,"PutEvents")}handleError(e,t){if(!super.handleError(e,t))return!1;let s=e.error_code,n=e.json();if(s>=1400&&s<=1499){let o=n.Message||n.message||n.__type;throw n.__type==="InvalidSignatureException"?new h(o,n.__type):new X(o,n.__type,t)}if(s===1500)throw new X("An error occured on the server side","InternalServiceError",t);return!0}};var X=class extends g{operation;constructor(e,t,r){super(e,t),this.name="EventBridgeServiceError",this.operation=r}};import it from"k6/http";import at from"k6/encoding";var ee=class extends l{signature;commonHeaders;method;constructor(e){super(e,"lambda"),this.signature=new p({service:this.serviceName,region:this.awsConfig.region,credentials:{accessKeyId:this.awsConfig.accessKeyId,secretAccessKey:this.awsConfig.secretAccessKey,sessionToken:this.awsConfig.sessionToken},uriEscapePath:!0,applyChecksum:!1}),this.method="POST",this.commonHeaders={"Content-Type":"application/x-amz-json-1.1"}}async invoke(e,t,r={}){let s={},n=r.invocationType||"RequestResponse",o={...this.commonHeaders,[m]:`AWSLambda.${n}`,"X-Amz-Invocation-Type":n,"X-Amz-Log-Type":r.logType||"None"};r.clientContext&&(o["X-Amz-Client-Context"]=r.clientContext),r.qualifier&&(s.Qualifier=r.qualifier);let a=this.signature.sign({method:this.method,endpoint:this.endpoint,path:`/2015-03-31/functions/${e}/invocations`,query:s,headers:o,body:t||""},{}),c=await it.asyncRequest(this.method,a.url,a.body,{...this.baseRequestParams,headers:a.headers});this.handleError(c);let d=c.headers["X-Amz-Log-Result"],u={executedVersion:c.headers["X-Amz-Executed-Version"],logResult:d?at.b64decode(d,"std","s"):void 0,statusCode:c.status,payload:c.body},S=c.headers["X-Amz-Function-Error"];if(S)throw new B(S,u);return u}handleError(e,t){if(!super.handleError(e,t))return!1;let s=g.parse(e);switch(s.code){case"AuthorizationHeaderMalformed":case"InvalidSignatureException":throw new h(s.message,s.code);default:throw s}}},B=class extends Error{response;constructor(e,t){super(`${e}: ${t.payload}`),this.response=t}};export{D as AMZ_CONTENT_SHA256_HEADER,q as AWSConfig,g as AWSError,x as DNSError,w as Endpoint,Ce as EventBridgeClient,P as GeneralError,C as HTTP2Error,R as InvalidAWSConfigError,h as InvalidSignatureError,de as KMSClient,z as KMSDataKey,j as KMSServiceError,Ee as KinesisClient,ee as LambdaClient,B as LambdaInvocationError,T as NetworkError,K as ReceivedMessage,me as S3Bucket,he as S3Client,Q as S3Object,L as S3ServiceError,Z as SQSClient,H as Secret,Se as SecretsManagerClient,J as SecretsManagerServiceError,p as SignatureV4,fe as SystemsManagerClient,V as SystemsManagerParameter,G as SystemsManagerServiceError,_ as TCPError,I as TLSError,ae as UNSIGNED_PAYLOAD};
//# sourceMappingURL=index.js.map
