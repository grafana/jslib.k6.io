var m=class n{_protocol;_hostname;_port;static DEFAULT_PROTOCOL="https";constructor(e){let o=!e.startsWith("http://")&&!e.startsWith("https://")?`${n.DEFAULT_PROTOCOL}://${e}`:e,r=o.match(/^https?:/),s=o.replace(/^https?:\/\//,""),[i]=s.split("/");this._protocol=r?r[0].slice(0,-1):n.DEFAULT_PROTOCOL,this._hostname=i.split(":")[0],this._port=i.split(":")[1]?parseInt(i.split(":")[1]):void 0}copy(){return new n(this.href)}get host(){return this._port?`${this._hostname}:${this._port}`:this._hostname}set host(e){let[t,o]=e.split(":");this._hostname=t,this._port=o?parseInt(o):void 0}get hostname(){return this._hostname}set hostname(e){this._hostname=e}get href(){return`${this.protocol}://${this.host}`}set href(e){let t=e.match(/^https?:/),o=e.replace(/^https?:\/\//,""),[r]=o.split("/");this._protocol=t?t[0].slice(0,-1):n.DEFAULT_PROTOCOL,this._hostname=r.split(":")[0],this._port=r.split(":")[1]?parseInt(r.split(":")[1]):void 0}get port(){return this._port}set port(e){this._port=e}get protocol(){return this._protocol}set protocol(e){this._protocol=e}};var G=class n{region;accessKeyId;secretAccessKey;sessionToken;endpoint;static fromEnvironment(e){let t=__ENV.AWS_REGION,o=__ENV.AWS_ACCESS_KEY_ID,r=__ENV.AWS_SECRET_ACCESS_KEY,s=__ENV.AWS_SESSION_TOKEN,i=e?.endpoint;return new n({region:t,accessKeyId:o,secretAccessKey:r,sessionToken:s,endpoint:i})}constructor(e){if(!e.region||e.region==="")throw new T(`invalid AWS region; reason: expected a valid AWS region name (e.g. "us-east-1"), got \`${e.region}\``);if(!e.accessKeyId||e.accessKeyId==="")throw new T(`invalid AWS access key ID; reason: expected a non empty string, got \`${e.accessKeyId}\``);if(e.accessKeyId.length<16||e.accessKeyId.length>128&&e.sessionToken!=null)throw new T(`invalid AWS access key ID; reason: size should be between 16 and 128 characters, got ${e.accessKeyId.length}`);if(!e.secretAccessKey||e.secretAccessKey==="")throw new T(`invalid AWS secret access key; reason: expected a non empty string, got \`${e.secretAccessKey}\``);this.region=e.region,this.accessKeyId=e.accessKeyId,this.secretAccessKey=e.secretAccessKey,e.sessionToken!==void 0&&(this.sessionToken=e.sessionToken),e.endpoint!==void 0&&(typeof e.endpoint=="string"?this.endpoint=new m(e.endpoint):this.endpoint=e.endpoint)}},T=class extends Error{constructor(e){super(e)}};import{parseHTML as ue}from"k6/html";var f=class n extends Error{code;constructor(e,t){super(e),this.name="AWSError",this.code=t}static parseXML(e){let t=ue(e);return new n(t.find("Message").text(),t.find("Code").text())}static parse(e){if(e.headers["Content-Type"]==="application/json"){let t=e.json()||{},o=t.Message||t.message||t.__type||"An error occurred on the server side",r=e.headers["X-Amzn-Errortype"]||t.__type;return new n(o,r)}else return n.parseXML(e.body)}},h=class extends Error{code;name;constructor(e,t){super(le[t]||"An unknown error occurred"),this.name=e,this.code=t}},H=class extends h{constructor(e){super("GeneralError",e)}},P=class extends h{constructor(e){super("DNSError",e)}},D=class extends h{constructor(e){super("TCPError",e)}},b=class extends h{constructor(e){super("TLSError",e)}},I=class extends h{constructor(e){super("HTTP2Error",e)}};var le={1e3:"A generic error that isn\u2019t any of the ones listed below",1010:"A non-TCP network error - this is a placeholder and there is no error currently known to trigger it",1020:"An invalid URL was specified",1050:"The HTTP request has timed out",1100:"A generic DNS error that isn\u2019t any of the ones listed below",1101:"No IP for the provided host was found",1110:"Blacklisted IP was resolved or a connection to such was tried to be established",1111:"Blacklisted hostname using The Block Hostnames option",1200:"A generic TCP error that isn\u2019t any of the ones listed below",1201:"A \u201Cbroken pipe\u201D on write - the other side has likely closed the connection",1202:"An unknown TCP error - We got an error that we don\u2019t recognize but it is from the operating system and has errno set on it. The message in error includes the operation(write,read) and the errno, the OS, and the original message of the error",1210:"General TCP dial error",1211:"Dial timeout error - the timeout for the dial was reached",1212:"Dial connection refused - the connection was refused by the other party on dial",1213:"Dial unknown error",1220:"Reset by peer - the connection was reset by the other party, most likely a server",1300:"General TLS error",1310:"Unknown authority - the certificate issuer is unknown",1311:"The certificate doesn\u2019t match the hostname",1600:"A generic HTTP/2 error that isn\u2019t any of the ones listed below",1610:"A general HTTP/2 GoAway error"};import de from"k6/http";var w=class{awsConfig;serviceName;baseRequestParams={responseType:"text"};_endpoint;constructor(e,t){this.awsConfig=e,this.serviceName=t,e.endpoint!=null&&(this._endpoint=e.endpoint)}get endpoint(){return this._endpoint==null&&(this._endpoint=new m(`https://${this.serviceName}.${this.awsConfig.region}.amazonaws.com`)),this._endpoint}set endpoint(e){this._endpoint=e}handleError(e,t){let o=e.status,r=e.error_code,s=e.error;if(o>=200&&o<300&&s==""&&r===0)return!1;switch(r){case 1e3:case 1010:case 1020:case 1050:throw new H(r);case 1100:case 1101:case 1110:case 1111:throw new P(r);case 1200:case 1201:case 1202:case 1210:case 1211:case 1212:case 1213:case 1220:throw new D(r);case 1300:case 1310:case 1311:throw new b(r);case 1600:case 1610:throw new I(r)}return!0}};var q="X-Amz-Algorithm",J="X-Amz-Credential",U="X-Amz-Date",F="X-Amz-Expires",K="X-Amz-Signature",X="X-Amz-SignedHeaders",Ee="X-Amz-Target",L="X-Amz-Security-Token",N="x-amz-content-sha256",$=U.toLowerCase(),V=K.toLowerCase(),B=Ee.toLowerCase(),ee=L.toLowerCase(),W="authorization",Te="date",te=[W,$,Te],x="host",re={authorization:!0,"cache-control":!0,connection:!0,expect:!0,from:!0,"keep-alive":!0,"max-forwards":!0,pragma:!0,referer:!0,te:!0,trailer:!0,"transfer-encoding":!0,upgrade:!0,"user-agent":!0,"x-amzn-trace-id":!0},j="aws4_request",C="AWS4-HMAC-SHA256",ne=60*60*24*7,se="e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";var oe="UNSIGNED-PAYLOAD";import g from"k6/crypto";function ie(n,e){n=n.toLowerCase();for(let t of Object.keys(e))if(n===t.toLowerCase())return!0;return!1}function ae(n){return typeof ArrayBuffer=="function"&&(n instanceof ArrayBuffer||Object.prototype.toString.call(n)==="[object ArrayBuffer]")}var M=class{service;region;credentials;uriEscapePath;applyChecksum;constructor({service:e,region:t,credentials:o,uriEscapePath:r,applyChecksum:s}){this.service=e,this.region=t,this.credentials=o,this.uriEscapePath=typeof r=="boolean"?r:!0,this.applyChecksum=typeof s=="boolean"?s:!0}sign(e,t={}){let r={...{signingDate:new Date,unsignableHeaders:new Set,signableHeaders:new Set},...t},{longDate:s,shortDate:i}=ce(r.signingDate),a=r.signingService||this.service,d=r.signingRegion||this.region,y=`${i}/${d}/${a}/${j}`;e.headers[x]||(e.headers[x]=e.endpoint.hostname);for(let R of Object.keys(e.headers))te.indexOf(R.toLowerCase())>-1&&delete e.headers[R];e.headers[$]=s,this.credentials.sessionToken&&(e.headers[ee]=this.credentials.sessionToken),ArrayBuffer.isView(e.body)&&(e.body=e.body.buffer),e.body||(e.body="");let l=this.computePayloadHash(e);!ie(N,e.headers)&&this.applyChecksum&&(e.headers[N]=l);let E=this.computeCanonicalHeaders(e,r.unsignableHeaders,r.signableHeaders),A=this.calculateSignature(s,y,this.deriveSigningKey(this.credentials,a,d,i),this.createCanonicalRequest(e,E,l));e.headers[W]=`${C} Credential=${this.credentials.accessKeyId}/${y}, SignedHeaders=${Object.keys(E).sort().join(";")}, Signature=${A}`;let p=e.endpoint.href;return e.path&&(!p.endsWith("/")&&!e.path.startsWith("/")&&(p+="/"),p+=e.path),e.query&&(p+=`?${this.serializeQueryParameters(e.query)}`),{url:p,...e}}presign(e,t={}){let{signingDate:o=new Date,expiresIn:r=3600,unsignableHeaders:s,unhoistableHeaders:i,signableHeaders:a,signingRegion:d,signingService:y}=t,{longDate:l,shortDate:E}=ce(o),A=d||this.region,p=y||this.service;if(r>ne)throw new S("Signature version 4 presigned URLs can't be valid for more than 7 days");let R=`${E}/${A}/${p}/${j}`,c=this.moveHeadersToQuery(e,{unhoistableHeaders:i});c.headers[x]||(c.headers[x]=e.endpoint.hostname),this.credentials.sessionToken&&(c.query[L]=this.credentials.sessionToken),c.query[q]=C,c.query[J]=`${this.credentials.accessKeyId}/${R}`,c.query[U]=l,c.query[F]=r.toString(10);let z=this.computeCanonicalHeaders(c,s,a);c.query[X]=Object.keys(z).sort().join(";");let pe=this.deriveSigningKey(this.credentials,p,A,E),he=this.computePayloadHash(e),ge=this.createCanonicalRequest(c,z,he);c.query[K]=this.calculateSignature(l,R,pe,ge);let _=e.endpoint.href;return c.path&&(!_.endsWith("/")&&!c.path.startsWith("/")&&(_+="/"),_+=c.path),c.query&&(_+=`?${this.serializeQueryParameters(c.query)}`),{url:_,...c}}createCanonicalRequest(e,t,o){let r=Object.keys(t).sort(),s=r.map(a=>`${a}:${t[a]}`).join(`
`),i=r.join(";");return`${e.method}
${this.computeCanonicalURI(e)}
${this.computeCanonicalQuerystring(e)}
${s}

${i}
${o}`}createStringToSign(e,t,o){let r=g.sha256(o,"hex");return`${C}
${e}
${t}
${r}`}calculateSignature(e,t,o,r){let s=this.createStringToSign(e,t,r);return g.hmac("sha256",o,s,"hex")}deriveSigningKey(e,t,o,r){let s=e.secretAccessKey,i=g.hmac("sha256","AWS4"+s,r,"binary"),a=k(i),d=g.hmac("sha256",Z(a),o,"binary"),y=k(d),l=g.hmac("sha256",Z(y),t,"binary"),E=k(l),A=g.hmac("sha256",Z(E),"aws4_request","binary");return k(A)}computeCanonicalURI({path:e}){if(this.uriEscapePath){let t=[];for(let d of e.split("/"))d?.length!==0&&d!=="."&&(d===".."?t.pop():t.push(d));let o=e?.startsWith("/")?"/":"",r=t.join("/"),s=t.length>0&&e?.endsWith("/")?"/":"",i=`${o}${r}${s}`;return encodeURIComponent(i).replace(/%2F/g,"/")}return e}computeCanonicalQuerystring({query:e={}}){let t=[],o={};for(let r of Object.keys(e).sort()){if(r.toLowerCase()===V)continue;t.push(r);let s=e[r];typeof s=="string"?o[r]=`${u(r)}=${u(s)}`:Array.isArray(s)&&(o[r]=s.slice(0).sort().reduce((i,a)=>i.concat([`${u(r)}=${u(a)}`]),[]).join("&"))}return t.map(r=>o[r]).filter(r=>r).join("&")}computeCanonicalHeaders({headers:e},t,o){let r={};for(let s of Object.keys(e).sort()){if(e[s]==null)continue;let i=s.toLowerCase();(i in re||t?.has(i))&&(!o||o&&!o.has(i))||typeof e[s]=="string"&&(r[i]=e[s]=e[s].trim().replace(/\s+/g," "))}return r}computePayloadHash({headers:e,body:t}){return e[N]?e[N]:t==null?se:typeof t=="string"||ae(t)?g.sha256(t,"hex").toLowerCase():ArrayBuffer.isView(t)?g.sha256(t.buffer,"hex").toLowerCase():oe}moveHeadersToQuery(e,t={}){let o=JSON.parse(JSON.stringify(e)),{headers:r,query:s={}}=o;for(let i of Object.keys(r)){let a=i.toLowerCase();a.slice(0,6)==="x-amz-"&&!t.unhoistableHeaders?.has(a)&&(s[i]=r[i],delete r[i])}return{...o,headers:r,query:s}}serializeQueryParameters(e,t){let o=[],r={};for(let s of Object.keys(e).sort()){if(t?.includes(s.toLowerCase()))continue;o.push(s);let i=e[s];typeof i=="string"?r[s]=`${u(s)}=${u(i)}`:Array.isArray(i)&&(r[s]=i.slice(0).sort().reduce((a,d)=>a.concat([`${u(s)}=${u(d)}`]),[]).join("&"))}return o.map(s=>r[s]).filter(s=>s).join("&")}},S=class extends f{constructor(e,t){super(e,t),this.name="InvalidSignatureError"}};function k(n){return new Uint8Array(n)}function Z(n){return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}function u(n){let e=t=>`%${t.charCodeAt(0).toString(16).toUpperCase()}`;return encodeURIComponent(n).replace(/[!'()*]/g,e)}function ce(n){let e=ye(n).replace(/[-:]/g,"");return{longDate:e,shortDate:e.slice(0,8)}}function ye(n){return Ae(n).toISOString().replace(/\.\d{3}Z$/,"Z")}function Ae(n){return typeof n=="number"?new Date(n*1e3):typeof n=="string"?Number(n)?new Date(Number(n)*1e3):new Date(n):n}var Y=class extends w{signature;method;commonHeaders;constructor(e){super(e,"kms"),this.signature=new M({service:this.serviceName,region:e.region,credentials:{accessKeyId:e.accessKeyId,secretAccessKey:e.secretAccessKey,sessionToken:e.sessionToken},uriEscapePath:!0,applyChecksum:!1}),this.method="POST",this.commonHeaders={"Content-Type":"application/x-amz-json-1.1"}}async listKeys(){let e=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[B]:"TrentService.ListKeys"},body:JSON.stringify({})},{}),t=await de.asyncRequest(this.method,e.url,e.body,{...this.baseRequestParams,headers:e.headers});return this.handleError(t,"ListKeys"),t.json("Keys").map(r=>Q.fromJSON(r))}async generateDataKey(e,t=32){let o=this.signature.sign({method:this.method,endpoint:this.endpoint,path:"/",headers:{...this.commonHeaders,[B]:"TrentService.GenerateDataKey"},body:JSON.stringify({KeyId:e,NumberOfBytes:t})},{}),r=await de.asyncRequest(this.method,o.url,o.body,{...this.baseRequestParams,headers:o.headers});return this.handleError(r,"GenerateDataKey"),v.fromJSON(r.json())}handleError(e,t){if(!super.handleError(e,t))return!1;let r=e.error_code,s=e.json();if(r>=1400&&r<=1499){let i=s.Message||s.message||s.__type;throw s.__type==="InvalidSignatureException"?new S(i,s.__type):new O(i,s.__type,t)}if(r===1500)throw new O("An error occured on the server side","InternalServiceError",t);return!0}},Q=class n{keyArn;keyId;constructor(e,t){this.keyArn=e,this.keyId=t}static fromJSON(e){return new n(e.KeyArn,e.KeyId)}},v=class n{id;ciphertextBlob;plaintext;constructor(e,t,o){this.ciphertextBlob=e,this.id=t,this.plaintext=o}static fromJSON(e){return new n(e.CiphertextBlob,e.KeyId,e.Plaintext)}},O=class extends f{operation;constructor(e,t,o){super(e,t),this.name="KMSServiceError",this.operation=o}};export{G as AWSConfig,f as AWSError,P as DNSError,H as GeneralError,I as HTTP2Error,T as InvalidAWSConfigError,S as InvalidSignatureError,Y as KMSClient,v as KMSDataKey,O as KMSServiceError,h as NetworkError,D as TCPError,b as TLSError};
//# sourceMappingURL=kms.js.map
