{"version":3,"file":"kms.js","mappings":"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","sources":["webpack://k6-jslib-aws/webpack/bootstrap","webpack://k6-jslib-aws/webpack/runtime/compat get default export","webpack://k6-jslib-aws/webpack/runtime/define property getters","webpack://k6-jslib-aws/webpack/runtime/hasOwnProperty shorthand","webpack://k6-jslib-aws/webpack/runtime/make namespace object","webpack://k6-jslib-aws/./src/internal/config.ts","webpack://k6-jslib-aws/external commonjs \"k6/http\"","webpack://k6-jslib-aws/./src/internal/client.ts","webpack://k6-jslib-aws/./src/internal/constants.ts","webpack://k6-jslib-aws/external commonjs \"k6/html\"","webpack://k6-jslib-aws/./src/internal/error.ts","webpack://k6-jslib-aws/external commonjs \"k6/crypto\"","webpack://k6-jslib-aws/./src/internal/signature.ts","webpack://k6-jslib-aws/./src/internal/http.ts","webpack://k6-jslib-aws/./src/internal/utils.ts","webpack://k6-jslib-aws/./src/internal/kms.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { HTTPScheme } from './http'\n\n/** Class holding an AWS connection information */\nexport class AWSConfig {\n    /**\n     * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     *\n     * @type {string}\n     */\n    region: string\n\n    /**\n     * Your user's AWS access key id credential.\n     *\n     * @type {string}\n     */\n    accessKeyId: string\n\n    /**\n     * Your user's AWS secret access key credential.\n     *\n     * @type {string}\n     */\n    secretAccessKey: string\n\n    /**\n     * Your user's AWS session token credential.\n     *\n     * @type {string}\n     */\n    sessionToken?: string\n\n    /**\n     * The HTTP scheme to use when connecting to AWS.\n     *\n     * @type {HTTPScheme} ['https']\n     */\n    scheme: HTTPScheme = 'https'\n\n    // FIXME: Should really be called \"host\" instead. When used\n    // with localstack we pass a complete host (hostname:port) here.\n    /**\n     * The AWS hostname to connect to.\n     *\n     * @type {string} ['amazonaws.com']\n     */\n    endpoint: string = 'amazonaws.com'\n\n    /**\n     * Create an AWSConfig.\n     *\n     * @param {AWSConfigOptions} options - configuration attributes to use when interacting with AWS' APIs\n     * @throws {InvalidArgumentException}\n     */\n    constructor(options: AWSConfigOptions) {\n        if (options.region === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS region; reason: should be a non empty string'\n            )\n        }\n\n        if (options.accessKeyId === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS access key ID; reason: should be a non empty string'\n            )\n        }\n\n        if (options.accessKeyId.length < 16 || options.accessKeyId.length > 128) {\n            throw new InvalidAWSConfigError(\n                `invalid AWS access key ID; reason: size should be between 16 and 128 characters, got ${options.accessKeyId.length}`\n            )\n        }\n\n        if (options.secretAccessKey === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS secret access key; reason: should be a non empty string'\n            )\n        }\n\n        if (options.secretAccessKey.length < 16 || options.secretAccessKey.length > 128) {\n            throw new InvalidAWSConfigError(\n                `invalid AWS secret access key; reason: size should be between 16 and 128 characters, got ${options.secretAccessKey.length}`\n            )\n        }\n\n        this.region = options.region\n        this.accessKeyId = options.accessKeyId\n        this.secretAccessKey = options.secretAccessKey\n\n        if (options.sessionToken !== undefined) {\n            this.sessionToken = options.sessionToken\n        }\n\n        if (options.scheme !== undefined) {\n            this.scheme = options.scheme\n        }\n\n        if (options.endpoint !== undefined) {\n            this.endpoint = options.endpoint\n        }\n    }\n}\n\n/**\n * Interface representing AWSConfig options\n */\nexport interface AWSConfigOptions {\n    /**\n     * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     *\n     * @type {string}\n     */\n    region: string\n\n    /**\n     * Your user's AWS access key id credential.\n     *\n     * @type {string}\n     */\n    accessKeyId: string\n\n    /**\n     * Your user's AWS secret access key credential.\n     *\n     * @type {string}\n     */\n    secretAccessKey: string\n\n    /**\n     * Your user's AWS session token credential.\n     *\n     * @type {string}\n     */\n    sessionToken?: string\n\n    /**\n     * The HTTP scheme to use when connecting to AWS.\n     *\n     * @type {HTTPScheme}\n     */\n    scheme?: HTTPScheme\n\n    /**\n     * The AWS hostname to connect to.\n     *\n     * @type {string}\n     */\n    endpoint?: string\n}\n\n/** Class representing an invalid AWS configuration */\nexport class InvalidAWSConfigError extends Error {\n    constructor(message: string) {\n        super(message)\n    }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/http\");","import { AWSConfig } from './config'\nimport { HTTPHeaders } from './http'\n\n/**\n * Class allowing to build requests targeting AWS APIs\n *\n * This class is meant to be used as a base class for specific\n * services clients. See S3Client or SecretsManagerClient for\n * usage examples.\n */\nexport class AWSClient {\n    awsConfig: AWSConfig\n    serviceName: string\n\n    private _host?: string\n\n    /**\n     * @param {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     * @param  {string} serviceName - name of the service to target.\n     * @param  {URIEncodingConfig} URIencodingConfig - configures how requests URIs should be encoded.\n     */\n    constructor(awsConfig: AWSConfig, serviceName: string) {\n        this.awsConfig = awsConfig\n        this.serviceName = serviceName\n    }\n\n    /**\n     * Property computing the URL to send the requests to when interacting with\n     * the specific AWS service the child class implements the functionalities of.\n     */\n    public get host() {\n        if (this._host == undefined) {\n            return `${this.serviceName}.${this.awsConfig.region}.${this.awsConfig.endpoint}`\n        }\n        return this._host\n    }\n\n    public set host(host: string) {\n        this._host = host\n    }\n}\n\n/**\n * Type alias representing the result of an AWSClient.buildRequest call\n */\nexport interface AWSRequest {\n    url: string\n    headers: HTTPHeaders\n}\n","/**\n * Standard Amazon AWS query parameter names\n */\nexport const AMZ_ALGORITHM_QUERY_PARAM = 'X-Amz-Algorithm'\nexport const AMZ_CREDENTIAL_QUERY_PARAM = 'X-Amz-Credential'\nexport const AMZ_DATE_QUERY_PARAM = 'X-Amz-Date'\nexport const AMZ_EXPIRES_QUERY_PARAM = 'X-Amz-Expires'\nexport const AMZ_SIGNATURE_QUERY_PARAM = 'X-Amz-Signature'\nexport const AMZ_SIGNED_HEADERS_QUERY_PARAM = 'X-Amz-SignedHeaders'\nexport const AMZ_TARGET_QUERY_PARAM = 'X-Amz-Target'\nexport const AMZ_TOKEN_QUERY_PARAM = 'X-Amz-Security-Token'\n\n/**\n * Standard Amazon AWS header names\n */\nexport const AMZ_CONTENT_SHA256_HEADER = 'x-amz-content-sha256'\nexport const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase()\nexport const AMZ_SIGNATURE_HEADER = AMZ_SIGNATURE_QUERY_PARAM.toLowerCase()\nexport const AMZ_TARGET_HEADER = AMZ_TARGET_QUERY_PARAM.toLowerCase()\nexport const AMZ_TOKEN_HEADER = AMZ_TOKEN_QUERY_PARAM.toLowerCase()\n\n/**\n * Common HTTP headers we rely on in the signing process\n */\nexport const AUTHORIZATION_HEADER = 'authorization'\nexport const DATE_HEADER = 'date'\n\n/**\n * Lists the headers that are generated as part of the signature process.\n */\nexport const GENERATED_HEADERS = [AUTHORIZATION_HEADER, AMZ_DATE_HEADER, DATE_HEADER]\nexport const HOST_HEADER = 'host'\n\n/**\n * Lists the headers that should never be included in the\n * request signature signature process.\n */\nexport const ALWAYS_UNSIGNABLE_HEADERS = {\n    authorization: true,\n    'cache-control': true,\n    connection: true,\n    expect: true,\n    from: true,\n    'keep-alive': true,\n    'max-forwards': true,\n    pragma: true,\n    referer: true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n    'user-agent': true,\n    'x-amzn-trace-id': true,\n}\n\n/**\n * Signature specific constants included in the signing process\n */\nexport const KEY_TYPE_IDENTIFIER = 'aws4_request'\nexport const SIGNING_ALGORITHM_IDENTIFIER = 'AWS4-HMAC-SHA256'\n\n/**\n * Maximum time to live of a signed request in seconds: 7 days.\n */\nexport const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7\n\n/**\n * SHA256 hash of an empty string (so we don't waste cycles recomputing it)\n */\nexport const EMPTY_SHA256 = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n\n/**\n * SHA256 hash of the unsigned payload constant (so we don't waste cycles recomputing it)\n */\nexport const UNSIGNED_PAYLOAD_SHA256 =\n    '5a41b0751e4537c6ff868564ab44a4d4ecceec2ec5b1c5f74d97422968e04237'\n\nexport const UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD'\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/html\");","import { parseHTML } from 'k6/html'\n\n/**\n * Base class to derive errors from\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class AWSError extends Error {\n    /**\n     * Error code issued by the service (if any)\n     */\n    code?: string\n\n    /**\n     * Create an AWSError\n     *\n     * @param {string} message - A longer human readable error message.\n     * @param {string?} code - A unique short code representing the error that was emitted\n     */\n    constructor(message: string, code?: string) {\n        super(message)\n        this.name = 'AWSError'\n        this.code = code\n    }\n\n    /**\n     * Parse an AWSError from an XML document\n     *\n     * @param  {string} xmlDocument - Serialized XML document to parse the error from\n     */\n    static parseXML(xmlDocument: string): AWSError {\n        const doc = parseHTML(xmlDocument)\n        return new AWSError(doc.find('Message').text(), doc.find('Code').text())\n    }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/crypto\");","import crypto from 'k6/crypto'\n\nimport * as constants from './constants'\nimport { AWSError } from './error'\nimport { hasHeader, HTTPHeaderBag, HTTPRequest, QueryParameterBag, SignedHTTPRequest } from './http'\nimport { isArrayBuffer } from './utils'\n\n/**\n * SignatureV4 can be used to sign HTTP requests and presign URLs using the AWS Signature\n * Version 4 signing process.\n *\n * It offers two signing methods:\n * - sign: signs the request headers and payload\n * - presign: returns a presigned (authorization information contained in the query string) URL\n *\n * @see https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */\nexport class SignatureV4 {\n    /**\n     * The name of the service to sign for.\n     */\n    private readonly service: string\n\n    /**\n     * The name of the region to sign for.\n     */\n    private readonly region: string\n\n    /**\n     * The credentials with which the request should be signed.\n     */\n    private readonly credentials: Credentials\n\n    /**\n     * Whether to uri-escape the request URI path as part of computing the\n     * canonical request string. This is required for every AWS service, except\n     * Amazon S3, as of late 2017.\n     *\n     * @default [true]\n     */\n    private readonly uriEscapePath: boolean\n\n    /**\n     * Whether to calculate a checksum of the request body and include it as\n     * either a request header (when signing) or as a query string parameter\n     * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n     * every other AWS service as of late 2017.\n     *\n     * @default [true]\n     */\n    private readonly applyChecksum: boolean\n\n    // TODO: uriEscapePath and applyChecksum should not be present in the constructor\n    constructor({\n        service,\n        region,\n        credentials,\n        uriEscapePath,\n        applyChecksum,\n    }: SignatureV4Options) {\n        this.service = service\n        this.region = region\n        this.credentials = credentials\n        this.uriEscapePath = typeof uriEscapePath === 'boolean' ? uriEscapePath : true\n        this.applyChecksum = typeof applyChecksum === 'boolean' ? applyChecksum : true\n    }\n\n    /**\n     * Includes AWS v4 signing information to the provided HTTP request.\n     *\n     * This method adds an Authorization header to the request, containing\n     * the signature and other signing information. It also returns a preformatted\n     * URL that can be used to make the k6 http request.\n     *\n     * This method mutates the request object.\n     *\n     * @param request {HTTPRequest} The request to sign.\n     * @param param1 {SignOptions} Options for signing the request.\n     * @returns {SignedHTTPRequest} The signed request.\n     */\n    sign(\n        request: HTTPRequest,\n        {\n            signingDate = new Date(),\n            signingService,\n            signingRegion,\n            unsignableHeaders = new Set<string>(),\n            signableHeaders = new Set<string>(),\n        }: RequestSigningOptions\n    ): SignedHTTPRequest {\n        const { longDate, shortDate }: DateInfo = formatDate(signingDate)\n        const service = signingService || this.service\n        const region = signingRegion || this.region\n        const scope = `${shortDate}/${region}/${service}/${constants.KEY_TYPE_IDENTIFIER}`\n\n        // Required by the specification:\n        //   \"For HTTP/1.1 requests, you must include the host header at a minimum.\n        //   Standard headers like content-type are optional.\n        //   For HTTP/2 requests, you must include the :authority header instead of\n        //   the host header. Different services might require other headers.\"\n        request.headers[constants.HOST_HEADER] = request.hostname\n\n        // Filter out headers that will be generated and managed by the signing process.\n        // If the user provide any of those as part of the HTTPRequest's headers, they\n        // will be ignored.\n        for (const headerName of Object.keys(request.headers)) {\n            if (constants.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {\n                delete request.headers[headerName]\n            }\n        }\n\n        request.headers[constants.AMZ_DATE_HEADER] = longDate\n        if (this.credentials.sessionToken) {\n            request.headers[constants.AMZ_TOKEN_HEADER] = this.credentials.sessionToken\n        }\n\n        // If the request body is a typed array, we need to convert it to a buffer\n        // so that we can calculate the checksum.\n        if (ArrayBuffer.isView(request.body)) {\n            request.body = request.body.buffer\n        }\n\n        // Ensure we avoid passing undefined to the crypto hash function.\n        if (!request.body) {\n            request.body = ''\n        }\n\n        let payloadHash = constants.EMPTY_SHA256\n        if (this.applyChecksum) {\n            if (!hasHeader(constants.AMZ_CONTENT_SHA256_HEADER, request.headers)) {\n                payloadHash = crypto.sha256(request.body, 'hex').toLowerCase()\n                request.headers[constants.AMZ_CONTENT_SHA256_HEADER] = payloadHash\n            } else if (\n                request.headers[constants.AMZ_CONTENT_SHA256_HEADER] === constants.UNSIGNED_PAYLOAD\n            ) {\n                payloadHash = constants.UNSIGNED_PAYLOAD\n            }\n        }\n\n        const canonicalHeaders = this.computeCanonicalHeaders(\n            request,\n            unsignableHeaders,\n            signableHeaders\n        )\n        const canonicalRequest = this.createCanonicalRequest(request, canonicalHeaders, payloadHash)\n        const signingKey = this.deriveSigningKey(this.credentials, service, region, shortDate)\n        const signature = this.calculateSignature(longDate, scope, signingKey, canonicalRequest)\n\n        /**\n         * Step 4 of the signing process: add the signature to the HTTP request's headers.\n         *\n         * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n         */\n        request.headers[constants.AUTHORIZATION_HEADER] =\n            `${constants.SIGNING_ALGORITHM_IDENTIFIER} ` +\n            `Credential=${this.credentials.accessKeyId}/${scope}, ` +\n            `SignedHeaders=${Object.keys(canonicalHeaders).sort().join(';')}, ` +\n            `Signature=${signature}`\n\n        // If a request path was provided, add it to the URL\n        let url = `${request.protocol}://${request.hostname}`\n        if (request.path) {\n            url += request.path\n        }\n\n        // If a request query string was provided, add it to the URL\n        if (request.query) {\n            // We exclude the signature from the query string\n            url += `?${this.serializeQueryParameters(request.query)}`\n        }\n\n        return {\n            url: url,\n            ...request,\n        }\n    }\n\n    /**\n     * Produces a presigned URL with AWS v4 signature information for the provided HTTP request.\n     *\n     * A presigned URL is a URL that contains the authorization information\n     * (signature and other signing information) in the query string. This method\n     * returns a preformatted URL that can be used to make the k6 http request.\n     *\n     * @param originalRequest - The original request to presign.\n     * @param options - Options controlling the signing of the request.\n     * @returns A signed request, including the presigned URL.\n     */\n    presign(originalRequest: HTTPRequest, options: PresignOptions = {}): SignedHTTPRequest {\n        const {\n            signingDate = new Date(),\n            expiresIn = 3600,\n            unsignableHeaders,\n            unhoistableHeaders,\n            signableHeaders,\n            signingRegion,\n            signingService,\n        } = options\n        const { longDate, shortDate }: DateInfo = formatDate(signingDate)\n        const region = signingRegion || this.region\n        const service = signingService || this.service\n\n        if (expiresIn > constants.MAX_PRESIGNED_TTL) {\n            throw new InvalidSignatureError(\n                \"Signature version 4 presigned URLs can't be valid for more than 7 days\"\n            )\n        }\n\n        const scope = `${shortDate}/${region}/${service}/${constants.KEY_TYPE_IDENTIFIER}`\n        const request = this.moveHeadersToQuery(originalRequest, { unhoistableHeaders })\n\n        // Required by the specification:\n        //   \"For HTTP/1.1 requests, you must include the host header at a minimum.\n        //   Standard headers like content-type are optional.\n        //   For HTTP/2 requests, you must include the :authority header instead of\n        //   the host header. Different services might require other headers.\"\n        request.headers[constants.HOST_HEADER] = originalRequest.hostname\n\n        // If the user provided a session token, include it in the signed url query string.\n        if (this.credentials.sessionToken) {\n            request.query[constants.AMZ_TOKEN_QUERY_PARAM] = this.credentials.sessionToken\n        }\n\n        // Add base signing query parameters to the request, as described in the documentation\n        // @see https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n        request.query[constants.AMZ_ALGORITHM_QUERY_PARAM] = constants.SIGNING_ALGORITHM_IDENTIFIER\n        request.query[\n            constants.AMZ_CREDENTIAL_QUERY_PARAM\n        ] = `${this.credentials.accessKeyId}/${scope}`\n        request.query[constants.AMZ_DATE_QUERY_PARAM] = longDate\n        request.query[constants.AMZ_EXPIRES_QUERY_PARAM] = expiresIn.toString(10)\n\n        const canonicalHeaders = this.computeCanonicalHeaders(\n            request,\n            unsignableHeaders,\n            signableHeaders\n        )\n        request.query[constants.AMZ_SIGNED_HEADERS_QUERY_PARAM] = Object.keys(canonicalHeaders)\n            .sort()\n            .join(';')\n\n        const signingKey = this.deriveSigningKey(this.credentials, service, region, shortDate)\n\n        // Computing the payload from the original request. This is required\n        // in the event the user attempts to produce a presigned URL for s3,\n        // which requires the payload hash to be 'UNSIGNED-PAYLOAD'.\n        //\n        // To that effect, users need to set the 'x-amz-content-sha256' header,\n        // and mark it as unhoistable and unsignable. When setup this way,\n        // the computePayloadHash method will then return the string 'UNSIGNED-PAYLOAD'.\n        const payloadHash = this.computePayloadHash(originalRequest)\n        const canonicalRequest = this.createCanonicalRequest(request, canonicalHeaders, payloadHash)\n\n        request.query[constants.AMZ_SIGNATURE_QUERY_PARAM] = this.calculateSignature(\n            longDate,\n            scope,\n            signingKey,\n            canonicalRequest\n        )\n\n        // If a request path was provided, add it to the URL\n        let url = `${request.protocol}://${request.hostname}`\n        if (request.path) {\n            url += request.path\n        }\n\n        // If a request query string was provided, add it to the URL\n        if (request.query) {\n            url += `?${this.serializeQueryParameters(request.query)}`\n        }\n\n        return { url: url, ...request }\n    }\n\n    /**\n     * Create a string including information from your request\n     * in a AWS signature v4 standardized (canonical) format.\n     *\n     * Step 1 of the signing process: create the canonical request string.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n     *\n     * @param request {HTTPRequest} The request to sign.\n     * @param canonicalHeaders {HTTPHeaderBag} The request's canonical headers.\n     * @param payloadHash {string} The hexadecimally encoded request's payload hash .\n     * @returns {string} The canonical request string.\n     */\n    private createCanonicalRequest(\n        request: HTTPRequest,\n        canonicalHeaders: HTTPHeaderBag,\n        payloadHash: string\n    ): string {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort()\n        const sortedCanonicalHeaders = sortedHeaders\n            .map((name) => `${name}:${canonicalHeaders[name]}`)\n            .join('\\n')\n        const signedHeaders = sortedHeaders.join(';')\n\n        return (\n            `${request.method}\\n` +\n            `${this.computeCanonicalURI(request)}\\n` +\n            `${this.computeCanonicalQuerystring(request)}\\n` +\n            `${sortedCanonicalHeaders}\\n\\n` +\n            `${signedHeaders}\\n` +\n            `${payloadHash}`\n        )\n    }\n\n    /**\n     * Create the \"string to sign\" part of the signature Version 4 protocol.\n     *\n     * The \"string to sign\" includes meta information about your request and\n     * about the canonical request that you created with `createCanonicalRequest`.\n     * It is used hand in hand with the signing key to create the request signature.\n     * Step 2 of the signing process: create the string to sign.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n     *\n     * @param longDate {string} The request's date in iso 8601 format.\n     * @param credentialScope {string} The request's credential scope.\n     * @param canonicalRequest {string} The request's canonical request.\n     * @returns {string} The \"string to sign\".\n     */\n    private createStringToSign(\n        longDate: string,\n        credentialScope: string,\n        canonicalRequest: string\n    ): string {\n        const hashedCanonicalRequest = crypto.sha256(canonicalRequest, 'hex')\n\n        return (\n            `${constants.SIGNING_ALGORITHM_IDENTIFIER}\\n` +\n            `${longDate}\\n` +\n            `${credentialScope}\\n` +\n            `${hashedCanonicalRequest}`\n        )\n    }\n\n    /**\n     * Calculte the signature for AWS signature version 4.\n     *\n     * Step 3 of the signing process: create the signature.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n     *\n     * @param longDate {string} The request's date in iso 8601 format.\n     * @param credentialScope {string} The request's credential scope.\n     * @param signingKey {string} the signing key as computed by the deriveSigningKey method.\n     * @param canonicalRequest {string} The request's canonical request.\n     * @returns {string} The signature.\n     */\n    private calculateSignature(\n        longDate: string,\n        credentialScope: string,\n        signingKey: Uint8Array,\n        canonicalRequest: string\n    ): string {\n        const stringToSign = this.createStringToSign(longDate, credentialScope, canonicalRequest)\n        return crypto.hmac('sha256', signingKey, stringToSign, 'hex')\n    }\n\n    /**\n     * Derives the signing key for authenticating requests signed with\n     * the Signature version 4 authentication protocol.\n     *\n     * deriveSigningKey produces a signing key by creating a series of\n     * hash-based message authentication codes (HMACs) represented in\n     * a binary format.\n     *\n     * The derived signing key is specific to the date it's made at, as well as\n     * the service and region it targets.\n     *\n     * @param credentials {AWSCredentials} The credentials to use for signing.\n     * @param service {string} The service the request is targeted at.\n     * @param region {string} The region the request is targeted at.\n     * @param shortDate {string} The request's date in YYYYMMDD format.\n     * @returns {Uint8Array} The derived signing key.\n     */\n    private deriveSigningKey(\n        credentials: Credentials,\n        service: string,\n        region: string,\n        shortDate: string\n    ): Uint8Array {\n        const kSecret = credentials.secretAccessKey\n        const kDate: any = crypto.hmac('sha256', 'AWS4' + kSecret, shortDate, 'binary')\n        const kRegion: any = crypto.hmac('sha256', kDate, region, 'binary')\n        const kService: any = crypto.hmac('sha256', kRegion, service, 'binary')\n        const kSigning: any = crypto.hmac('sha256', kService, 'aws4_request', 'binary')\n\n        return kSigning\n    }\n\n    /**\n     * Create a string that includes information from your request\n     * in a AWS signature v4 standardized (canonical) format.\n     *\n     * @param param0 {HTTPRequest} The request to sign.\n     * @returns {string} The canonical URI.\n     */\n    private computeCanonicalURI({ path }: HTTPRequest): string {\n        if (!this.uriEscapePath) {\n            // If the path is not uri-escaped, as in S3, then there's no need to\n            // double encode it nor normalize it.\n            return path\n        }\n\n        const normalizedURISegments = []\n\n        for (const URISegment of path.split('/')) {\n            if (URISegment?.length == 0) {\n                continue\n            }\n\n            if (URISegment === '.') {\n                continue\n            }\n\n            if (URISegment === '..') {\n                normalizedURISegments.pop()\n            } else {\n                normalizedURISegments.push(URISegment)\n            }\n        }\n\n        // Normalize and double encode the URI\n        const leading = path?.startsWith('/') ? '/' : ''\n        const URI = normalizedURISegments.join('/')\n        const trailing = normalizedURISegments.length > 0 && path?.endsWith('/') ? '/' : ''\n        const normalizedURI = `${leading}${URI}${trailing}`\n\n        const doubleEncoded = encodeURIComponent(normalizedURI)\n\n        return doubleEncoded.replace(/%2F/g, '/')\n    }\n\n    /**\n     * Serializes the request's query parameters into their canonical\n     * string version. If the request does not include a query parameters,\n     * returns an empty string.\n     *\n     * @param param0 {HTTPRequest} The request containing the query parameters.\n     * @returns {string} The canonical query string.\n     */\n    private computeCanonicalQuerystring({ query = {} }: HTTPRequest): string {\n        const keys: Array<string> = []\n        const serialized: Record<string, string> = {}\n\n        for (const key of Object.keys(query).sort()) {\n            if (key.toLowerCase() === constants.AMZ_SIGNATURE_HEADER) {\n                continue\n            }\n\n            keys.push(key)\n            const value = query[key]\n\n            if (typeof value === 'string') {\n                serialized[key] = `${escapeURI(key)}=${escapeURI(value)}`\n            } else if (Array.isArray(value)) {\n                serialized[key] = value\n                    .slice(0)\n                    .sort()\n                    .reduce(\n                        (encoded: Array<string>, value: string) =>\n                            encoded.concat([`${escapeURI(key)}=${escapeURI(value)}`]),\n                        []\n                    )\n                    .join('&')\n            }\n        }\n\n        return keys\n            .map((key) => serialized[key])\n            .filter((serialized) => serialized)\n            .join('&')\n    }\n\n    /**\n     * Create the canonical form of the request's headers.\n     * Canonical headers consist of all the HTTP headers you\n     * are including with the signed request.\n     *\n     * @param param0 {HTTPRequest} The request to compute the canonical headers of.\n     * @param unsignableHeaders {Set<string>} The headers that should not be signed.\n     * @param signableHeaders {Set<string>} The headers that should be signed.\n     * @returns {string} The canonical headers.\n     */\n    private computeCanonicalHeaders(\n        { headers }: HTTPRequest,\n        unsignableHeaders?: Set<string>,\n        signableHeaders?: Set<string>\n    ): HTTPHeaderBag {\n        const canonicalHeaders: HTTPHeaderBag = {}\n\n        for (const headerName of Object.keys(headers).sort()) {\n            if (headers[headerName] == undefined) {\n                continue\n            }\n\n            const canonicalHeaderName = headerName.toLowerCase()\n            if (\n                canonicalHeaderName in constants.ALWAYS_UNSIGNABLE_HEADERS ||\n                unsignableHeaders?.has(canonicalHeaderName)\n            ) {\n                if (\n                    !signableHeaders ||\n                    (signableHeaders && !signableHeaders.has(canonicalHeaderName))\n                ) {\n                    continue\n                }\n            }\n\n            canonicalHeaders[canonicalHeaderName] = headers[headerName].trim().replace(/\\s+/g, ' ')\n        }\n\n        return canonicalHeaders\n    }\n\n    /**\n     * Computes the SHA256 cryptographic hash of the request's body.\n     *\n     * If the headers contain the 'X-Amz-Content-Sha256' header, then\n     * the value of that header is returned instead. This proves useful\n     * when, for example, presiging a URL for S3, as the payload hash\n     * must always be equal to 'UNSIGNED-PAYLOAD'.\n     *\n     * @param param0 {HTTPRequest} The request to compute the payload hash of.\n     * @returns {string} The hex encoded SHA256 payload hash, or the value of the 'X-Amz-Content-Sha256' header.\n     */\n    private computePayloadHash({ headers, body }: HTTPRequest): string {\n        for (const headerName of Object.keys(headers)) {\n            // If the header is present, return its value.\n            // So that we let the 'UNSIGNED-PAYLOAD' value pass through.\n            if (headerName.toLowerCase() === constants.AMZ_CONTENT_SHA256_HEADER) {\n                return headers[headerName]\n            }\n        }\n\n        if (body == undefined) {\n            return constants.EMPTY_SHA256\n        }\n\n        if (typeof body === 'string' || isArrayBuffer(body)) {\n            return crypto.sha256(body, 'hex').toLowerCase()\n        }\n\n        if (ArrayBuffer.isView(body)) {\n            // If the request body is a typed array, we need to convert it to a buffer\n            // so that we can calculate the checksum.\n            return crypto.sha256((body as DataView).buffer, 'hex').toLowerCase()\n        }\n\n        return constants.UNSIGNED_PAYLOAD\n    }\n\n    /**\n     * Moves a request's headers to its query parameters.\n     *\n     * The operation will ignore any amazon standard headers, prefixed\n     * with 'X-Amz-'. It will also ignore any headers specified as unhoistable\n     * by the options.\n     *\n     * The operation will delete the headers from the request.\n     *\n     * @param request {HTTPRequest} The request to move the headers from.\n     * @param options\n     * @returns {HTTPRequest} The request with the headers moved to the query parameters.\n     */\n    private moveHeadersToQuery(\n        request: HTTPRequest,\n        options: { unhoistableHeaders?: Set<string> } = {}\n    ): HTTPRequest & { query: QueryParameterBag } {\n        const requestCopy = JSON.parse(JSON.stringify(request))\n        const { headers, query = {} as QueryParameterBag } = requestCopy\n\n        for (const name of Object.keys(headers)) {\n            const lowerCaseName = name.toLowerCase()\n            if (\n                lowerCaseName.slice(0, 6) === 'x-amz-' &&\n                !options.unhoistableHeaders?.has(lowerCaseName)\n            ) {\n                query[name] = headers[name]\n                delete headers[name]\n            }\n        }\n\n        return {\n            ...requestCopy,\n            headers,\n            query,\n        }\n    }\n\n    /**\n     * Serializes a HTTPRequest's query parameter bag into a string.\n     *\n     * @param query {QueryParameterBag} The query parameters to serialize.\n     * @param ignoreKeys {Set<string>} The keys to ignore.\n     * @returns {string} The serialized, and ready to use in a URL, query parameters.\n     */\n    private serializeQueryParameters(query: QueryParameterBag, ignoreKeys?: string[]): string {\n        const keys: Array<string> = []\n        const serialized: Record<string, string> = {}\n\n        for (const key of Object.keys(query).sort()) {\n            if (ignoreKeys?.includes(key.toLowerCase())) {\n                continue\n            }\n\n            keys.push(key)\n            const value = query[key]\n\n            if (typeof value === 'string') {\n                serialized[key] = `${escapeURI(key)}=${escapeURI(value)}`\n            } else if (Array.isArray(value)) {\n                serialized[key] = value\n                    .slice(0)\n                    .sort()\n                    .reduce(\n                        (encoded: Array<string>, value: string) =>\n                            encoded.concat([`${escapeURI(key)}=${escapeURI(value)}`]),\n                        []\n                    )\n                    .join('&')\n            }\n        }\n\n        return keys\n            .map((key) => serialized[key])\n            .filter((serialized) => serialized)\n            .join('&')\n    }\n}\n\n/**\n * Error indicating an Invalid signature has been sent to AWS services\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class InvalidSignatureError extends AWSError {\n    /**\n     * Constructs an InvalidSignatureError\n     *\n     * @param  {string} message - human readable error message\n     */\n    constructor(message: string, code?: string) {\n        super(message, code)\n        this.name = 'InvalidSignatureError'\n    }\n}\n\nexport interface SignatureV4Options {\n    /**\n     * The name of the service to sign for.\n     */\n    service: string\n\n    /**\n     * The name of the region to sign for.\n     */\n    region: string\n\n    /**\n     * The credentials with which the request should be signed.\n     */\n    credentials: Credentials\n\n    /**\n     * Whether to uri-escape the request URI path as part of computing the\n     * canonical request string. This is required for every AWS service, except\n     * Amazon S3, as of late 2017.\n     *\n     * @default [true]\n     */\n    uriEscapePath?: boolean\n\n    /**\n     * Whether to calculate a checksum of the request body and include it as\n     * either a request header (when signing) or as a query string parameter\n     * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n     * every other AWS service as of late 2017.\n     *\n     * @default [true]\n     */\n    applyChecksum?: boolean\n}\n\nexport interface SignOptions {\n    /**\n     * The date and time to be used as signature metadata. This value should be\n     * a Date object, a unix (epoch) timestamp, or a string that can be\n     * understood by the JavaScript `Date` constructor.If not supplied, the\n     * value returned by `new Date()` will be used.\n     */\n    signingDate?: Date\n\n    /**\n     * The service signing name. It will override the service name of the signer\n     * in current invocation\n     */\n    signingService?: string\n\n    /**\n     * The region name to sign the request. It will override the signing region of the\n     * signer in current invocation\n     */\n    signingRegion?: string\n}\n\nexport interface RequestSigningOptions extends SignOptions {\n    /**\n     * A set of strings whose members represents headers that cannot be signed.\n     * All headers in the provided request will have their names converted to\n     * lower case and then checked for existence in the unsignableHeaders set.\n     */\n    unsignableHeaders?: Set<string>\n\n    /**\n     * A set of strings whose members represents headers that should be signed.\n     * Any values passed here will override those provided via unsignableHeaders,\n     * allowing them to be signed.\n     *\n     * All headers in the provided request will have their names converted to\n     * lower case before signing.\n     */\n    signableHeaders?: Set<string>\n}\n\nexport interface PresignOptions extends RequestSigningOptions {\n    /**\n     * The number of seconds before the presigned URL expires\n     */\n    expiresIn?: number\n\n    /**\n     * A set of strings whose representing headers that should not be hoisted\n     * to presigned request's query string. If not supplied, the presigner\n     * moves all the AWS-specific headers (starting with `x-amz-`) to the request\n     * query string. If supplied, these headers remain in the presigned request's\n     * header.\n     * All headers in the provided request will have their names converted to\n     * lower case and then checked for existence in the unhoistableHeaders set.\n     */\n    unhoistableHeaders?: Set<string>\n}\n\nexport interface Credentials {\n    /**\n     * AWS access key ID\n     */\n    readonly accessKeyId: string\n\n    /**\n     * AWS secret access key\n     */\n    readonly secretAccessKey: string\n\n    /**\n     * A security or session token to use with these credentials. Usually\n     * present for temporary credentials.\n     */\n    readonly sessionToken?: string\n}\n\nexport interface DateInfo {\n    /**\n     * ISO8601 formatted date string\n     */\n    longDate: string\n\n    /**\n     * String in the format YYYYMMDD\n     */\n    shortDate: string\n}\n\n/**\n * Escapes a URI following the AWS signature v4 escaping rules.\n *\n * @param URI {string} The URI to escape.\n * @returns {string} The escaped URI.\n */\nfunction escapeURI(URI: string): string {\n    const hexEncode = (c: string): string => {\n        return `%${c.charCodeAt(0).toString(16).toUpperCase()}`\n    }\n\n    return encodeURIComponent(URI).replace(/[!'()*]/g, hexEncode)\n}\n\n/**\n * formatDate formats a Date object into a ISO8601 formatted date string\n * and a string in the format YYYYMMDD.\n *\n * @param date {Date} The date to format.\n * @returns {DateInfo} The formatted date.\n */\nfunction formatDate(date: Date): DateInfo {\n    const longDate = iso8601(date).replace(/[\\-:]/g, '')\n    return {\n        longDate,\n        shortDate: longDate.slice(0, 8),\n    }\n}\n\n/**\n * Formats a time into an ISO 8601 string.\n *\n * @see https://en.wikipedia.org/wiki/ISO_8601\n *\n * @param time {number | string | Date} The time to format.\n * @returns {string} The ISO 8601 formatted time.\n */\nfunction iso8601(time: number | string | Date): string {\n    return toDate(time)\n        .toISOString()\n        .replace(/\\.\\d{3}Z$/, 'Z')\n}\n\n/**\n * Converts a time value into a Date object.\n *\n * @param time {number | string | Date} The time to convert.\n * @returns {Date} The resulting Date object.\n */\nfunction toDate(time: number | string | Date): Date {\n    if (typeof time === 'number') {\n        return new Date(time * 1000)\n    }\n\n    if (typeof time === 'string') {\n        if (Number(time)) {\n            return new Date(Number(time) * 1000)\n        }\n\n        return new Date(time)\n    }\n\n    return time\n}\n","/**\n * Type representing HTTP schemes\n */\nexport type HTTPScheme = 'http' | 'https'\n\n/**\n * Type representing HTTP Methods\n *\n */\nexport type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\n/**\n * Type alias representing HTTP Headers\n */\nexport type HTTPHeaders = { [key: string]: string }\n\n/**\n * HTTPHeaderBag is a type alias representing HTTP Headers\n */\nexport type HTTPHeaderBag = Record<string, string>\n\nexport function hasHeader(soughtHeader: string, headers: HTTPHeaderBag): boolean {\n    soughtHeader = soughtHeader.toLowerCase()\n\n    for (const headerName of Object.keys(headers)) {\n        if (soughtHeader === headerName.toLowerCase()) {\n            return true\n        }\n    }\n\n    return false\n}\n\n/**\n * QueryParameterBag is a type alias representing HTTP Query Parameters\n */\nexport type QueryParameterBag = Record<string, string | Array<string>>\n\n/**\n * HTTPRequest represents an HTTP request\n */\nexport interface HTTPRequest {\n    /**\n     * The HTTP method to use\n     */\n    method: HTTPMethod\n\n    /**\n     * The protocol to use (http or https)\n     */\n    protocol: HTTPScheme\n\n    /**\n     * The hostname (domain name or IP address) the request targets\n     */\n    hostname: string\n\n    /**\n     * The port to the request targets\n     */\n    port?: number\n\n    /**\n     * The path to the resource\n     */\n    path: string\n\n    /**\n     * The query parameters to include in the request\n     */\n    query?: QueryParameterBag\n\n    /**\n     * The headers to include in the request\n     */\n    headers: HTTPHeaderBag\n\n    /**\n     * The body of the request\n     */\n    body?: string | ArrayBuffer | null\n}\n\n/**\n * SignedHTTPRequest represents an HTTP request that has been signed\n * with an AWS signature. It is a superset of HTTPRequest adding\n * the following fields:\n * - url: the fully qualified URL of the request that can be used in a k6 http.request.\n */\nexport interface SignedHTTPRequest extends HTTPRequest {\n    url: string\n}\n","/**\n *\n * @param value\n * @returns\n */\nexport function isArrayBuffer(value: any): value is ArrayBuffer {\n    return (\n        typeof ArrayBuffer === 'function' &&\n        (value instanceof ArrayBuffer ||\n            Object.prototype.toString.call(value) === '[object ArrayBuffer]')\n    )\n}\n","import { JSONArray, JSONObject } from 'k6'\nimport http, { RefinedResponse, ResponseType } from 'k6/http'\n\nimport { AWSClient } from './client'\nimport { AWSConfig } from './config'\nimport { AMZ_TARGET_HEADER } from './constants'\nimport { AWSError } from './error'\nimport { HTTPHeaders, HTTPMethod } from './http'\nimport { InvalidSignatureError, SignatureV4 } from './signature'\n\n/**\n * Class allowing to interact with Amazon AWS's KMS service\n */\nexport class KMSClient extends AWSClient {\n    method: HTTPMethod\n    commonHeaders: HTTPHeaders\n\n    signature: SignatureV4\n\n    /**\n     * Create a KMSClient\n     * @param  {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     */\n    constructor(awsConfig: AWSConfig) {\n        super(awsConfig, 'kms')\n\n        this.signature = new SignatureV4({\n            service: this.serviceName,\n            region: awsConfig.region,\n            credentials: {\n                accessKeyId: awsConfig.accessKeyID,\n                secretAccessKey: awsConfig.secretAccessKey,\n            },\n            uriEscapePath: false,\n            applyChecksum: false,\n        })\n\n        // All interactions with the KMS service\n        // are made via the GET or POST method.\n        this.method = 'POST'\n\n        this.commonHeaders = {\n            'Content-Type': 'application/x-amz-json-1.1',\n        }\n    }\n\n    /**\n     * Gets a list of all the KMS keys in the caller's AWS\n     * account and region.\n     *\n     * @returns an array of all the available keys\n     */\n    listKeys(): Array<KMSKey> {\n        const signedRequest = this.signature.sign(\n            {\n                method: this.method,\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    // For some reason, the base target is not kms...\n                    [AMZ_TARGET_HEADER]: `TrentService.ListKeys`,\n                },\n                body: JSON.stringify({}),\n            },\n            {}\n        )\n\n        const res = http.request(this.method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(KMSOperation.ListKeys, res)\n\n        const json: JSONArray = res.json('Keys') as JSONArray\n        return json.map((k) => KMSKey.fromJSON(k as JSONObject))\n    }\n\n    /**\n     * GenerateDataKey returns a unique symmetric data key for use outside of AWS KMS.\n     *\n     * This operation returns a plaintext copy of the data key and a copy that is encrypted under a symmetric encryption KMS key that you specify.\n     * The bytes in the plaintext key are random; they are not related to the caller or the KMS key.\n     * You can use the plaintext key to encrypt your data outside of AWS KMS and store the encrypted data key with the encrypted data.\n     *\n     * To generate a data key, specify the symmetric encryption KMS key that will be used to encrypt the data key.\n     * You cannot use an asymmetric KMS key to encrypt data keys.\n     *\n     * Used to generate data key with the KMS key defined\n     * @param {string} id - Specifies the symmetric encryption KMS key that encrypts the data key. Use its key ID, key ARN, alias name, or alias ARN.\n     * @param {KMKeySize} size - Specifies the length of the data key in bytes. For example, use the value 64 to generate a 512-bit data key (64 bytes is 512 bits). Default is 32, and generates a 256-bit data key.\n     * @throws {KMSServiceError}\n     * @throws {InvalidSignatureError}\n     * @returns {KMSDataKey} - The generated data key.\n     */\n    generateDataKey(id: string, size: KMSKeySize = KMSKeySize.Size256): KMSDataKey | undefined {\n        const signedRequest = this.signature.sign(\n            {\n                method: this.method,\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    // For some reason, the base target is not kms...\n                    [AMZ_TARGET_HEADER]: `TrentService.GenerateDataKey`,\n                },\n                body: JSON.stringify({ KeyId: id, NumberOfBytes: size }),\n            },\n            {}\n        )\n\n        const res = http.request(this.method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(KMSOperation.GenerateDataKey, res)\n\n        return KMSDataKey.fromJSON(res.json() as JSONObject)\n    }\n\n    _handle_error(operation: KMSOperation, response: RefinedResponse<ResponseType | undefined>) {\n        const errorCode = response.error_code\n        if (errorCode === 0) {\n            return\n        }\n\n        const error = response.json() as JSONObject\n        if (errorCode >= 1400 && errorCode <= 1499) {\n            // In the event of certain errors, the message is not set.\n            // Also, note the inconsistency in casing...\n            const errorMessage: string =\n                (error.Message as string) || (error.message as string) || (error.__type as string)\n\n            // Handle specifically the case of an invalid signature\n            if (error.__type === 'InvalidSignatureException') {\n                throw new InvalidSignatureError(errorMessage, error.__type)\n            }\n\n            // Otherwise throw a standard service error\n            throw new KMSServiceError(errorMessage, error.__type as string, operation)\n        }\n\n        if (errorCode === 1500) {\n            throw new KMSServiceError(\n                'An error occured on the server side',\n                'InternalServiceError',\n                operation\n            )\n        }\n    }\n}\n\n/**\n * Class representing a KMS key\n */\nexport class KMSKey {\n    /**\n     * ARN of the key\n     */\n    keyArn: string\n\n    /**\n     * Unique identifier of the key\n     */\n    keyId: string\n\n    constructor(keyArn: string, KeyId: string) {\n        this.keyArn = keyArn\n        this.keyId = KeyId\n    }\n\n    static fromJSON(json: JSONObject) {\n        return new KMSKey(json.KeyArn as string, json.KeyId as string)\n    }\n}\n\n/**\n * Class representing a data key\n */\nexport class KMSDataKey {\n    /**\n     * The Amazon Resource Name (key ARN) of the KMS key that encrypted the data key.\n     */\n    id: string\n\n    /**\n     * The (base64-encoded) encrypted copy of the data key.\n     */\n    ciphertextBlob: string\n\n    /**\n     * The plaintext data key.\n     * Use this data key to encrypt your data outside of KMS. Then, remove it from memory as soon as possible.\n     */\n    plaintext: string\n\n    constructor(CiphertextBlob: string, KeyId: string, Plaintext: string) {\n        this.ciphertextBlob = CiphertextBlob\n        this.id = KeyId\n        this.plaintext = Plaintext\n    }\n\n    static fromJSON(json: JSONObject) {\n        return new KMSDataKey(\n            json.CiphertextBlob as string,\n            json.KeyId as string,\n            json.Plaintext as string\n        )\n    }\n}\n\nexport class KMSServiceError extends AWSError {\n    operation: KMSOperation\n\n    /**\n     * Constructs a KMSServiceError\n     *\n     * @param  {string} message - human readable error message\n     * @param  {string} code - A unique short code representing the error that was emitted\n     * @param  {string} operation - Name of the failed Operation\n     */\n    constructor(message: string, code: string, operation: KMSOperation) {\n        super(message, code)\n        this.name = 'KMSServiceError'\n        this.operation = operation\n    }\n}\n\n/**\n *  KMSOperation defines all currently implemented KMS Service operations.\n */\nenum KMSOperation {\n    GenerateDataKey = 'GenerateDataKey',\n    ListKeys = 'ListKeys',\n}\n\n/**\n *  KMSKeyLength describes possible key lenght values for KMS API data key operations.\n */\nenum KMSKeySize {\n    Size256 = 32,\n    Size512 = 64,\n}\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","AWSConfig","options","region","InvalidAWSConfigError","accessKeyId","length","secretAccessKey","this","undefined","sessionToken","scheme","endpoint","message","Error","require","AWSClient","awsConfig","serviceName","_host","host","AMZ_DATE_QUERY_PARAM","AMZ_SIGNATURE_QUERY_PARAM","AMZ_TOKEN_QUERY_PARAM","AMZ_CONTENT_SHA256_HEADER","AMZ_DATE_HEADER","toLowerCase","AMZ_SIGNATURE_HEADER","AMZ_TARGET_HEADER","AMZ_TOKEN_HEADER","AUTHORIZATION_HEADER","GENERATED_HEADERS","ALWAYS_UNSIGNABLE_HEADERS","authorization","connection","expect","from","pragma","referer","te","trailer","upgrade","KEY_TYPE_IDENTIFIER","SIGNING_ALGORITHM_IDENTIFIER","MAX_PRESIGNED_TTL","EMPTY_SHA256","UNSIGNED_PAYLOAD","AWSError","code","name","xmlDocument","doc","parseHTML","find","text","SignatureV4","service","credentials","uriEscapePath","applyChecksum","request","signingDate","Date","signingService","signingRegion","unsignableHeaders","Set","signableHeaders","formatDate","longDate","shortDate","scope","constants","headers","hostname","keys","headerName","ArrayBuffer","isView","body","buffer","payloadHash","soughtHeader","hasHeader","crypto","canonicalHeaders","computeCanonicalHeaders","canonicalRequest","createCanonicalRequest","signingKey","deriveSigningKey","signature","calculateSignature","sort","join","url","protocol","path","query","serializeQueryParameters","originalRequest","expiresIn","unhoistableHeaders","InvalidSignatureError","moveHeadersToQuery","toString","computePayloadHash","sortedHeaders","sortedCanonicalHeaders","map","signedHeaders","method","computeCanonicalURI","computeCanonicalQuerystring","credentialScope","hashedCanonicalRequest","stringToSign","createStringToSign","kSecret","kDate","kRegion","kService","normalizedURISegments","split","URISegment","pop","push","leading","startsWith","URI","trailing","endsWith","normalizedURI","encodeURIComponent","replace","serialized","escapeURI","Array","isArray","slice","reduce","encoded","concat","filter","canonicalHeaderName","has","trim","requestCopy","JSON","parse","stringify","lowerCaseName","ignoreKeys","includes","c","charCodeAt","toUpperCase","date","time","Number","toDate","toISOString","KMSOperation","KMSKeySize","KMSClient","accessKeyID","commonHeaders","signedRequest","sign","res","http","_handle_error","ListKeys","json","k","KMSKey","fromJSON","id","size","Size256","KeyId","NumberOfBytes","GenerateDataKey","KMSDataKey","operation","response","errorCode","error_code","error","errorMessage","Message","__type","KMSServiceError","keyArn","keyId","KeyArn","CiphertextBlob","Plaintext","ciphertextBlob","plaintext"],"sourceRoot":""}