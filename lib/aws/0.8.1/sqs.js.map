{"version":3,"file":"sqs.js","mappings":"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","sources":["webpack://k6-jslib-aws/./src/internal/client.ts","webpack://k6-jslib-aws/./src/internal/config.ts","webpack://k6-jslib-aws/./src/internal/constants.ts","webpack://k6-jslib-aws/./src/internal/error.ts","webpack://k6-jslib-aws/./src/internal/http.ts","webpack://k6-jslib-aws/./src/internal/signature.ts","webpack://k6-jslib-aws/./src/internal/utils.ts","webpack://k6-jslib-aws/external commonjs \"k6/crypto\"","webpack://k6-jslib-aws/external commonjs \"k6/html\"","webpack://k6-jslib-aws/external commonjs \"k6/http\"","webpack://k6-jslib-aws/webpack/bootstrap","webpack://k6-jslib-aws/webpack/runtime/compat get default export","webpack://k6-jslib-aws/webpack/runtime/define property getters","webpack://k6-jslib-aws/webpack/runtime/hasOwnProperty shorthand","webpack://k6-jslib-aws/webpack/runtime/make namespace object","webpack://k6-jslib-aws/./src/internal/sqs.ts"],"sourcesContent":["import { AWSConfig } from './config'\nimport { HTTPHeaders } from './http'\nimport { HTTPScheme } from './http'\n/**\n * Class allowing to build requests targeting AWS APIs\n *\n * This class is meant to be used as a base class for specific\n * services clients. See S3Client or SecretsManagerClient for\n * usage examples.\n */\nexport class AWSClient {\n    awsConfig: AWSConfig\n    serviceName: string\n\n    private _host?: string\n    private _scheme?: HTTPScheme\n    /**\n     * @param {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     * @param  {string} serviceName - name of the service to target.\n     * @param  {URIEncodingConfig} URIencodingConfig - configures how requests URIs should be encoded.\n     */\n    constructor(awsConfig: AWSConfig, serviceName: string) {\n        this.awsConfig = awsConfig\n        this.serviceName = serviceName\n    }\n\n    /**\n     * Property computing the URL to send the requests to when interacting with\n     * the specific AWS service the child class implements the functionalities of.\n     */\n    public get host() {\n        if (this._host == undefined) {\n          this._host = `${this.serviceName}.${this.awsConfig.region}.${this.awsConfig.endpoint}`\n        }\n        return this._host\n    }\n\n    public set host(host: string) {\n        this._host = host\n    }\n\n      /**\n     * Property computing the scheme to use http or https. Defaults to https as per AWSConfig Defaults\n     * the specific AWS service the child class implements the functionalities of.\n     */\n  \n    public get scheme() {\n\n      if (this._scheme == undefined) {\n        this._scheme = this.awsConfig.scheme;\n      }\n      return this._scheme\n    }\n  \n    // Validatiuon should be done by the type declaration \n    public set scheme(scheme: HTTPScheme) {\n      this._scheme = scheme\n  }\n\n}\n\n/**\n * Type alias representing the result of an AWSClient.buildRequest call\n */\nexport interface AWSRequest {\n    url: string\n    headers: HTTPHeaders\n}\n","import { HTTPScheme } from './http'\n\n/** Class holding an AWS connection information */\nexport class AWSConfig {\n    /**\n     * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     *\n     * @type {string}\n     */\n    region: string\n\n    /**\n     * Your user's AWS access key id credential.\n     *\n     * @type {string}\n     */\n    accessKeyId: string\n\n    /**\n     * Your user's AWS secret access key credential.\n     *\n     * @type {string}\n     */\n    secretAccessKey: string\n\n    /**\n     * Your user's AWS session token credential.\n     *\n     * @type {string}\n     */\n    sessionToken?: string\n\n    /**\n     * The HTTP scheme to use when connecting to AWS.\n     *\n     * @type {HTTPScheme} ['https']\n     */\n    scheme: HTTPScheme = 'https'\n\n    // FIXME: Should really be called \"host\" instead. When used\n    // with localstack we pass a complete host (hostname:port) here.\n    /**\n     * The AWS hostname to connect to.\n     *\n     * @type {string} ['amazonaws.com']\n     */\n    endpoint: string = 'amazonaws.com'\n\n    /**\n     * fromEnvironment creates an AWSConfig from the environment variables.\n     *\n     * It expects to find the following compulsory environment variables:\n     *  * AWS_REGION\n     *  * AWS_ACCESS_KEY_ID\n     *  * AWS_SECRET_ACCESS_KEY\n     *\n     * If set, the following optional environment variables are also used:\n     *  * AWS_SESSION_TOKEN\n     *\n     * Finally, the options parameter allows to explicitly set the scheme and endpoint\n     * to use when connecting to AWS.\n     *\n     * @param options {AWSConnectionOptions}\n     * @returns\n     */\n    static fromEnvironment(options?: AWSConnectionOptions): AWSConfig {\n        const region = __ENV.AWS_REGION;\n        const accessKeyId = __ENV.AWS_ACCESS_KEY_ID;\n        const secretAccessKey = __ENV.AWS_SECRET_ACCESS_KEY;\n        const sessionToken: string | undefined = __ENV.AWS_SESSION_TOKEN;\n        const scheme: HTTPScheme | undefined = options?.scheme;\n        const endpoint: string | undefined = options?.endpoint;\n\n        return new AWSConfig({\n            region,\n            accessKeyId,\n            secretAccessKey,\n            sessionToken,\n            scheme: scheme,\n            endpoint: endpoint,\n        })\n    }\n\n    /**\n     * Create an AWSConfig.\n     *\n     * @param {AWSConfigOptions} options - configuration attributes to use when interacting with AWS' APIs\n     * @throws {InvalidArgumentException}\n     */\n    constructor(options: AWSConfigOptions) {\n        if (!options.region || options.region === '') {\n            throw new InvalidAWSConfigError(\n                `invalid AWS region; reason: expected a valid AWS region name (e.g. \"us-east-1\"), got \\`${options.region}\\``\n            )\n        }\n\n        if (!options.accessKeyId || options.accessKeyId === '') {\n            throw new InvalidAWSConfigError(\n                `invalid AWS access key ID; reason: expected a non empty string, got \\`${options.accessKeyId}\\``\n            )\n        }\n\n        if (options.accessKeyId.length < 16 || options.accessKeyId.length > 128) {\n            throw new InvalidAWSConfigError(\n                `invalid AWS access key ID; reason: size should be between 16 and 128 characters, got ${options.accessKeyId.length}`\n            )\n        }\n\n        if (!options.secretAccessKey || options.secretAccessKey === '') {\n            throw new InvalidAWSConfigError(\n                `invalid AWS secret access key; reason: expected a non empty string, got \\`${options.secretAccessKey}\\``\n            )\n        }\n\n        if (options.secretAccessKey.length < 16 || options.secretAccessKey.length > 128) {\n            throw new InvalidAWSConfigError(\n                `invalid AWS secret access key; reason: size should be between 16 and 128 characters, got ${options.secretAccessKey.length}`\n            )\n        }\n\n        this.region = options.region\n        this.accessKeyId = options.accessKeyId\n        this.secretAccessKey = options.secretAccessKey\n\n        if (options.sessionToken !== undefined) {\n            this.sessionToken = options.sessionToken\n        }\n\n        if (options.scheme !== undefined) {\n            this.scheme = options.scheme\n        }\n\n        if (options.endpoint !== undefined) {\n            this.endpoint = options.endpoint\n        }\n    }\n}\n\n/**\n * Interface representing AWSConfig options\n */\nexport interface AWSConfigOptions extends AWSConnectionOptions {\n    /**\n     * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     *\n     * @type {string}\n     */\n    region: string\n\n    /**\n     * Your user's AWS access key id credential.\n     *\n     * @type {string}\n     */\n    accessKeyId: string\n\n    /**\n     * Your user's AWS secret access key credential.\n     *\n     * @type {string}\n     */\n    secretAccessKey: string\n\n    /**\n     * Your user's AWS session token credential.\n     *\n     * @type {string}\n     */\n    sessionToken?: string\n}\n\n/**\n * Interface representing AWS connection options\n */\nexport interface AWSConnectionOptions {\n    /**\n     * The HTTP scheme to use when connecting to AWS.\n     *\n     * @type {HTTPScheme}\n     */\n    scheme?: HTTPScheme\n\n    /**\n     * The AWS hostname to connect to.\n     *\n     * @type {string}\n     */\n    endpoint?: string\n}\n\n/** Class representing an invalid AWS configuration */\nexport class InvalidAWSConfigError extends Error {\n    constructor(message: string) {\n        super(message)\n    }\n}\n","/**\n * Standard Amazon AWS query parameter names\n */\nexport const AMZ_ALGORITHM_QUERY_PARAM = 'X-Amz-Algorithm'\nexport const AMZ_CREDENTIAL_QUERY_PARAM = 'X-Amz-Credential'\nexport const AMZ_DATE_QUERY_PARAM = 'X-Amz-Date'\nexport const AMZ_EXPIRES_QUERY_PARAM = 'X-Amz-Expires'\nexport const AMZ_SIGNATURE_QUERY_PARAM = 'X-Amz-Signature'\nexport const AMZ_SIGNED_HEADERS_QUERY_PARAM = 'X-Amz-SignedHeaders'\nexport const AMZ_TARGET_QUERY_PARAM = 'X-Amz-Target'\nexport const AMZ_TOKEN_QUERY_PARAM = 'X-Amz-Security-Token'\n\n/**\n * Standard Amazon AWS header names\n */\nexport const AMZ_CONTENT_SHA256_HEADER = 'x-amz-content-sha256'\nexport const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase()\nexport const AMZ_SIGNATURE_HEADER = AMZ_SIGNATURE_QUERY_PARAM.toLowerCase()\nexport const AMZ_TARGET_HEADER = AMZ_TARGET_QUERY_PARAM.toLowerCase()\nexport const AMZ_TOKEN_HEADER = AMZ_TOKEN_QUERY_PARAM.toLowerCase()\n\n/**\n * Common HTTP headers we rely on in the signing process\n */\nexport const AUTHORIZATION_HEADER = 'authorization'\nexport const DATE_HEADER = 'date'\n\n/**\n * Lists the headers that are generated as part of the signature process.\n */\nexport const GENERATED_HEADERS = [AUTHORIZATION_HEADER, AMZ_DATE_HEADER, DATE_HEADER]\nexport const HOST_HEADER = 'host'\n\n/**\n * Lists the headers that should never be included in the\n * request signature signature process.\n */\nexport const ALWAYS_UNSIGNABLE_HEADERS = {\n    authorization: true,\n    'cache-control': true,\n    connection: true,\n    expect: true,\n    from: true,\n    'keep-alive': true,\n    'max-forwards': true,\n    pragma: true,\n    referer: true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n    'user-agent': true,\n    'x-amzn-trace-id': true,\n}\n\n/**\n * Signature specific constants included in the signing process\n */\nexport const KEY_TYPE_IDENTIFIER = 'aws4_request'\nexport const SIGNING_ALGORITHM_IDENTIFIER = 'AWS4-HMAC-SHA256'\n\n/**\n * Maximum time to live of a signed request in seconds: 7 days.\n */\nexport const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7\n\n/**\n * SHA256 hash of an empty string (so we don't waste cycles recomputing it)\n */\nexport const EMPTY_SHA256 = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n\n/**\n * SHA256 hash of the unsigned payload constant (so we don't waste cycles recomputing it)\n */\nexport const UNSIGNED_PAYLOAD_SHA256 =\n    '5a41b0751e4537c6ff868564ab44a4d4ecceec2ec5b1c5f74d97422968e04237'\n\nexport const UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD'\n","import { parseHTML } from 'k6/html'\n\n/**\n * Base class to derive errors from\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class AWSError extends Error {\n    /**\n     * Error code issued by the service (if any)\n     */\n    code?: string\n\n    /**\n     * Create an AWSError\n     *\n     * @param {string} message - A longer human readable error message.\n     * @param {string?} code - A unique short code representing the error that was emitted\n     */\n    constructor(message: string, code?: string) {\n        super(message)\n        this.name = 'AWSError'\n        this.code = code\n    }\n\n    /**\n     * Parse an AWSError from an XML document\n     *\n     * @param  {string} xmlDocument - Serialized XML document to parse the error from\n     */\n    static parseXML(xmlDocument: string): AWSError {\n        const doc = parseHTML(xmlDocument)\n        return new AWSError(doc.find('Message').text(), doc.find('Code').text())\n    }\n}\n","/**\n * Type representing HTTP schemes\n */\nexport type HTTPScheme = 'http' | 'https'\n\n/**\n * Type representing HTTP Methods\n *\n */\nexport type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\n/**\n * Type alias representing HTTP Headers\n */\nexport type HTTPHeaders = { [key: string]: string }\n\n/**\n * HTTPHeaderBag is a type alias representing HTTP Headers\n */\nexport type HTTPHeaderBag = Record<string, string>\n\nexport function hasHeader(soughtHeader: string, headers: HTTPHeaderBag): boolean {\n    soughtHeader = soughtHeader.toLowerCase()\n\n    for (const headerName of Object.keys(headers)) {\n        if (soughtHeader === headerName.toLowerCase()) {\n            return true\n        }\n    }\n\n    return false\n}\n\n/**\n * QueryParameterBag is a type alias representing HTTP Query Parameters\n */\nexport type QueryParameterBag = Record<string, string | Array<string>>\n\n/**\n * HTTPRequest represents an HTTP request\n */\nexport interface HTTPRequest {\n    /**\n     * The HTTP method to use\n     */\n    method: HTTPMethod\n\n    /**\n     * The protocol to use (http or https)\n     */\n    protocol: HTTPScheme\n\n    /**\n     * The hostname (domain name or IP address) the request targets\n     */\n    hostname: string\n\n    /**\n     * The port to the request targets\n     */\n    port?: number\n\n    /**\n     * The path to the resource\n     */\n    path: string\n\n    /**\n     * The query parameters to include in the request\n     */\n    query?: QueryParameterBag\n\n    /**\n     * The headers to include in the request\n     */\n    headers: HTTPHeaderBag\n\n    /**\n     * The body of the request\n     */\n    body?: string | ArrayBuffer | null\n}\n\n/**\n * SignedHTTPRequest represents an HTTP request that has been signed\n * with an AWS signature. It is a superset of HTTPRequest adding\n * the following fields:\n * - url: the fully qualified URL of the request that can be used in a k6 http.request.\n */\nexport interface SignedHTTPRequest extends HTTPRequest {\n    url: string\n}\n","import crypto from 'k6/crypto'\n\nimport * as constants from './constants'\nimport { AWSError } from './error'\nimport { hasHeader, HTTPHeaderBag, HTTPRequest, QueryParameterBag, SignedHTTPRequest } from './http'\nimport { isArrayBuffer } from './utils'\n\n/**\n * SignatureV4 can be used to sign HTTP requests and presign URLs using the AWS Signature\n * Version 4 signing process.\n *\n * It offers two signing methods:\n * - sign: signs the request headers and payload\n * - presign: returns a presigned (authorization information contained in the query string) URL\n *\n * @see https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */\nexport class SignatureV4 {\n    /**\n     * The name of the service to sign for.\n     */\n    private readonly service: string\n\n    /**\n     * The name of the region to sign for.\n     */\n    private readonly region: string\n\n    /**\n     * The credentials with which the request should be signed.\n     */\n    private readonly credentials: Credentials\n\n    /**\n     * Whether to uri-escape the request URI path as part of computing the\n     * canonical request string. This is required for every AWS service, except\n     * Amazon S3, as of late 2017.\n     *\n     * @default [true]\n     */\n    private readonly uriEscapePath: boolean\n\n    /**\n     * Whether to calculate a checksum of the request body and include it as\n     * either a request header (when signing) or as a query string parameter\n     * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n     * every other AWS service as of late 2017.\n     *\n     * @default [true]\n     */\n    private readonly applyChecksum: boolean\n\n    // TODO: uriEscapePath and applyChecksum should not be present in the constructor\n    constructor({\n        service,\n        region,\n        credentials,\n        uriEscapePath,\n        applyChecksum,\n    }: SignatureV4Options) {\n        this.service = service\n        this.region = region\n        this.credentials = credentials\n        this.uriEscapePath = typeof uriEscapePath === 'boolean' ? uriEscapePath : true\n        this.applyChecksum = typeof applyChecksum === 'boolean' ? applyChecksum : true\n    }\n\n    /**\n     * Includes AWS v4 signing information to the provided HTTP request.\n     *\n     * This method adds an Authorization header to the request, containing\n     * the signature and other signing information. It also returns a preformatted\n     * URL that can be used to make the k6 http request.\n     *\n     * This method mutates the request object.\n     *\n     * @param request {HTTPRequest} The request to sign.\n     * @param options {Partial<RequestSigningOptions>} Options for signing the request.\n     * @returns {SignedHTTPRequest} The signed request.\n     */\n    sign(request: HTTPRequest, options: Partial<RequestSigningOptions> = {}): SignedHTTPRequest {\n        // Set default values for options which are not provided by the user.\n        const defaultOptions = {\n            signingDate: new Date(),\n            unsignableHeaders: new Set<string>(),\n            signableHeaders: new Set<string>(),\n        }\n\n        // Merge default options with the ones maybe provided by the user.\n        const finalOptions = { ...defaultOptions, ...options }\n\n        const { longDate, shortDate }: DateInfo = formatDate(finalOptions.signingDate)\n        const service = finalOptions.signingService || this.service\n        const region = finalOptions.signingRegion || this.region\n        const scope = `${shortDate}/${region}/${service}/${constants.KEY_TYPE_IDENTIFIER}`\n\n        // Required by the specification:\n        //   \"For HTTP/1.1 requests, you must include the host header at a minimum.\n        //   Standard headers like content-type are optional.\n        //   For HTTP/2 requests, you must include the :authority header instead of\n        //   the host header. Different services might require other headers.\"\n        request.headers[constants.HOST_HEADER] = request.hostname\n\n        // Filter out headers that will be generated and managed by the signing process.\n        // If the user provide any of those as part of the HTTPRequest's headers, they\n        // will be ignored.\n        for (const headerName of Object.keys(request.headers)) {\n            if (constants.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {\n                delete request.headers[headerName]\n            }\n        }\n\n        request.headers[constants.AMZ_DATE_HEADER] = longDate\n        if (this.credentials.sessionToken) {\n            request.headers[constants.AMZ_TOKEN_HEADER] = this.credentials.sessionToken\n        }\n\n        // If the request body is a typed array, we need to convert it to a buffer\n        // so that we can calculate the checksum.\n        if (ArrayBuffer.isView(request.body)) {\n            request.body = request.body.buffer\n        }\n\n        // Ensure we avoid passing undefined to the crypto hash function.\n        if (!request.body) {\n            request.body = ''\n        }\n\n        let payloadHash = this.computePayloadHash(request)\n        if (\n            !hasHeader(constants.AMZ_CONTENT_SHA256_HEADER, request.headers) &&\n            this.applyChecksum\n        ) {\n            request.headers[constants.AMZ_CONTENT_SHA256_HEADER] = payloadHash\n        }\n\n        const canonicalHeaders = this.computeCanonicalHeaders(\n            request,\n            finalOptions.unsignableHeaders,\n            finalOptions.signableHeaders\n        )\n        const signature = this.calculateSignature(\n            longDate,\n            scope,\n            this.deriveSigningKey(this.credentials, service, region, shortDate),\n            this.createCanonicalRequest(request, canonicalHeaders, payloadHash)\n        )\n\n        /**\n         * Step 4 of the signing process: add the signature to the HTTP request's headers.\n         *\n         * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n         */\n        request.headers[constants.AUTHORIZATION_HEADER] =\n            `${constants.SIGNING_ALGORITHM_IDENTIFIER} ` +\n            `Credential=${this.credentials.accessKeyId}/${scope}, ` +\n            `SignedHeaders=${Object.keys(canonicalHeaders).sort().join(';')}, ` +\n            `Signature=${signature}`\n\n        // If a request path was provided, add it to the URL\n        let url = `${request.protocol}://${request.hostname}`\n        if (request.path) {\n            url += request.path\n        }\n\n        // If a request query string was provided, add it to the URL\n        if (request.query) {\n            // We exclude the signature from the query string\n            url += `?${this.serializeQueryParameters(request.query)}`\n        }\n\n        return {\n            url: url,\n            ...request,\n        }\n    }\n\n    /**\n     * Produces a presigned URL with AWS v4 signature information for the provided HTTP request.\n     *\n     * A presigned URL is a URL that contains the authorization information\n     * (signature and other signing information) in the query string. This method\n     * returns a preformatted URL that can be used to make the k6 http request.\n     *\n     * @param originalRequest - The original request to presign.\n     * @param options - Options controlling the signing of the request.\n     * @returns A signed request, including the presigned URL.\n     */\n    presign(originalRequest: HTTPRequest, options: PresignOptions = {}): SignedHTTPRequest {\n        const {\n            signingDate = new Date(),\n            expiresIn = 3600,\n            unsignableHeaders,\n            unhoistableHeaders,\n            signableHeaders,\n            signingRegion,\n            signingService,\n        } = options\n        const { longDate, shortDate }: DateInfo = formatDate(signingDate)\n        const region = signingRegion || this.region\n        const service = signingService || this.service\n\n        if (expiresIn > constants.MAX_PRESIGNED_TTL) {\n            throw new InvalidSignatureError(\n                \"Signature version 4 presigned URLs can't be valid for more than 7 days\"\n            )\n        }\n\n        const scope = `${shortDate}/${region}/${service}/${constants.KEY_TYPE_IDENTIFIER}`\n        const request = this.moveHeadersToQuery(originalRequest, { unhoistableHeaders })\n\n        // Required by the specification:\n        //   \"For HTTP/1.1 requests, you must include the host header at a minimum.\n        //   Standard headers like content-type are optional.\n        //   For HTTP/2 requests, you must include the :authority header instead of\n        //   the host header. Different services might require other headers.\"\n        request.headers[constants.HOST_HEADER] = originalRequest.hostname\n\n        // If the user provided a session token, include it in the signed url query string.\n        if (this.credentials.sessionToken) {\n            request.query[constants.AMZ_TOKEN_QUERY_PARAM] = this.credentials.sessionToken\n        }\n\n        // Add base signing query parameters to the request, as described in the documentation\n        // @see https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n        request.query[constants.AMZ_ALGORITHM_QUERY_PARAM] = constants.SIGNING_ALGORITHM_IDENTIFIER\n        request.query[\n            constants.AMZ_CREDENTIAL_QUERY_PARAM\n        ] = `${this.credentials.accessKeyId}/${scope}`\n        request.query[constants.AMZ_DATE_QUERY_PARAM] = longDate\n        request.query[constants.AMZ_EXPIRES_QUERY_PARAM] = expiresIn.toString(10)\n\n        const canonicalHeaders = this.computeCanonicalHeaders(\n            request,\n            unsignableHeaders,\n            signableHeaders\n        )\n        request.query[constants.AMZ_SIGNED_HEADERS_QUERY_PARAM] = Object.keys(canonicalHeaders)\n            .sort()\n            .join(';')\n\n        const signingKey = this.deriveSigningKey(this.credentials, service, region, shortDate)\n\n        // Computing the payload from the original request. This is required\n        // in the event the user attempts to produce a presigned URL for s3,\n        // which requires the payload hash to be 'UNSIGNED-PAYLOAD'.\n        //\n        // To that effect, users need to set the 'x-amz-content-sha256' header,\n        // and mark it as unhoistable and unsignable. When setup this way,\n        // the computePayloadHash method will then return the string 'UNSIGNED-PAYLOAD'.\n        const payloadHash = this.computePayloadHash(originalRequest)\n        const canonicalRequest = this.createCanonicalRequest(request, canonicalHeaders, payloadHash)\n\n        request.query[constants.AMZ_SIGNATURE_QUERY_PARAM] = this.calculateSignature(\n            longDate,\n            scope,\n            signingKey,\n            canonicalRequest\n        )\n\n        // If a request path was provided, add it to the URL\n        let url = `${request.protocol}://${request.hostname}`\n        if (request.path) {\n            url += request.path\n        }\n\n        // If a request query string was provided, add it to the URL\n        if (request.query) {\n            url += `?${this.serializeQueryParameters(request.query)}`\n        }\n\n        return { url: url, ...request }\n    }\n\n    /**\n     * Create a string including information from your request\n     * in a AWS signature v4 standardized (canonical) format.\n     *\n     * Step 1 of the signing process: create the canonical request string.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n     *\n     * @param request {HTTPRequest} The request to sign.\n     * @param canonicalHeaders {HTTPHeaderBag} The request's canonical headers.\n     * @param payloadHash {string} The hexadecimally encoded request's payload hash .\n     * @returns {string} The canonical request string.\n     */\n    private createCanonicalRequest(\n        request: HTTPRequest,\n        canonicalHeaders: HTTPHeaderBag,\n        payloadHash: string\n    ): string {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort()\n        const sortedCanonicalHeaders = sortedHeaders\n            .map((name) => `${name}:${canonicalHeaders[name]}`)\n            .join('\\n')\n        const signedHeaders = sortedHeaders.join(';')\n\n        return (\n            `${request.method}\\n` +\n            `${this.computeCanonicalURI(request)}\\n` +\n            `${this.computeCanonicalQuerystring(request)}\\n` +\n            `${sortedCanonicalHeaders}\\n\\n` +\n            `${signedHeaders}\\n` +\n            `${payloadHash}`\n        )\n    }\n\n    /**\n     * Create the \"string to sign\" part of the signature Version 4 protocol.\n     *\n     * The \"string to sign\" includes meta information about your request and\n     * about the canonical request that you created with `createCanonicalRequest`.\n     * It is used hand in hand with the signing key to create the request signature.\n     * Step 2 of the signing process: create the string to sign.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n     *\n     * @param longDate {string} The request's date in iso 8601 format.\n     * @param credentialScope {string} The request's credential scope.\n     * @param canonicalRequest {string} The request's canonical request.\n     * @returns {string} The \"string to sign\".\n     */\n    private createStringToSign(\n        longDate: string,\n        credentialScope: string,\n        canonicalRequest: string\n    ): string {\n        const hashedCanonicalRequest = crypto.sha256(canonicalRequest, 'hex')\n\n        return (\n            `${constants.SIGNING_ALGORITHM_IDENTIFIER}\\n` +\n            `${longDate}\\n` +\n            `${credentialScope}\\n` +\n            `${hashedCanonicalRequest}`\n        )\n    }\n\n    /**\n     * Calculte the signature for AWS signature version 4.\n     *\n     * Step 3 of the signing process: create the signature.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n     *\n     * @param longDate {string} The request's date in iso 8601 format.\n     * @param credentialScope {string} The request's credential scope.\n     * @param signingKey {string} the signing key as computed by the deriveSigningKey method.\n     * @param canonicalRequest {string} The request's canonical request.\n     * @returns {string} The signature.\n     */\n    private calculateSignature(\n        longDate: string,\n        credentialScope: string,\n        signingKey: Uint8Array,\n        canonicalRequest: string\n    ): string {\n        const stringToSign = this.createStringToSign(longDate, credentialScope, canonicalRequest)\n        return crypto.hmac('sha256', signingKey, stringToSign, 'hex')\n    }\n\n    /**\n     * Derives the signing key for authenticating requests signed with\n     * the Signature version 4 authentication protocol.\n     *\n     * deriveSigningKey produces a signing key by creating a series of\n     * hash-based message authentication codes (HMACs) represented in\n     * a binary format.\n     *\n     * The derived signing key is specific to the date it's made at, as well as\n     * the service and region it targets.\n     *\n     * @param credentials {AWSCredentials} The credentials to use for signing.\n     * @param service {string} The service the request is targeted at.\n     * @param region {string} The region the request is targeted at.\n     * @param shortDate {string} The request's date in YYYYMMDD format.\n     * @returns {Uint8Array} The derived signing key.\n     */\n    private deriveSigningKey(\n        credentials: Credentials,\n        service: string,\n        region: string,\n        shortDate: string\n    ): Uint8Array {\n        const kSecret: string = credentials.secretAccessKey\n        const kDate: any = crypto.hmac('sha256', 'AWS4' + kSecret, shortDate, 'binary')\n        const kRegion: any = crypto.hmac('sha256', kDate, region, 'binary')\n        const kService: any = crypto.hmac('sha256', kRegion, service, 'binary')\n        const kSigning: any = crypto.hmac('sha256', kService, 'aws4_request', 'binary')\n\n        return kSigning\n    }\n\n    /**\n     * Create a string that includes information from your request\n     * in a AWS signature v4 standardized (canonical) format.\n     *\n     * @param param0 {HTTPRequest} The request to sign.\n     * @returns {string} The canonical URI.\n     */\n    private computeCanonicalURI({ path }: HTTPRequest): string {\n        if (this.uriEscapePath) {\n            // Non-S3 services, we normalize the path and then double URI encode it.\n            // Ref: \"Remove Dot Segments\" https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4\n            const normalizedURISegments = []\n\n            for (const URISegment of path.split('/')) {\n                if (URISegment?.length === 0) {\n                    continue\n                }\n\n                if (URISegment === '.') {\n                    continue\n                }\n\n                if (URISegment === '..') {\n                    normalizedURISegments.pop()\n                } else {\n                    normalizedURISegments.push(URISegment)\n                }\n            }\n\n            // Normalize the URI\n            const leading = path?.startsWith('/') ? '/' : ''\n            const URI = normalizedURISegments.join('/')\n            const trailing = normalizedURISegments.length > 0 && path?.endsWith('/') ? '/' : ''\n            const normalizedURI = `${leading}${URI}${trailing}`\n\n            const doubleEncoded = encodeURIComponent(normalizedURI)\n\n            return doubleEncoded.replace(/%2F/g, '/')\n        }\n\n        // For S3, we shouldn't normalize the path. For example, object name\n        // my-object//example//photo.user should not be normalized to\n        // my-object/example/photo.user\n        return path\n    }\n\n    /**\n     * Serializes the request's query parameters into their canonical\n     * string version. If the request does not include a query parameters,\n     * returns an empty string.\n     *\n     * @param param0 {HTTPRequest} The request containing the query parameters.\n     * @returns {string} The canonical query string.\n     */\n    private computeCanonicalQuerystring({ query = {} }: HTTPRequest): string {\n        const keys: Array<string> = []\n        const serialized: Record<string, string> = {}\n\n        for (const key of Object.keys(query).sort()) {\n            if (key.toLowerCase() === constants.AMZ_SIGNATURE_HEADER) {\n                continue\n            }\n\n            keys.push(key)\n            const value = query[key]\n\n            if (typeof value === 'string') {\n                serialized[key] = `${escapeURI(key)}=${escapeURI(value)}`\n            } else if (Array.isArray(value)) {\n                serialized[key] = value\n                    .slice(0)\n                    .sort()\n                    .reduce(\n                        (encoded: Array<string>, value: string) =>\n                            encoded.concat([`${escapeURI(key)}=${escapeURI(value)}`]),\n                        []\n                    )\n                    .join('&')\n            }\n        }\n\n        return keys\n            .map((key) => serialized[key])\n            .filter((serialized) => serialized)\n            .join('&')\n    }\n\n    /**\n     * Create the canonical form of the request's headers.\n     * Canonical headers consist of all the HTTP headers you\n     * are including with the signed request.\n     *\n     * @param param0 {HTTPRequest} The request to compute the canonical headers of.\n     * @param unsignableHeaders {Set<string>} The headers that should not be signed.\n     * @param signableHeaders {Set<string>} The headers that should be signed.\n     * @returns {string} The canonical headers.\n     */\n    private computeCanonicalHeaders(\n        { headers }: HTTPRequest,\n        unsignableHeaders?: Set<string>,\n        signableHeaders?: Set<string>\n    ): HTTPHeaderBag {\n        const canonicalHeaders: HTTPHeaderBag = {}\n\n        for (const headerName of Object.keys(headers).sort()) {\n            if (headers[headerName] == undefined) {\n                continue\n            }\n\n            const canonicalHeaderName = headerName.toLowerCase()\n            if (\n                canonicalHeaderName in constants.ALWAYS_UNSIGNABLE_HEADERS ||\n                unsignableHeaders?.has(canonicalHeaderName)\n            ) {\n                if (\n                    !signableHeaders ||\n                    (signableHeaders && !signableHeaders.has(canonicalHeaderName))\n                ) {\n                    continue\n                }\n            }\n\n            canonicalHeaders[canonicalHeaderName] = headers[headerName].trim().replace(/\\s+/g, ' ')\n        }\n\n        return canonicalHeaders\n    }\n\n    /**\n     * Computes the SHA256 cryptographic hash of the request's body.\n     *\n     * If the headers contain the 'X-Amz-Content-Sha256' header, then\n     * the value of that header is returned instead. This proves useful\n     * when, for example, presiging a URL for S3, as the payload hash\n     * must always be equal to 'UNSIGNED-PAYLOAD'.\n     *\n     * @param param0 {HTTPRequest} The request to compute the payload hash of.\n     * @returns {string} The hex encoded SHA256 payload hash, or the value of the 'X-Amz-Content-Sha256' header.\n     */\n    private computePayloadHash({ headers, body }: HTTPRequest): string {\n        // for (const headerName of Object.keys(headers)) {\n        //     // If the header is present, return its value.\n        //     // So that we let the 'UNSIGNED-PAYLOAD' value pass through.\n        //     if (headerName.toLowerCase() === constants.AMZ_CONTENT_SHA256_HEADER) {\n        //         return headers[headerName]\n        //     }\n        // }\n\n        if (headers[constants.AMZ_CONTENT_SHA256_HEADER]) {\n            return headers[constants.AMZ_CONTENT_SHA256_HEADER]\n        }\n\n        if (body == undefined) {\n            return constants.EMPTY_SHA256\n        }\n\n        if (typeof body === 'string' || isArrayBuffer(body)) {\n            return crypto.sha256(body, 'hex').toLowerCase()\n        }\n\n        if (ArrayBuffer.isView(body)) {\n            // If the request body is a typed array, we need to convert it to a buffer\n            // so that we can calculate the checksum.\n            return crypto.sha256((body as DataView).buffer, 'hex').toLowerCase()\n        }\n\n        return constants.UNSIGNED_PAYLOAD\n    }\n\n    /**\n     * Moves a request's headers to its query parameters.\n     *\n     * The operation will ignore any amazon standard headers, prefixed\n     * with 'X-Amz-'. It will also ignore any headers specified as unhoistable\n     * by the options.\n     *\n     * The operation will delete the headers from the request.\n     *\n     * @param request {HTTPRequest} The request to move the headers from.\n     * @param options\n     * @returns {HTTPRequest} The request with the headers moved to the query parameters.\n     */\n    private moveHeadersToQuery(\n        request: HTTPRequest,\n        options: { unhoistableHeaders?: Set<string> } = {}\n    ): HTTPRequest & { query: QueryParameterBag } {\n        const requestCopy = JSON.parse(JSON.stringify(request))\n        const { headers, query = {} as QueryParameterBag } = requestCopy\n\n        for (const name of Object.keys(headers)) {\n            const lowerCaseName = name.toLowerCase()\n            if (\n                lowerCaseName.slice(0, 6) === 'x-amz-' &&\n                !options.unhoistableHeaders?.has(lowerCaseName)\n            ) {\n                query[name] = headers[name]\n                delete headers[name]\n            }\n        }\n\n        return {\n            ...requestCopy,\n            headers,\n            query,\n        }\n    }\n\n    /**\n     * Serializes a HTTPRequest's query parameter bag into a string.\n     *\n     * @param query {QueryParameterBag} The query parameters to serialize.\n     * @param ignoreKeys {Set<string>} The keys to ignore.\n     * @returns {string} The serialized, and ready to use in a URL, query parameters.\n     */\n    private serializeQueryParameters(query: QueryParameterBag, ignoreKeys?: string[]): string {\n        const keys: Array<string> = []\n        const serialized: Record<string, string> = {}\n\n        for (const key of Object.keys(query).sort()) {\n            if (ignoreKeys?.includes(key.toLowerCase())) {\n                continue\n            }\n\n            keys.push(key)\n            const value = query[key]\n\n            if (typeof value === 'string') {\n                serialized[key] = `${escapeURI(key)}=${escapeURI(value)}`\n            } else if (Array.isArray(value)) {\n                serialized[key] = value\n                    .slice(0)\n                    .sort()\n                    .reduce(\n                        (encoded: Array<string>, value: string) =>\n                            encoded.concat([`${escapeURI(key)}=${escapeURI(value)}`]),\n                        []\n                    )\n                    .join('&')\n            }\n        }\n\n        return keys\n            .map((key) => serialized[key])\n            .filter((serialized) => serialized)\n            .join('&')\n    }\n}\n\n/**\n * Error indicating an Invalid signature has been sent to AWS services\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class InvalidSignatureError extends AWSError {\n    /**\n     * Constructs an InvalidSignatureError\n     *\n     * @param  {string} message - human readable error message\n     */\n    constructor(message: string, code?: string) {\n        super(message, code)\n        this.name = 'InvalidSignatureError'\n    }\n}\n\nexport interface SignatureV4Options {\n    /**\n     * The name of the service to sign for.\n     */\n    service: string\n\n    /**\n     * The name of the region to sign for.\n     */\n    region: string\n\n    /**\n     * The credentials with which the request should be signed.\n     */\n    credentials: Credentials\n\n    /**\n     * Whether to uri-escape the request URI path as part of computing the\n     * canonical request string. This is required for every AWS service, except\n     * Amazon S3, as of late 2017.\n     *\n     * @default [true]\n     */\n    uriEscapePath?: boolean\n\n    /**\n     * Whether to calculate a checksum of the request body and include it as\n     * either a request header (when signing) or as a query string parameter\n     * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n     * every other AWS service as of late 2017.\n     *\n     * @default [true]\n     */\n    applyChecksum?: boolean\n}\n\nexport interface SignOptions {\n    /**\n     * The date and time to be used as signature metadata. This value should be\n     * a Date object, a unix (epoch) timestamp, or a string that can be\n     * understood by the JavaScript `Date` constructor.If not supplied, the\n     * value returned by `new Date()` will be used.\n     */\n    signingDate?: Date\n\n    /**\n     * The service signing name. It will override the service name of the signer\n     * in current invocation\n     */\n    signingService?: string\n\n    /**\n     * The region name to sign the request. It will override the signing region of the\n     * signer in current invocation\n     */\n    signingRegion?: string\n}\n\nexport interface RequestSigningOptions extends SignOptions {\n    /**\n     * A set of strings whose members represents headers that cannot be signed.\n     * All headers in the provided request will have their names converted to\n     * lower case and then checked for existence in the unsignableHeaders set.\n     */\n    unsignableHeaders?: Set<string>\n\n    /**\n     * A set of strings whose members represents headers that should be signed.\n     * Any values passed here will override those provided via unsignableHeaders,\n     * allowing them to be signed.\n     *\n     * All headers in the provided request will have their names converted to\n     * lower case before signing.\n     */\n    signableHeaders?: Set<string>\n}\n\nexport interface PresignOptions extends RequestSigningOptions {\n    /**\n     * The number of seconds before the presigned URL expires\n     */\n    expiresIn?: number\n\n    /**\n     * A set of strings whose representing headers that should not be hoisted\n     * to presigned request's query string. If not supplied, the presigner\n     * moves all the AWS-specific headers (starting with `x-amz-`) to the request\n     * query string. If supplied, these headers remain in the presigned request's\n     * header.\n     * All headers in the provided request will have their names converted to\n     * lower case and then checked for existence in the unhoistableHeaders set.\n     */\n    unhoistableHeaders?: Set<string>\n}\n\nexport interface Credentials {\n    /**\n     * AWS access key ID\n     */\n    readonly accessKeyId: string\n\n    /**\n     * AWS secret access key\n     */\n    readonly secretAccessKey: string\n\n    /**\n     * A security or session token to use with these credentials. Usually\n     * present for temporary credentials.\n     */\n    readonly sessionToken?: string\n}\n\nexport interface DateInfo {\n    /**\n     * ISO8601 formatted date string\n     */\n    longDate: string\n\n    /**\n     * String in the format YYYYMMDD\n     */\n    shortDate: string\n}\n\n/**\n * Escapes a URI following the AWS signature v4 escaping rules.\n *\n * @param URI {string} The URI to escape.\n * @returns {string} The escaped URI.\n */\nfunction escapeURI(URI: string): string {\n    const hexEncode = (c: string): string => {\n        return `%${c.charCodeAt(0).toString(16).toUpperCase()}`\n    }\n\n    return encodeURIComponent(URI).replace(/[!'()*]/g, hexEncode)\n}\n\n/**\n * formatDate formats a Date object into a ISO8601 formatted date string\n * and a string in the format YYYYMMDD.\n *\n * @param date {Date} The date to format.\n * @returns {DateInfo} The formatted date.\n */\nfunction formatDate(date: Date): DateInfo {\n    const longDate = iso8601(date).replace(/[\\-:]/g, '')\n    return {\n        longDate,\n        shortDate: longDate.slice(0, 8),\n    }\n}\n\n/**\n * Formats a time into an ISO 8601 string.\n *\n * @see https://en.wikipedia.org/wiki/ISO_8601\n *\n * @param time {number | string | Date} The time to format.\n * @returns {string} The ISO 8601 formatted time.\n */\nfunction iso8601(time: number | string | Date): string {\n    return toDate(time)\n        .toISOString()\n        .replace(/\\.\\d{3}Z$/, 'Z')\n}\n\n/**\n * Converts a time value into a Date object.\n *\n * @param time {number | string | Date} The time to convert.\n * @returns {Date} The resulting Date object.\n */\nfunction toDate(time: number | string | Date): Date {\n    if (typeof time === 'number') {\n        return new Date(time * 1000)\n    }\n\n    if (typeof time === 'string') {\n        if (Number(time)) {\n            return new Date(Number(time) * 1000)\n        }\n\n        return new Date(time)\n    }\n\n    return time\n}\n","/**\n *\n * @param value\n * @returns\n */\nexport function isArrayBuffer(value: any): value is ArrayBuffer {\n    return (\n        typeof ArrayBuffer === 'function' &&\n        (value instanceof ArrayBuffer ||\n            Object.prototype.toString.call(value) === '[object ArrayBuffer]')\n    )\n}\n\nexport function toFormUrlEncoded(form: any): string {\n    return Object.keys(form).reduce((params, key) => {\n        let value = form[key]\n        if (value !== undefined && value !== null) {\n            params.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\n        }\n        return params;\n    }, [] as string[]).join('&')\n}","module.exports = require(\"k6/crypto\");","module.exports = require(\"k6/html\");","module.exports = require(\"k6/http\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { AWSClient } from './client'\nimport { AWSConfig } from './config'\nimport { SignatureV4, InvalidSignatureError } from './signature'\nimport { HTTPHeaders, SignedHTTPRequest } from './http'\nimport http, { RefinedResponse, ResponseType } from 'k6/http'\nimport { toFormUrlEncoded } from './utils'\nimport { AWSError } from './error'\n\nconst API_VERSION = '2012-11-05'\n\nexport class SQSClient extends AWSClient {\n    private readonly signature: SignatureV4\n    private readonly commonHeaders: HTTPHeaders\n\n    constructor(awsConfig: AWSConfig) {\n        super(awsConfig, 'sqs')\n\n        this.signature = new SignatureV4({\n            service: this.serviceName,\n            region: this.awsConfig.region,\n            credentials: {\n                accessKeyId: this.awsConfig.accessKeyId,\n                secretAccessKey: this.awsConfig.secretAccessKey,\n                sessionToken: this.awsConfig.sessionToken\n            },\n            uriEscapePath: true,\n            applyChecksum: true\n        })\n\n        this.commonHeaders = {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n    }\n\n    /**\n     * Delivers a message to the specified queue.\n     *\n     * @param {string} queueUrl - The URL of the Amazon SQS queue to which a message is sent. Queue URLs and names are case-sensitive.\n     * @param {string} messageBody - The message to send. The minimum size is one character. The maximum size is 256 KB.\n     * @param {Object} options - Options for the request\n     * @param {string} [options.messageDeduplicationId] - The message deduplication id.\n     * @param {string} [options.messageGroupId] - The message group ID for FIFO queues\n     * @returns {Message} - The message that was sent.\n     */\n    sendMessage(queueUrl: string, messageBody: string, options: { messageDeduplicationId?: string; messageGroupId?: string} = {}): Message {\n        const method = 'POST'\n\n        let body: any = {\n            Action: 'SendMessage',\n            Version: API_VERSION,\n            QueueUrl: queueUrl,\n            MessageBody: messageBody,\n        }\n\n        if (typeof(options.messageDeduplicationId) !== 'undefined') {\n            body = { ...body,\n                MessageDeduplicationId: options.messageDeduplicationId\n            }\n        }\n\n        if (typeof(options.messageGroupId) !== 'undefined') {\n            body = { ...body,\n                MessageGroupId: options.messageGroupId\n            }\n        }\n\n        const signedRequest: SignedHTTPRequest = this.signature.sign(\n            {\n                method: 'POST',\n                protocol: this.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders\n                },\n                body: toFormUrlEncoded(body)\n            },\n            {}\n        )\n\n        const res = http.request(method, signedRequest.url, signedRequest.body || '', {\n            headers: signedRequest.headers\n        })\n        this._handleError('SendMessage', res)\n\n        const parsed = res.html('SendMessageResponse > SendMessageResult')\n        return new Message(\n            parsed.find('MessageId').text(),\n            parsed.find('MD5OfMessageBody').text()\n        )\n    }\n\n    /**\n     * Returns a list of your queues in the current region.\n     *\n     * @param {ListQueuesRequestParameters} [parameters={}] request parameters\n     * @param {number} [ListQueuesRequestParameters.maxResults] Maximum number of results to include in the response. Value range is 1 to 1000. You must set maxResults to receive a value for nextToken in the response.\n     * @param {string} [ListQueuesRequestParameters.nextToken] Pagination token to request the next set of results.\n     * @param {string} [ListQueuesRequestParameters.queueNamePrefix] A string to use for filtering the list results. Only those queues whose name begins with the specified string are returned.\n     * @returns {Object}\n     * @returns {string[]} Object.queueUrls - A list of queue URLs, up to 1000 entries.\n     * @returns {string} [Object.nextToken] - In the future, you can use NextToken to request the next set of results.\n     */\n    listQueues(parameters: ListQueuesRequestParameters = {}): ListQueuesResponse {\n        const method = 'POST'\n\n        let body: any = {\n            Action: 'ListQueues',\n            Version: API_VERSION,\n        }\n\n        if (typeof(parameters?.maxResults) !== 'undefined') {\n            body = { ...body,\n                MaxResults: parameters.maxResults\n            }\n        }\n\n        if (typeof(parameters?.nextToken) !== 'undefined') {\n            body = { ...body,\n                NextToken: parameters.nextToken\n            }\n        }\n\n        if (typeof(parameters?.queueNamePrefix) !== 'undefined') {\n            body = { ...body,\n                QueueNamePrefix: parameters.queueNamePrefix\n            }\n        }\n\n        const signedRequest: SignedHTTPRequest = this.signature.sign(\n            {\n                method: 'POST',\n                protocol: this.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    'Host': this.host\n                },\n                body: toFormUrlEncoded(body)\n            },\n            {}\n        )\n\n        const res = http.request(method, signedRequest.url, signedRequest.body || '', {\n            headers: signedRequest.headers\n        })\n        this._handleError('ListQueues', res)\n\n        let parsed = res.html()\n        return {\n            urls: parsed.find('QueueUrl').toArray().map(e => e.text()),\n            nextToken: parsed.find('NextToken').text() || undefined\n        }\n    }\n\n    private _handleError(operation: SQSOperation, response: RefinedResponse<ResponseType | undefined>) {\n        const errorCode: number = response.error_code\n        const errorMessage: string = response.error\n\n        if (errorMessage == '' && errorCode === 0) {\n            return\n        }\n\n        const awsError = AWSError.parseXML(response.body as string)\n        switch (awsError.code) {\n            case 'AuthorizationHeaderMalformed':\n                throw new InvalidSignatureError(awsError.message, awsError.code)\n            default:\n                throw new SQSServiceError(awsError.message, awsError.code || 'unknown', operation)\n        }\n    }\n}\n\n/**\n * An Amazon SQS message.\n */\nexport class Message {\n    /**\n     * A unique identifier for the message.\n     * A MessageIdis considered unique across all AWS accounts for an extended period of time.\n     */\n    id: string\n\n    /**\n     * An MD5 digest of the non-URL-encoded message body string.\n     */\n    bodyMD5: string\n\n    /**\n     * Instantiates a new Message object.\n     *\n     * @param id\n     * @param md5Ofbody\n     */\n    constructor(id: string, bodyMD5: string) {\n        this.id = id\n        this.bodyMD5 = bodyMD5\n    }\n}\n\n/**\n * SQSServiceError indicates an error occurred while interacting with the SQS API.\n */\nexport class SQSServiceError extends AWSError {\n    operation: SQSOperation;\n\n    constructor(message: string, code: string, operation: SQSOperation) {\n        super(message, code)\n        this.name = 'SQSServiceError'\n        this.operation = operation\n    }\n}\n\n/**\n * SQSOperation describes possible SQS operations.\n */\ntype SQSOperation = 'ListQueues' | 'SendMessage'\n\nexport interface SendMessageOptions {\n    /*\n     * The message deduplication ID for FIFO queues\n    */\n    messageDeduplicationId?: string\n\n    /*\n     * The message group ID for FIFO queues\n     */\n    messageGroupId?: string\n}\n\nexport interface ListQueuesRequestParameters {\n    /**\n     * Maximum number of results to include in the response. Value range is 1 to 1000.\n     */\n    maxResults?: number\n    /**\n     * Pagination token to request the next set of results.\n     */\n    nextToken?: string\n    /**\n     * A string to use for filtering the list results. Only those queues whose name begins with the specified string are returned.\n     * Queue URLs and names are case-sensitive.\n     */\n    queueNamePrefix?: string\n}\n\nexport interface ListQueuesResponse {\n    /**\n     * A list of queue URLs, up to 1,000 entries, or the value of MaxResults you sent in the request.\n     */\n    urls: string[]\n    /**\n     * Pagination token to include in the next request.\n     */\n    nextToken?: string\n}\n"],"names":["AWSClient","awsConfig","serviceName","_classCallCheck","_defineProperty","this","key","get","undefined","_host","concat","region","endpoint","set","host","_scheme","scheme","AWSConfig","options","InvalidAWSConfigError","accessKeyId","length","secretAccessKey","sessionToken","_createClass","value","__ENV","AWS_REGION","AWS_ACCESS_KEY_ID","AWS_SECRET_ACCESS_KEY","AWS_SESSION_TOKEN","_Error","_inherits","_super","_createSuper","message","call","_wrapNativeSuper","Error","AMZ_ALGORITHM_QUERY_PARAM","AMZ_CREDENTIAL_QUERY_PARAM","AMZ_DATE_QUERY_PARAM","AMZ_EXPIRES_QUERY_PARAM","AMZ_SIGNATURE_QUERY_PARAM","AMZ_SIGNED_HEADERS_QUERY_PARAM","AMZ_TOKEN_QUERY_PARAM","AMZ_CONTENT_SHA256_HEADER","AMZ_DATE_HEADER","toLowerCase","AMZ_SIGNATURE_HEADER","AMZ_TOKEN_HEADER","AUTHORIZATION_HEADER","GENERATED_HEADERS","HOST_HEADER","ALWAYS_UNSIGNABLE_HEADERS","authorization","connection","expect","from","pragma","referer","te","trailer","upgrade","KEY_TYPE_IDENTIFIER","SIGNING_ALGORITHM_IDENTIFIER","MAX_PRESIGNED_TTL","EMPTY_SHA256","UNSIGNED_PAYLOAD","AWSError","code","_this","_assertThisInitialized","name","xmlDocument","doc","parseHTML","find","text","hasHeader","soughtHeader","headers","_i","_Object$keys","Object","keys","SignatureV4","_ref","service","credentials","uriEscapePath","applyChecksum","request","arguments","finalOptions","_objectSpread","signingDate","Date","unsignableHeaders","Set","signableHeaders","_formatDate","formatDate","longDate","shortDate","signingService","signingRegion","scope","constants","hostname","headerName","indexOf","ArrayBuffer","isView","body","buffer","payloadHash","computePayloadHash","canonicalHeaders","computeCanonicalHeaders","signature","calculateSignature","deriveSigningKey","createCanonicalRequest","sort","join","url","protocol","path","query","serializeQueryParameters","originalRequest","_options$signingDate","_options$expiresIn","expiresIn","unhoistableHeaders","_formatDate2","InvalidSignatureError","moveHeadersToQuery","toString","signingKey","canonicalRequest","sortedHeaders","sortedCanonicalHeaders","map","signedHeaders","method","computeCanonicalURI","computeCanonicalQuerystring","credentialScope","hashedCanonicalRequest","crypto","stringToSign","createStringToSign","kSecret","kDate","kRegion","kService","_ref2","_step","normalizedURISegments","_iterator","_createForOfIteratorHelper","split","s","n","done","URISegment","pop","push","err","e","f","leading","startsWith","URI","trailing","endsWith","normalizedURI","encodeURIComponent","replace","_ref3","_step2","_ref3$query","serialized","_loop","escapeURI","Array","isArray","slice","reduce","encoded","_iterator2","filter","_ref4","_step3","_iterator3","canonicalHeaderName","has","trim","_ref5","isArrayBuffer","requestCopy","JSON","parse","stringify","_requestCopy$query","_i2","_Object$keys2","_options$unhoistableH","lowerCaseName","ignoreKeys","_step4","_loop2","includes","_iterator4","_AWSError","c","charCodeAt","toUpperCase","date","time","Number","toDate","toISOString","prototype","toFormUrlEncoded","form","params","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","d","a","definition","o","defineProperty","enumerable","obj","prop","hasOwnProperty","r","Symbol","toStringTag","API_VERSION","SQSClient","_AWSClient","commonHeaders","queueUrl","messageBody","Action","Version","QueueUrl","MessageBody","messageDeduplicationId","MessageDeduplicationId","messageGroupId","MessageGroupId","signedRequest","sign","res","http","_handleError","parsed","html","Message","parameters","maxResults","MaxResults","nextToken","NextToken","queueNamePrefix","QueueNamePrefix","urls","toArray","operation","response","errorCode","error_code","error","awsError","parseXML","SQSServiceError","id","bodyMD5","_super2","_this2"],"sourceRoot":""}