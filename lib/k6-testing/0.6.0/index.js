import Ce from"k6/execution";function O(t,e,r,n="throw"){if(!t)if(r)if(n==="fail")Ce.test.fail(e);else throw new W(e);else Ce.test.abort(e)}var W=class extends Error{constructor(e){super(e),this.name="AssertionFailedError"}};function Ie(){let t=globalThis.Deno;return t?t.env.toObject():__ENV}var D=Ie(),S={hasValue(t){return D[t]!==void 0},boolean(t){let e=D[t]?.toLowerCase();if(e===void 0)throw new Error(`Environment variable ${t} is not set`);return e!=="false"},enum(t,e){let r=D[t]?.toLowerCase();if(r===void 0)throw new Error(`Environment variable ${t} is not set`);if(!e.includes(r))throw new Error(`Invalid value for ${t}. Must be one of: ${e.join(", ")}`);return r},number(t){let e=D[t];if(!e)throw new Error(`Environment variable ${t} is not set`);let r=Number(e);if(Number.isNaN(r)||!Number.isFinite(r))throw new Error(`Environment variable ${t} must be a valid number, got: ${e}`);if(r<0)throw new Error(`Environment variable ${t} must be a non-negative number, got: ${e}`);return r}};var q={timeout:5e3,interval:100},Te={...q,soft:!1,softMode:"throw",colorize:!0,display:"pretty",assertFn:O},j=class t{static load(e={}){let r=t.loadFromEnv();return{...Te,...e,...r}}static loadFromEnv(){let e={};return S.hasValue("K6_TESTING_COLORIZE")&&(e.colorize=S.boolean("K6_TESTING_COLORIZE")),S.hasValue("K6_TESTING_DISPLAY")&&(e.display=S.enum("K6_TESTING_DISPLAY",["inline","pretty"])),S.hasValue("K6_TESTING_TIMEOUT")&&(e.timeout=S.number("K6_TESTING_TIMEOUT")),S.hasValue("K6_TESTING_INTERVAL")&&(e.interval=S.number("K6_TESTING_INTERVAL")),S.hasValue("K6_TESTING_SOFT_MODE")&&(e.softMode=S.enum("K6_TESTING_SOFT_MODE",["throw","fail"])),e}};function N(t){if(!t||t.length<=1)return;let e=t[t.length-1],r=e.filePath,n=e.fileName,o=e.lineNumber,i=e.columnNumber,s=`${r}:${o}:${i}`;return{filePath:r,fileName:n,lineNumber:o,columnNumber:i,at:s}}function P(t){if(!t)return[];let e=t.split(`
`),r=[];for(let n=0;n<e.length;n++){let o=e[n].trim();if(n===0&&o.startsWith("Error")||!o.startsWith("at "))continue;o=o.slice(3).trim();let i="<anonymous>",s=o,a=o.indexOf("("),l=o.indexOf("file://");l===0?(i="<anonymous>",s=o.slice(l)):a>=0?(i=o.slice(0,a).trim()||"<anonymous>",s=o.slice(a+1,o.lastIndexOf(")")).trim()):s=o;let g=s.lastIndexOf("(");g>=0&&(s=s.slice(0,g)),s.startsWith("file://")&&(s=s.slice(7));let p=s.lastIndexOf(":");if(p===-1)continue;let u=s.lastIndexOf(":",p-1);if(u===-1)continue;let d=s.slice(0,u),f=d.split("/").pop()??"",y=s.slice(u+1,p),v=s.slice(p+1);r.push({functionName:i,filePath:d,fileName:f,lineNumber:parseInt(y,10),columnNumber:parseInt(v,10)})}return r}var Le={reset:"\x1B[0m",black:"\x1B[30m",red:"\x1B[31m",green:"\x1B[32m",yellow:"\x1B[33m",blue:"\x1B[34m",magenta:"\x1B[35m",cyan:"\x1B[36m",white:"\x1B[37m",brightBlack:"\x1B[90m",brightRed:"\x1B[91m",brightGreen:"\x1B[92m",brightYellow:"\x1B[93m",brightBlue:"\x1B[94m",brightMagenta:"\x1B[95m",brightCyan:"\x1B[96m",brightWhite:"\x1B[97m",darkGrey:"\x1B[90m"};function A(t,e){return`${Le[e]}${t}${Le.reset}`}var c=class{static renderers=new Map;static config={colorize:!0,display:"pretty"};static register(e,r){this.renderers.set(e,r)}static getRenderer(e){return this.renderers.get(e)||new G}static configure(e){this.config={...this.config,...e}}static getConfig(){return this.config}},V=class{getReceivedPlaceholder(){return"received"}getExpectedPlaceholder(){return"expected"}renderErrorLine(e,r){let n=(o,i)=>r.colorize?A(o,i):o;return"customMessage"in e&&typeof e.customMessage=="string"?n(e.customMessage,"white"):n("expect(","darkGrey")+n(this.getReceivedPlaceholder(),"red")+n(").","darkGrey")+n(this.getMatcherName(),"white")+this.renderMatcherArgs(n)}renderMatcherArgs(e){return e("()","darkGrey")}render(e,r){let n=(i,s)=>r.colorize?A(i,s):i,o=[{label:"Error",value:this.renderErrorLine(e,r),group:1},{label:"At",value:n(e.executionContext.at||"unknown location","darkGrey"),group:1},...this.getSpecificLines(e,n),{label:"Filename",value:n(e.executionContext.fileName,"darkGrey"),group:99},{label:"Line",value:n(e.executionContext.lineNumber.toString(),"darkGrey"),group:99}];return U.getFormatter(r.display).renderLines(o)}},R=class extends V{getSpecificLines(e,r){return[{label:"Received",value:r(e.received,"red"),group:2}]}},h=class extends V{getSpecificLines(e,r){return[{label:"Expected",value:r(e.expected,"green"),group:2},{label:"Received",value:r(e.received,"red"),group:2}]}renderMatcherArgs(e){return e("(","darkGrey")+e(this.getExpectedPlaceholder(),"green")+e(")","darkGrey")}},G=class{render(e,r){let n=(i,s)=>r.colorize?A(i,s):i,o=[{label:"Error",value:this.renderErrorLine(e,r),group:1},{label:"At",value:n(e.executionContext.at||"unknown location","darkGrey"),group:1},{label:"Expected",value:n(e.expected,"green"),group:2},{label:"Received",value:n(e.received,"red"),group:2},{label:"Filename",value:n(e.executionContext.fileName,"darkGrey"),group:3},{label:"Line",value:n(e.executionContext.lineNumber.toString(),"darkGrey"),group:3}];return U.getFormatter(r.display).renderLines(o)}renderErrorLine(e,r){let n=(o,i)=>r.colorize?A(o,i):o;return"customMessage"in e&&typeof e.customMessage=="string"?n(e.customMessage,"white"):n("expect(","darkGrey")+n("received","red")+n(").","darkGrey")+n(`${e.matcherName}`,"white")+n("(","darkGrey")+n("expected","green")+n(")","darkGrey")}},Y=class{renderLines(e){let r=Math.max(...e.filter(n=>!n.raw).map(({label:n})=>(n+":").length));return`

`+e.map(({label:n,value:o,raw:i},s)=>{let a;if(i)a=o;else{let g=n+":";a=" ".repeat(r-g.length)+g+" "+o}let l=e[s+1];return l&&e[s].group!==l.group?a+`
`:a}).join(`
`)+`

`}},Z=class{renderLines(e){return e.map(({label:r,value:n})=>{let o=typeof n=="string"&&n.includes(" ")?`"${n}"`:n;return`${r.toLowerCase().replace(/\s+/g,"_")}=${o}`}).join(" ")}},U=class{static formatters=new Map([["pretty",new Y],["inline",new Z]]);static getFormatter(e){let r=this.formatters.get(e);if(!r)throw new Error(`Unknown display format: ${e}`);return r}};function J(t,e,r,n=!1){let o=e.assertFn??O;c.configure({colorize:e.colorize,display:e.display}),c.register("toBe",new G),c.register("toBeCloseTo",new Q),c.register("toBeDefined",new X),c.register("toBeFalsy",new z),c.register("toBeGreaterThan",new ee),c.register("toBeGreaterThanOrEqual",new te),c.register("toBeInstanceOf",new re),c.register("toBeLessThan",new ne),c.register("toBeLessThanOrEqual",new oe),c.register("toBeNaN",new ie),c.register("toBeNull",new ae),c.register("toBeTruthy",new se),c.register("toBeUndefined",new ce),c.register("toEqual",new pe),c.register("toHaveLength",new le),c.register("toContain",new ue),c.register("toContainEqual",new de),c.register("toHaveProperty",new ge);let i={usedAssert:o,isSoft:e.soft,isNegated:n,message:r,softMode:e.softMode};return{get not(){return J(t,e,r,!n)},toBe(a){m("toBe",()=>Object.is(t,a),a,t,i)},toBeCloseTo(a,l=2){let g=Math.pow(10,-l)*Math.max(Math.abs(t),Math.abs(a)),p=Math.abs(t-a);m("toBeCloseTo",()=>p<g,a,t,{...i,matcherSpecific:{precision:l,difference:p,expectedDifference:g}})},toBeDefined(){m("toBeDefined",()=>t!==void 0,"defined",JSON.stringify(t),i)},toBeFalsy(){m("toBeFalsy",()=>!t,"falsy",JSON.stringify(t),i)},toBeGreaterThan(a){m("toBeGreaterThan",()=>t>a,a,t,i)},toBeGreaterThanOrEqual(a){m("toBeGreaterThanOrEqual",()=>t>=a,a,t,i)},toBeInstanceOf(a){m("toBeInstanceOf",()=>t instanceof a,a.name,t.constructor.name,i)},toBeLessThan(a){m("toBeLessThan",()=>t<a,a,t,i)},toBeLessThanOrEqual(a){m("toBeLessThanOrEqual",()=>t<=a,a,t,i)},toBeNaN(){m("toBeNaN",()=>isNaN(t),"NaN",JSON.stringify(t),i)},toBeNull(){m("toBeNull",()=>t===null,"null",JSON.stringify(t),i)},toBeTruthy(){m("toBeTruthy",()=>!!t,"truthy",JSON.stringify(t),i)},toBeUndefined(){m("toBeUndefined",()=>t===void 0,"undefined",JSON.stringify(t),i)},toEqual(a){m("toEqual",()=>_(t,a),JSON.stringify(a),JSON.stringify(t),i)},toHaveLength(a){m("toHaveLength",()=>t.length===a,a.toString(),t.length.toString(),i)},toContain(a){let l="";if(typeof t=="string")l="string";else if(Array.isArray(t))l="array";else if(t instanceof Set)l="set";else throw new Error("toContain is only supported for strings, arrays, and sets");m("toContain",()=>{if(typeof t=="string")return t.includes(a);if(Array.isArray(t))return t.includes(a);if(t instanceof Set)return Array.from(t).includes(a);throw new Error("toContain is only supported for strings, arrays, and sets")},a,t,{...i,matcherSpecific:{receivedType:l}})},toContainEqual(a){let l="";if(Array.isArray(t))l="array";else if(t instanceof Set)l="set";else throw new Error("toContainEqual is only supported for arrays and sets");m("toContainEqual",()=>{if(Array.isArray(t))return t.some(g=>_(g,a));if(t instanceof Set)return Array.from(t).some(g=>_(g,a));throw new Error("toContainEqual is only supported for arrays and sets")},a,t,{...i,matcherSpecific:{receivedType:l}})},toHaveProperty(a,l){if(typeof t!="object"||t===null)throw new Error("toHaveProperty is only supported for objects");m("toHaveProperty",()=>{try{let p=Be(t,a);return l!==void 0?_(p,l):!0}catch{return!1}},l!==void 0?l:a,t,{...i,matcherSpecific:{keyPath:a,hasExpectedValue:l!==void 0}})}}}function m(t,e,r,n,{usedAssert:o,isSoft:i,isNegated:s=!1,matcherSpecific:a={},message:l,softMode:g}){let p=Ae(t,r,n,{...a,isNegated:s},l),u=e();o(s?!u:u,c.getRenderer(t).render(p,c.getConfig()),i,g)}function Ae(t,e,r,n={},o){let i=P(new Error().stack),s=N(i);if(!s)throw new Error("k6 failed to capture execution context");return{executionContext:s,matcherName:t,expected:typeof e=="string"?e:JSON.stringify(e),received:typeof r=="string"?r:JSON.stringify(r),matcherSpecific:n,customMessage:o}}var Q=class extends h{getMatcherName(){return"toBeCloseTo"}getSpecificLines(e,r){let n=e.matcherSpecific;return[{label:"Expected precision",value:r(n.precision.toString(),"green"),group:3},{label:"Expected difference",value:"< "+r(`${n.expectedDifference}`,"green"),group:3},{label:"Received difference",value:r(n.difference.toString(),"red"),group:3}]}renderMatcherArgs(e){return e("(","darkGrey")+e("expected","green")+e(", ","darkGrey")+e("precision","white")+e(")","darkGrey")}},X=class extends R{getMatcherName(){return"toBeDefined"}},z=class extends R{getMatcherName(){return"toBeFalsy"}},ee=class extends h{getMatcherName(){return"toBeGreaterThan"}getSpecificLines(e,r){return[{label:"Expected",value:"> "+r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3}]}},te=class extends h{getMatcherName(){return"toBeGreaterThanOrEqual"}getSpecificLines(e,r){return[{label:"Expected",value:">= "+r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3}]}},re=class extends h{getMatcherName(){return"toBeInstanceOf"}getSpecificLines(e,r){return[{label:"Expected constructor",value:r(e.expected,"green"),group:3},{label:"Received constructor",value:r(e.received,"red"),group:3}]}},ne=class extends h{getMatcherName(){return"toBeLessThan"}getSpecificLines(e,r){return[{label:"Expected",value:"< "+r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3}]}},oe=class extends h{getMatcherName(){return"toBeLessThanOrEqual"}getSpecificLines(e,r){return[{label:"Expected",value:"<= "+r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3}]}},ie=class extends R{getMatcherName(){return"toBeNaN"}},ae=class extends R{getMatcherName(){return"toBeNull"}},se=class extends R{getMatcherName(){return"toBeTruthy"}},ce=class extends R{getMatcherName(){return"toBeUndefined"}},pe=class extends h{getMatcherName(){return"toEqual"}getSpecificLines(e,r){return[{label:"Expected",value:r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3}]}},le=class extends h{getMatcherName(){return"toHaveLength"}getSpecificLines(e,r){return[{label:"Expected length",value:r(e.expected,"green"),group:3},{label:"Received length",value:r(e.received,"red"),group:3},{label:"Received array",value:r(e.matcherSpecific?.receivedArray,"red"),group:3}]}},ue=class extends h{getMatcherName(){return"toContain"}getSpecificLines(e,r){let n=e.matcherSpecific?.isNegated,o=typeof e.matcherSpecific?.receivedType=="string"?e.matcherSpecific?.receivedType:Array.isArray(JSON.parse(e.received))?"array":"string";return[{label:n?"Expected not to contain":"Expected to contain",value:r(e.expected,"green"),group:3},{label:`Received ${o}`,value:r(e.received,"red"),group:3}]}},de=class extends h{getMatcherName(){return"toContainEqual"}getSpecificLines(e,r){let n=e.matcherSpecific?.isNegated,o=e.matcherSpecific?.receivedType;return[{label:n?"Expected not to contain equal":"Expected to contain equal",value:r(e.expected,"green"),group:3},{label:`Received ${o}`,value:r(e.received,"red"),group:3}]}},ge=class extends h{getMatcherName(){return"toHaveProperty"}getSpecificLines(e,r){let n=e.matcherSpecific?.isNegated,o=e.matcherSpecific?.keyPath,i=e.matcherSpecific?.hasExpectedValue,s=[{label:"Property path",value:r(o,"white"),group:3}];return i?s.push({label:n?"Expected property not to equal":"Expected property to equal",value:r(e.expected,"green"),group:3}):s.push({label:n?"Expected property not to exist":"Expected property to exist",value:"",group:3}),s.push({label:"Received object",value:r(e.received,"red"),group:3}),s}renderMatcherArgs(e){return e("(","darkGrey")+e("keyPath","white")+e(", ","darkGrey")+e("expected?","green")+e(")","darkGrey")}};function _(t,e){if(t===e)return!0;if(t===null||e===null||typeof t!="object"||typeof e!="object")return!1;let r=Object.keys(t),n=Object.keys(e);return r.length!==n.length?!1:r.every(o=>n.includes(o)&&_(t[o],e[o]))}function Be(t,e){if(e==="")throw new Error("Invalid path: empty string");let r=[],n="",o=!1;for(let s=0;s<e.length;s++){let a=e[s];if(a==="."&&!o)n&&(r.push(n),n="");else if(a==="[")n&&(r.push(n),n=""),o=!0;else if(a==="]")if(o)r.push(n),n="",o=!1;else throw new Error(`Invalid path: ${e}`);else n+=a}n&&r.push(n);let i=t;for(let s of r){if(i==null)throw new Error(`Property ${e} does not exist`);if(typeof s=="string"&&!isNaN(Number(s))){let a=Number(s);if(!Array.isArray(i))throw new Error(`Cannot access index ${s} of non-array`);if(a>=i.length)throw new Error(`Index ${s} out of bounds`);i=i[a]}else{if(typeof i!="object")throw new Error(`Cannot access property ${s} of non-object`);if(!Object.prototype.hasOwnProperty.call(i,s))throw new Error(`Property ${s} does not exist on object`);i=i[s]}}return i}function F(t){return t.replace(/[\u200B\u00AD]/g,"").replace(/\s+/g," ").trim()}function K(t){return{passed:!0,negate(){return B(typeof t.negate=="function"?t.negate():t.negate)}}}function B(t){let e=K({negate:()=>r.detail}),r={passed:!1,detail:t,negate:()=>e};return r}function I(t){if(!t||typeof t!="object")return!1;let e=["clear","isEnabled","isHidden","getAttribute","selectOption","press","type","dispatchEvent","dblclick","setChecked","isDisabled","focus","innerText","inputValue","check","isEditable","fill","textContent","hover","waitFor","click","uncheck","isChecked","isVisible","innerHTML","tap"],r=n=>e.every(o=>o in n);return t!=null&&typeof t=="object"&&r(t)}function $(t){if(!t||typeof t!="object")return!1;let e=["title","goto","url","close","mainFrame","waitForLoadState"],r=n=>e.every(o=>o in n);return t!=null&&typeof t=="object"&&r(t)}function Ge(t,e){return e===null?B({type:"expected-received",expected:`Attribute '${t}' to be present`,received:`Attribute '${t}' was not present`}):K({negate(){return{type:"expected-received",expected:`Attribute '${t}' to not be present`,received:`Attribute '${t}' was present`}}})}function _e(t,e,r){return e===null?B({type:"expected-received",expected:`Attribute '${t}' to have value '${r}'`,received:`Attribute '${t}' was not present`}):e!==r?B({type:"expected-received",expected:`Attribute '${t}' to have value '${r}'`,received:`Attribute '${t}' had value '${e}'`}):K({negate(){return{type:"expected-received",expected:`Attribute '${t}' to not have value '${r}'`,received:`Attribute '${t}' had value '${e}'`}}})}async function Ne(t,e,r){if(typeof e!="string"||e.trim()==="")throw new TypeError("Attribute name must be a non-empty string");if(r!==void 0&&typeof r!="string")throw new TypeError("Expected attribute value must be a string");if(!I(t))return B({type:"expected-received",expected:"Locator",received:t===null?"null":Array.isArray(t)?"any[]":typeof t});let n=await t.getAttribute(e);return r===void 0?Ge(e,n):_e(e,n,r)}function Pe(t,e,r,n=!1){let o=e.assertFn??O,i=e.soft??!1,s={timeout:e.timeout,interval:e.interval};c.configure({colorize:e.colorize,display:e.display}),c.register("toBeChecked",new fe),c.register("toBeDisabled",new xe),c.register("toBeEditable",new ye),c.register("toBeEmpty",new me),c.register("toBeEnabled",new he),c.register("toBeHidden",new Ee),c.register("toBeVisible",new be),c.register("toHaveValue",new ve);let a={locator:t,retryConfig:s,usedAssert:o,isSoft:i,isNegated:n,message:r,softMode:e.softMode},l=async(p,u,d={},f)=>{let y=P(new Error().stack),v=N(y);if(!v)throw new Error("k6 failed to capture execution context");let L=(x,b)=>{let w=d.ignoreCase!==void 0?new RegExp(x.source,x.flags.replace("i","")+(d.ignoreCase?"i":"")):x,k={executionContext:v,matcherName:p,expected:w.toString(),received:b,matcherSpecific:{isNegated:n},customMessage:r},M=w.test(b);o(n?!M:M,c.getRenderer(p).render(k,c.getConfig()),i,e.softMode)},E=(x,b)=>{let w=F(x),k=F(b),M={executionContext:v,matcherName:p,expected:w,received:k,matcherSpecific:{isNegated:n},customMessage:r},ke=d.ignoreCase?f(k.toLowerCase(),w.toLowerCase()):f(k,w);o(n?!ke:ke,c.getRenderer(p).render(M,c.getConfig()),i,e.softMode)};try{await H(async()=>{let x=d.useInnerText?await t.innerText():await t.textContent();if(x===null)throw new Error("Element has no text content");if(u instanceof RegExp){L(u,x);return}E(u,x)},{...s,...d})}catch{let b={executionContext:v,matcherName:p,expected:u.toString(),received:"unknown",matcherSpecific:{isNegated:n},customMessage:r};o(!1,c.getRenderer("toHaveText").render(b,c.getConfig()),i,e.softMode)}};return{get not(){return Pe(t,e,r,!n)},async toBeChecked(p=s){await T("toBeChecked",async()=>await t.isChecked(),"checked","unchecked",{...a,options:p})},async toBeDisabled(p=s){await T("toBeDisabled",async()=>await t.isDisabled(),"disabled","enabled",{...a,options:p})},async toBeEditable(p=s){await T("toBeEditable",async()=>await t.isEditable(),"editable","uneditable",{...a,options:p})},async toBeEmpty(p=s){await T("toBeEmpty",async()=>{try{return await t.inputValue().then(u=>u.length===0)}catch(u){let d="";if(u instanceof Error?d=u.toString():d=String(u),!d.includes("Node is not an <input>, <textarea> or <select> element"))throw u;return await t.textContent().then(f=>f==null?!0:f.trim().length===0)}},"empty","not empty",{...a,options:p})},async toBeEnabled(p=s){await T("toBeEnabled",async()=>await t.isEnabled(),"enabled","disabled",{...a,options:p})},async toBeHidden(p=s){await T("toBeHidden",async()=>await t.isHidden(),"hidden","visible",{...a,options:p})},async toBeVisible(p=s){await T("toBeVisible",async()=>await t.isVisible(),"visible","hidden",{...a,options:p})},toHaveText(p,u={}){return l("toHaveText",p,u,(d,f)=>d===f)},toContainText(p,u={}){return l("toContainText",p,u,(d,f)=>d.includes(f))},async toHaveAttribute(p,u){let d="toHaveAttribute",f=P(new Error().stack),y=N(f);if(!y)throw new Error("k6 failed to capture execution context");let v=c.getRenderer(d),L=c.getConfig();try{await H(async()=>{let E=await Ne(t,p,u),x=n?E.negate():E;if(x.passed)return;let b=x,w={executionContext:y,matcherName:d,expected:b.detail.expected,received:b.detail.received};o(!1,v.render(w,L),i,e.softMode)},s)}catch{let E={executionContext:y,matcherName:d,expected:"An element matching the locator.",received:`Timeout waiting for element matching locator (${s.timeout}ms)`};o(!1,c.getRenderer(d).render(E,c.getConfig()),i,e.softMode)}},async toHaveValue(p,u=s){let d=P(new Error().stack),f=N(d);if(!f)throw new Error("k6 failed to capture execution context");let y={executionContext:f,matcherName:"toHaveValue",expected:p,received:"unknown",matcherSpecific:{isNegated:n},customMessage:r};try{await H(async()=>{let v=await t.inputValue(),L=p===v;o(n?!L:L,c.getRenderer("toHaveValue").render(y,c.getConfig()),i,e.softMode)},{...s,...u})}catch{o(!1,c.getRenderer("toHaveValue").render(y,c.getConfig()),i,e.softMode)}}}}function Me(t,e,r,n=!1){let o=e.assertFn??O,i=e.soft??!1,s={timeout:e.timeout,interval:e.interval};c.configure({colorize:e.colorize,display:e.display}),c.register("toHaveTitle",new we);let a=async(g,p,u={},d)=>{let f=P(new Error().stack),y=N(f);if(!y)throw new Error("k6 failed to capture execution context");let v=(E,x)=>{let b=E,w={executionContext:y,matcherName:g,expected:b.toString(),received:x,matcherSpecific:{isNegated:n},customMessage:r},k=b.test(x);o(n?!k:k,c.getRenderer(g).render(w,c.getConfig()),i,e.softMode)},L=(E,x)=>{let b=F(E),w=F(x),k={executionContext:y,matcherName:g,expected:b,received:w,matcherSpecific:{isNegated:n},customMessage:r},M=d(w,b);o(n?!M:M,c.getRenderer(g).render(k,c.getConfig()),i,e.softMode)};try{await H(async()=>{let E=await t.title();if(p instanceof RegExp){v(p,E);return}L(p,E)},{...s,...u})}catch{let x={executionContext:y,matcherName:g,expected:p.toString(),received:"unknown",matcherSpecific:{isNegated:n},customMessage:r};o(!1,c.getRenderer("toHaveTitle").render(x,c.getConfig()),i,e.softMode)}};return{get not(){return Me(t,e,r,!n)},toHaveTitle(g,p={}){return a("toHaveTitle",g,p,(u,d)=>u===d)}}}function Re(t,e,r,n=!1){if($(t))return Me(t,e,r,n);if(I(t))return Pe(t,e,r,n);throw new Error("Invalid target for retrying expectation. Expected Locator or Page object.")}function Fe(t,e,r,n={},o){let i=P(new Error().stack),s=N(i);if(!s)throw new Error("k6 failed to capture execution context");return{executionContext:s,matcherName:t,expected:e,received:r,customMessage:o,...n}}async function T(t,e,r,n,{locator:o,retryConfig:i,usedAssert:s,isSoft:a,isNegated:l=!1,options:g={},message:p,softMode:u}){let d=Fe(t,r,n,{matcherSpecific:{locator:o,timeout:g.timeout,isNegated:l}},p);try{await H(async()=>{let f=await e(),y=l?!f:f;if(!y)throw new Error("matcher failed");s(y,c.getRenderer(t).render(d,c.getConfig()),a,u)},{...i,...g})}catch{s(!1,c.getRenderer(t).render(d,c.getConfig()),a,u)}}var C=class extends R{getMatcherName(){return`toBe${this.state[0].toUpperCase()}${this.state.slice(1)}`}getReceivedPlaceholder(){return"locator"}getSpecificLines(e,r){return[{label:"Expected",value:this.state,group:3},{label:"Received",value:this.oppositeState,group:3},{label:"Call log",value:"",group:3},{label:"",value:r(`  - expect.toBe${this.state[0].toUpperCase()}${this.state.slice(1)} with timeout ${e.matcherSpecific?.timeout}ms`,"darkGrey"),group:3,raw:!0},{label:"",value:r("  - waiting for locator","darkGrey"),group:3,raw:!0}]}},fe=class extends C{state="checked";oppositeState="unchecked"},xe=class extends C{state="disabled";oppositeState="enabled"},ye=class extends C{state="editable";oppositeState="uneditable"},me=class extends C{state="empty";oppositeState="not empty"},he=class extends C{state="enabled";oppositeState="disabled"},Ee=class extends C{state="hidden";oppositeState="visible"},be=class extends C{state="visible";oppositeState="hidden"},ve=class extends h{getMatcherName(){return"toHaveValue"}getSpecificLines(e,r){return[{label:"Expected",value:r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3},{label:"Call log",value:"",group:3},{label:"",value:r(`  - expect.toHaveValue with timeout ${e.matcherSpecific?.timeout}ms`,"darkGrey"),group:3,raw:!0},{label:"",value:r("  - waiting for locator","darkGrey"),group:3,raw:!0}]}},we=class extends h{getMatcherName(){return"pageExpectedReceived"}getSpecificLines(e,r){let n=e.matcherName;return[{label:"Expected",value:r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3},{label:"Call log",value:"",group:3},{label:"",value:r(`  - expect.${n}`,"darkGrey"),group:3,raw:!0},{label:"",value:r("  - waiting for page","darkGrey"),group:3,raw:!0}]}};async function H(t,e={}){let r=e.timeout??q.timeout,n=e.interval??q.interval,o=e._now??(()=>Date.now()),i=e._sleep??(a=>new Promise(l=>setTimeout(l,a))),s=o();for(;o()-s<r;){try{return await t(),!0}catch{}await i(n)}throw new Se(`Expect condition not met within ${r}ms timeout`)}var Se=class extends Error{constructor(e){super(e),this.name="RetryTimeoutError"}};var $e=Oe();function Oe(t){let e=j.load(t);return Object.assign(function(r,n){return I(r)||$(r)?Re(r,e,n):J(r,e,n)},{soft(r,n){return I(r)||$(r)?Re(r,{...e,soft:!0},n):J(r,{...e,soft:!0},n)},configure(r){return Oe(r)},get config(){return{...e}}})}export{A as colorize,$e as expect};
//# sourceMappingURL=index.js.map
