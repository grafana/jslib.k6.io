{
  "version": 3,
  "sources": ["../assert.ts", "../environment.ts", "../config.ts", "../execution.ts", "../stacktrace.ts", "../colors.ts", "../render.ts", "../expectNonRetrying.ts", "../expectRetrying.ts", "../expect.ts"],
  "sourcesContent": ["// NOTE (@oleiade): This is a shim for the k6/execution module, meaning that\n// imports of k6-execution-shim will be replaced with k6/execution in the\n// output bundle file.\n//\n// This allows us to avoid relying on the k6/execution module in the Deno runtime,\n// which is not compatible with the k6 runtime. Instead replacing it with a mock\n// implementation that does not abort the test. While making sure that we do replace\n// it with the real k6/execution module when bundling for the k6 runtime.\n//\n// It allows us to use the `deno test` command and unit tests in the Deno runtime. While\n// still being able to use the `k6 run` command and tests in the k6 runtime.\nimport exec from \"k6-execution-shim\";\n\n/**\n * assert is a function that checks a condition and fails the test if the condition is false.\n *\n * As a default, a failing assertion will immediately abort the whole test, exit with code 108, and\n * display an error message. If you want to continue the test after a failing assertion, you can pass\n * `true` as the third argument to `assert`.\n *\n * @param condition condition to assert the truthyness of\n * @param message the message to display if the condition is false\n * @param soft if true, the assertion will mark the test as failed without interrupting the execution\n */\nexport function assert(condition: boolean, message: string, soft?: boolean) {\n  if (condition) return;\n\n  if (soft) {\n    throw new AssertionFailedError(message);\n  } else {\n    // This will the k6-execution-shim module's abort method in the Deno runtime.\n    // It will instead be replaced with the k6/execution module's abort method\n    // in the output bundle file produced by esbuild specifically for the k6 runtime.\n    exec.test.abort(message);\n  }\n}\n\n/**\n * This indicates that an assertion failed.\n *\n * It is used to express a soft assertion's failure, as throwing will not abort the\n * test, and will instead fail the iteration.\n */\nexport class AssertionFailedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AssertionFailedError\";\n  }\n}\n", "// In the k6 runtime, the __ENV object is available and contains the environment variables.\nexport declare const __ENV: Record<string, string | undefined>;\n\n/**\n * Environment interface that matches the shape of k6's __ENV object.\n */\nexport interface Environment {\n  [key: string]: string | undefined;\n}\n\nfunction getEnvironment(): Environment {\n  // When running in Deno\n  if (typeof Deno !== \"undefined\") {\n    return Deno.env.toObject();\n  }\n\n  // When running in k6\n  return __ENV;\n}\n\n// Export a singleton instance of the environment object\nexport const env: Environment = getEnvironment();\n\n/**\n * Environment variable parser\n */\nexport const envParser = {\n  /**\n   * Check if an environment variable is set\n   */\n  hasValue(key: string): boolean {\n    return env[key] !== undefined;\n  },\n\n  /**\n   * Parse a boolean environment variable\n   * \"false\" (case insensitive) -> false\n   * anything else -> true\n   * @throws if value is undefined\n   */\n  boolean(key: string): boolean {\n    const value = env[key]?.toLowerCase();\n    if (value === undefined) {\n      throw new Error(`Environment variable ${key} is not set`);\n    }\n    return value !== \"false\";\n  },\n\n  /**\n   * Parse an environment variable that should match specific values\n   * @throws if value is undefined or doesn't match allowed values\n   */\n  enum<T extends string>(key: string, allowedValues: T[]): T {\n    const value = env[key]?.toLowerCase() as T;\n    if (value === undefined) {\n      throw new Error(`Environment variable ${key} is not set`);\n    }\n    if (!allowedValues.includes(value)) {\n      throw new Error(\n        `Invalid value for ${key}. Must be one of: ${allowedValues.join(\", \")}`,\n      );\n    }\n    return value;\n  },\n\n  /**\n   * Parses an environment variable as a non-negative number.\n   * @param name The name of the environment variable\n   * @throws Error if the value is not a valid non-negative number\n   * @returns The parsed number value\n   */\n  number(name: string): number {\n    const value = env[name];\n    if (!value) {\n      throw new Error(`Environment variable ${name} is not set`);\n    }\n\n    const parsed = Number(value);\n    if (Number.isNaN(parsed) || !Number.isFinite(parsed)) {\n      throw new Error(\n        `Environment variable ${name} must be a valid number, got: ${value}`,\n      );\n    }\n\n    if (parsed < 0) {\n      throw new Error(\n        `Environment variable ${name} must be a non-negative number, got: ${value}`,\n      );\n    }\n\n    return parsed;\n  },\n};\n", "import { assert } from \"./assert.ts\";\nimport { envParser } from \"./environment.ts\";\n\n/**\n * Options that can be set for the expect function.\n */\nexport interface ExpectConfig extends RenderConfig, RetryConfig {\n  /**\n   * Setting this option to true will make the assertions performed by expect\n   * to be always soft, meaning that they will not fail the test if the assertion\n   * is not met.\n   */\n  soft: boolean;\n\n  /**\n   * Optional custom assertion function to be used instead of the default assert function.\n   *\n   * This function should have the same signature as the assert function.\n   */\n  assertFn?: (...args: Parameters<typeof import(\"./assert.ts\").assert>) => void;\n}\n\n/**\n * The configuration for the retry behavior.\n */\nexport interface RetryConfig {\n  /**\n   * Maximum amount of time to retry in milliseconds.\n   * @default 5000\n   */\n  timeout?: number;\n\n  /**\n   * Time between retries in milliseconds.\n   * @default 100\n   */\n  interval?: number;\n}\n\nexport const DEFAULT_RETRY_OPTIONS: Required<RetryConfig> = {\n  // 5 seconds default timeout\n  timeout: 5000,\n  // 100ms between retries\n  interval: 100,\n};\n\n/**\n * The configuration for the renderer.\n */\nexport interface RenderConfig {\n  /**\n   * Setting this option to false will disable the colorization of the output of the\n   * expect function. The default is true.\n   */\n  colorize: boolean;\n\n  /**\n   * Expectations can be displayed in two different ways: inline or pretty.\n   * The default is pretty.\n   *\n   * When displayed inline, the expectation will be displayed in a single line, to\n   * make it easier to interpret the output when written to logs.\n   *\n   * When displayed pretty, the expectation will be displayed in a more human-readable\n   * format, with each part of the expectation in a separate line.\n   */\n  display: DisplayFormat;\n}\n\n/**\n * The display format to use.\n *\n * \"pretty\" is the default format and outputs in a human readable format with aligned columns.\n * \"inline\" is a logfmt style format that outputs in a single line.\n */\nexport type DisplayFormat = \"inline\" | \"pretty\";\n\n/**\n * Default configuration values, without any environment overrides\n */\nexport const DEFAULT_CONFIG: ExpectConfig = {\n  ...DEFAULT_RETRY_OPTIONS,\n  soft: false,\n  colorize: true,\n  display: \"pretty\",\n  assertFn: assert,\n};\n\n/**\n * Configuration loader that handles different sources of configuration\n * with clear precedence rules\n */\nexport class ConfigLoader {\n  /**\n   * Loads configuration with the following precedence (highest to lowest):\n   * 1. Environment variables\n   * 2. Explicit configuration passed to the function\n   * 3. Default values\n   */\n  static load(explicitConfig: Partial<ExpectConfig> = {}): ExpectConfig {\n    const envConfig = ConfigLoader.loadFromEnv();\n\n    return {\n      ...DEFAULT_CONFIG,\n      ...explicitConfig,\n      ...envConfig,\n    };\n  }\n\n  /**\n   * Loads configuration from environment variables\n   * Returns only the values that are explicitly set in the environment\n   */\n  private static loadFromEnv(): Partial<ExpectConfig> {\n    const config: Partial<ExpectConfig> = {};\n\n    // Load colorize from environment variable\n    if (envParser.hasValue(\"K6_TESTING_COLORIZE\")) {\n      config.colorize = envParser.boolean(\"K6_TESTING_COLORIZE\");\n    }\n\n    // Load display from environment variable\n    if (envParser.hasValue(\"K6_TESTING_DISPLAY\")) {\n      config.display = envParser.enum<DisplayFormat>(\n        \"K6_TESTING_DISPLAY\",\n        [\"inline\", \"pretty\"],\n      );\n    }\n\n    // Load timeout from environment variable\n    if (envParser.hasValue(\"K6_TESTING_TIMEOUT\")) {\n      config.timeout = envParser.number(\"K6_TESTING_TIMEOUT\");\n    }\n\n    // Load interval from environment variable\n    if (envParser.hasValue(\"K6_TESTING_INTERVAL\")) {\n      config.interval = envParser.number(\"K6_TESTING_INTERVAL\");\n    }\n\n    return config;\n  }\n}\n", "import type { StackFrame, Stacktrace } from \"./stacktrace.ts\";\n\n/**\n * Holds the execution context for a given assertion, and is used to render the error message.\n */\nexport interface ExecutionContext {\n  /**\n   * The file path where the assertion was called. e.g. \"/some/path.ts\".\n   */\n  filePath: string;\n\n  /**\n   * The file name where the assertion was called. e.g. \"path.ts\".\n   */\n  fileName: string;\n\n  /**\n   * The line number within `filename` where the assertion was called. e.g. 42.\n   */\n  lineNumber: number;\n\n  /**\n   * The column number within `filename` where the assertion was called. e.g. 24.\n   */\n  columnNumber: number;\n\n  /**\n   * The location of the assertion. e.g. \"/some/path.ts:124:12\".\n   */\n  at: string;\n\n  /**\n   * The stacktrace this execution context was captured from.\n   */\n  stacktrace?: Stacktrace;\n}\n\n/**\n * Captures the execution context from the provided stacktrace.\n *\n * If no stacktrace is provided, the execution context is not captured and the function returns `undefined`.\n *\n * @param stacktrace - The stacktrace to capture the execution context from, as returned by `new Error().stack`.\n * @returns the execution context\n */\nexport function captureExecutionContext(\n  st: Stacktrace,\n): ExecutionContext | undefined {\n  if (!st || st.length <= 1) {\n    return undefined;\n  }\n\n  const stackFrame: StackFrame = st[st.length - 1];\n\n  const filePath = stackFrame.filePath;\n  const fileName = stackFrame.fileName;\n  const lineNumber = stackFrame.lineNumber;\n  const columnNumber = stackFrame.columnNumber;\n  const at = `${filePath}:${lineNumber}:${columnNumber}`;\n\n  return {\n    filePath,\n    fileName,\n    lineNumber,\n    columnNumber,\n    at,\n  };\n}\n", "/**\n * A stacktrace, represented as an array of stack frames.\n */\nexport type Stacktrace = StackFrame[];\n\n/**\n * A single frame in a stacktrace.\n */\nexport interface StackFrame {\n  // Name of the function, if any.\n  functionName: string;\n\n  // The full path to the file, if any.\n  filePath: string;\n\n  // Name of the file, if any.\n  fileName: string;\n\n  // Line number in the file, if any.\n  lineNumber: number;\n\n  // Column number in the file, if any.\n  columnNumber: number;\n}\n\n/**\n * Parses a stacktrace from a string.\n *\n * If no stacktrace is provided, returns an empty array.\n *\n * @param stack the stacktrace to parse, as returned by `new Error().stack`\n * @returns the parsed stacktrace\n */\nexport function parseStackTrace(stack?: string): Stacktrace {\n  // If no stacktrace is provided, return an empty array.\n  if (!stack) return [];\n\n  const lines = stack.split(\"\\n\");\n  const frames: StackFrame[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    let lineStr = lines[i].trim();\n\n    // Skip the first line if it's \"Error\" or any line that doesn't start with \"at \"\n    if (i === 0 && lineStr.startsWith(\"Error\")) continue;\n    if (!lineStr.startsWith(\"at \")) continue;\n\n    // Remove \"at \"\n    lineStr = lineStr.slice(3).trim();\n\n    // 1. Separate the function name from file info\n    let functionName = \"<anonymous>\";\n    let fileInfo = lineStr;\n    const firstParenIndex = lineStr.indexOf(\"(\");\n    const fileProtocolIndex = lineStr.indexOf(\"file://\");\n\n    if (fileProtocolIndex === 0) {\n      functionName = \"<anonymous>\";\n      fileInfo = lineStr.slice(fileProtocolIndex);\n    } else if (firstParenIndex >= 0) {\n      functionName = lineStr.slice(0, firstParenIndex).trim() || \"<anonymous>\";\n      fileInfo = lineStr\n        .slice(firstParenIndex + 1, lineStr.lastIndexOf(\")\"))\n        .trim();\n    } else {\n      fileInfo = lineStr;\n    }\n\n    // 2. Remove any trailing \"(X)\" offset\n    const offsetParenIndex = fileInfo.lastIndexOf(\"(\");\n    if (offsetParenIndex >= 0) {\n      fileInfo = fileInfo.slice(0, offsetParenIndex);\n    }\n\n    // 3. Handle file:// protocol\n    if (fileInfo.startsWith(\"file://\")) {\n      fileInfo = fileInfo.slice(7);\n    }\n\n    // 4. Separate file, line, and column\n    const lastColon = fileInfo.lastIndexOf(\":\");\n    if (lastColon === -1) continue; // Malformed\n    const secondLastColon = fileInfo.lastIndexOf(\":\", lastColon - 1);\n    if (secondLastColon === -1) continue; // Malformed\n\n    const filePath = fileInfo.slice(0, secondLastColon);\n    const fileName = filePath.split(\"/\").pop() ?? \"\";\n    const lineNumberStr = fileInfo.slice(secondLastColon + 1, lastColon);\n    const columnNumberStr = fileInfo.slice(lastColon + 1);\n\n    frames.push({\n      functionName,\n      filePath,\n      fileName,\n      lineNumber: parseInt(lineNumberStr, 10),\n      columnNumber: parseInt(columnNumberStr, 10),\n    });\n  }\n\n  return frames;\n}\n", "export const ANSI_COLORS = {\n  reset: \"\\x1b[0m\",\n\n  // Standard Colors\n  black: \"\\x1b[30m\",\n  red: \"\\x1b[31m\",\n  green: \"\\x1b[32m\",\n  yellow: \"\\x1b[33m\",\n  blue: \"\\x1b[34m\",\n  magenta: \"\\x1b[35m\",\n  cyan: \"\\x1b[36m\",\n  white: \"\\x1b[37m\",\n\n  // Bright Colors\n  brightBlack: \"\\x1b[90m\",\n  brightRed: \"\\x1b[91m\",\n  brightGreen: \"\\x1b[92m\",\n  brightYellow: \"\\x1b[93m\",\n  brightBlue: \"\\x1b[94m\",\n  brightMagenta: \"\\x1b[95m\",\n  brightCyan: \"\\x1b[96m\",\n  brightWhite: \"\\x1b[97m\",\n\n  // Dark Colors\n  darkGrey: \"\\x1b[90m\",\n} as const;\n\nexport function colorize(\n  text: string | undefined,\n  color: keyof typeof ANSI_COLORS,\n): string {\n  return `${ANSI_COLORS[color]}${text}${ANSI_COLORS.reset}`;\n}\n", "import type { ExecutionContext } from \"./execution.ts\";\nimport { type ANSI_COLORS, colorize } from \"./colors.ts\";\nimport type { DisplayFormat, RenderConfig } from \"./config.ts\";\n\n/**\n * The interface that all matchers error renderers must implement.\n */\nexport interface MatcherErrorRenderer {\n  render(info: RenderedErrorInfo, config: RenderConfig): string;\n}\n\n/**\n * The data structure holding all info to be rendered when a matcher fails.\n *\n * Because some matchers require additional info to be rendered, we use a generic type\n * to allow for additional properties to be added to the info structure.\n */\nexport interface MatcherErrorInfo extends RenderedErrorInfo {\n  matcherSpecific?: Record<string, unknown>;\n  customMessage?: string;\n}\n\n/**\n * The data structure holding all info to be rendered.\n */\nexport interface RenderedErrorInfo {\n  // The execution context of the assertion, holding the file name, line number, and column number\n  // where the assertion was called.\n  executionContext: ExecutionContext;\n\n  // This would be something like: \"expect(received).toBe(expected)\"\n  // plus color info or text appended for extra context.\n  matcherName: string;\n\n  // The underlying operation that was used to make the assertion. e.g. \"Object.is\".\n  matcherOperation?: string;\n\n  // The expected value. e.g. \"false\".\n  expected: string;\n\n  // The received value. e.g. \"true\".\n  received: string;\n\n  // The stacktrace of the assertion. e.g. \"Error\".\n  stacktrace?: string;\n}\n\n/**\n * A registry of matchers error renderers.\n */\nexport class MatcherErrorRendererRegistry {\n  private static renderers: Map<string, MatcherErrorRenderer> = new Map();\n  private static config: RenderConfig = { colorize: true, display: \"pretty\" };\n\n  static register(matcherName: string, renderer: MatcherErrorRenderer) {\n    this.renderers.set(matcherName, renderer);\n  }\n\n  static getRenderer(matcherName: string): MatcherErrorRenderer {\n    return this.renderers.get(matcherName) || new DefaultMatcherErrorRenderer();\n  }\n\n  static configure(config: RenderConfig) {\n    this.config = { ...this.config, ...config };\n  }\n\n  static getConfig(): RenderConfig {\n    return this.config;\n  }\n}\n\n/**\n * Base class for all matcher error renderers that implements common functionality\n */\nexport abstract class BaseMatcherErrorRenderer implements MatcherErrorRenderer {\n  protected getReceivedPlaceholder(): string {\n    return \"received\";\n  }\n\n  protected getExpectedPlaceholder(): string {\n    return \"expected\";\n  }\n\n  protected abstract getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[];\n\n  protected abstract getMatcherName(): string;\n\n  protected renderErrorLine(\n    info: RenderedErrorInfo,\n    config: RenderConfig,\n  ): string {\n    const maybeColorize = (text: string, color: keyof typeof ANSI_COLORS) =>\n      config.colorize ? colorize(text, color) : text;\n\n    if (\"customMessage\" in info && typeof info.customMessage === \"string\") {\n      return maybeColorize(info.customMessage, \"white\");\n    }\n\n    return maybeColorize(`expect(`, \"darkGrey\") +\n      maybeColorize(this.getReceivedPlaceholder(), \"red\") +\n      maybeColorize(`).`, \"darkGrey\") +\n      maybeColorize(this.getMatcherName(), \"white\") +\n      this.renderMatcherArgs(maybeColorize);\n  }\n\n  protected renderMatcherArgs(\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): string {\n    return maybeColorize(`()`, \"darkGrey\");\n  }\n\n  render(info: MatcherErrorInfo, config: RenderConfig): string {\n    const maybeColorize = (text: string, color: keyof typeof ANSI_COLORS) =>\n      config.colorize ? colorize(text, color) : text;\n\n    const lines: LineGroup[] = [\n      { label: \"Error\", value: this.renderErrorLine(info, config), group: 1 },\n      {\n        label: \"At\",\n        value: maybeColorize(\n          info.executionContext.at || \"unknown location\",\n          \"darkGrey\",\n        ),\n        group: 1,\n      },\n\n      ...this.getSpecificLines(info, maybeColorize),\n\n      {\n        label: \"Filename\",\n        value: maybeColorize(info.executionContext.fileName, \"darkGrey\"),\n        group: 99,\n      },\n      {\n        label: \"Line\",\n        value: maybeColorize(\n          info.executionContext.lineNumber.toString(),\n          \"darkGrey\",\n        ),\n        group: 99,\n      },\n    ];\n\n    return DisplayFormatRegistry.getFormatter(config.display).renderLines(\n      lines,\n    );\n  }\n}\n\n/**\n * Base class for matchers that only show the received value\n */\nexport abstract class ReceivedOnlyMatcherRenderer\n  extends BaseMatcherErrorRenderer {\n  protected getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 2,\n      },\n    ];\n  }\n}\n\n/**\n * Base class for matchers that show both expected and received values\n */\nexport abstract class ExpectedReceivedMatcherRenderer\n  extends BaseMatcherErrorRenderer {\n  protected getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 2,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 2,\n      },\n    ];\n  }\n\n  protected override renderMatcherArgs(\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): string {\n    return maybeColorize(`(`, \"darkGrey\") +\n      maybeColorize(this.getExpectedPlaceholder(), \"green\") +\n      maybeColorize(`)`, \"darkGrey\");\n  }\n}\n\n/**\n * The default matcher error renderer.\n */\nexport class DefaultMatcherErrorRenderer implements MatcherErrorRenderer {\n  render(info: RenderedErrorInfo, config: RenderConfig): string {\n    const maybeColorize = (text: string, color: keyof typeof ANSI_COLORS) =>\n      config.colorize ? colorize(text, color) : text;\n    const lines: LineGroup[] = [\n      { label: \"Error\", value: this.renderErrorLine(info, config), group: 1 },\n      {\n        label: \"At\",\n        value: maybeColorize(\n          info.executionContext.at || \"unknown location\",\n          \"darkGrey\",\n        ),\n        group: 1,\n      },\n\n      {\n        label: \"Expected\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 2,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 2,\n      },\n\n      {\n        label: \"Filename\",\n        value: maybeColorize(info.executionContext.fileName, \"darkGrey\"),\n        group: 3,\n      },\n      {\n        label: \"Line\",\n        value: maybeColorize(\n          info.executionContext.lineNumber.toString(),\n          \"darkGrey\",\n        ),\n        group: 3,\n      },\n    ];\n\n    return DisplayFormatRegistry.getFormatter(config.display).renderLines(\n      lines,\n    );\n  }\n\n  protected renderErrorLine(\n    info: RenderedErrorInfo,\n    config: RenderConfig,\n  ): string {\n    const maybeColorize = (text: string, color: keyof typeof ANSI_COLORS) =>\n      config.colorize ? colorize(text, color) : text;\n    return maybeColorize(`expect(`, \"darkGrey\") +\n      maybeColorize(`received`, \"red\") +\n      maybeColorize(`).`, \"darkGrey\") +\n      maybeColorize(`${info.matcherName}`, \"white\") +\n      maybeColorize(`(`, \"darkGrey\") +\n      maybeColorize(`expected`, \"green\") +\n      maybeColorize(`)`, \"darkGrey\");\n  }\n}\n\ninterface DisplayFormatRenderer {\n  renderLines(lines: LineGroup[]): string;\n}\n\n/**\n * Pretty format renderer that groups and aligns output\n *\n * Note that any stylization of the lines, such as colorization is expected to\n * be done by the caller.\n */\nclass PrettyFormatRenderer implements DisplayFormatRenderer {\n  renderLines(lines: LineGroup[]): string {\n    const maxLabelWidth = Math.max(\n      ...lines\n        .filter((line) => !line.raw)\n        .map(({ label }: { label: string }) => (label + \":\").length),\n    );\n\n    return \"\\n\\n\" + lines\n      .map(({ label, value, raw }, index) => {\n        let line: string;\n        if (raw) {\n          line = value;\n        } else {\n          const labelWithColon = label + \":\";\n          const spaces = \" \".repeat(maxLabelWidth - labelWithColon.length);\n          line = spaces + labelWithColon + \" \" + value;\n        }\n\n        // Add newlines before a new group of lines (except for the first group)\n        const nextLine = lines[index + 1];\n        if (nextLine && lines[index].group !== nextLine.group) {\n          return line + \"\\n\";\n        }\n        return line;\n      })\n      .join(\"\\n\") +\n      \"\\n\\n\";\n  }\n}\n\n/**\n * Inline format renderer that outputs in logfmt style\n */\nclass InlineFormatRenderer implements DisplayFormatRenderer {\n  renderLines(lines: LineGroup[]): string {\n    return lines\n      .map(({ label, value }) => {\n        // Escape any spaces or special characters in the value\n        const escapedValue = typeof value === \"string\"\n          ? value.includes(\" \") ? `\"${value}\"` : value\n          : value;\n        // Convert label to lowercase and replace spaces with underscores\n        const escapedLabel = label.toLowerCase().replace(/\\s+/g, \"_\");\n        return `${escapedLabel}=${escapedValue}`;\n      })\n      .join(\" \");\n  }\n}\n\nclass DisplayFormatRegistry {\n  private static formatters: Map<DisplayFormat, DisplayFormatRenderer> =\n    new Map([\n      [\"pretty\", new PrettyFormatRenderer()],\n      [\"inline\", new InlineFormatRenderer()],\n    ]);\n\n  static getFormatter(format: DisplayFormat): DisplayFormatRenderer {\n    const formatter = this.formatters.get(format);\n    if (!formatter) {\n      throw new Error(`Unknown display format: ${format}`);\n    }\n    return formatter;\n  }\n}\n\n/**\n * A line with a label and a value.\n *\n * The label is the text before the colon, and the value is the text after the colon.\n *\n * The group number is used to align the lines at the same column and group them into\n * newline separated sections.\n */\nexport interface LineGroup {\n  // The label of the line.\n  label: string;\n\n  // The value of the line.\n  value: string;\n\n  // The group number of the line. Lines with the same group number are aligned at the same column.\n  group?: number;\n\n  // If true, the line is not formatted and is output as raw text.\n  raw?: boolean;\n}\n", "import { assert } from \"./assert.ts\";\nimport type { ANSI_COLORS } from \"./colors.ts\";\nimport type { ExpectConfig } from \"./config.ts\";\nimport { captureExecutionContext } from \"./execution.ts\";\nimport { parseStackTrace } from \"./stacktrace.ts\";\nimport {\n  DefaultMatcherErrorRenderer,\n  ExpectedReceivedMatcherRenderer,\n  type LineGroup,\n  type MatcherErrorInfo,\n  MatcherErrorRendererRegistry,\n  ReceivedOnlyMatcherRenderer,\n} from \"./render.ts\";\n\nexport interface NonRetryingExpectation {\n  /**\n   * Negates the expectation, causing the assertion to pass when it would normally fail, and vice versa.\n   */\n  not: NonRetryingExpectation;\n\n  /**\n   * Asserts that the value is equal to the expected value.\n   *\n   * @param expected the expected value\n   */\n  toBe(expected: unknown): void;\n\n  /**\n   * Asserts that the value is close to the expected value with a given precision.\n   *\n   * @param expected the expected value\n   * @param precision the number of decimal places to consider\n   */\n  toBeCloseTo(expected: number, precision?: number): void;\n\n  /**\n   * Asserts that the value is not `undefined`.\n   */\n  toBeDefined(): void;\n\n  /**\n   * Asserts that the value is truthy.\n   */\n  toBeFalsy(): void;\n\n  /**\n   * Asserts that the value is greater than the expected value.\n   *\n   * @param expected the expected value\n   */\n  toBeGreaterThan(expected: number): void;\n\n  /**\n   * Asserts that the value is greater than or equal to the expected value.\n   *\n   * @param expected\n   */\n  toBeGreaterThanOrEqual(expected: number): void;\n\n  /**\n   * Ensures that value is an instance of a class. Uses instanceof operator.\n   *\n   * @param expected The class or constructor function.\n   */\n  // deno-lint-ignore ban-types\n  toBeInstanceOf(expected: Function): void;\n\n  /**\n   * Asserts that the value is less than the expected value.\n   *\n   * @param expected the expected value\n   */\n  toBeLessThan(expected: number): void;\n\n  /**\n   * Ensures that value <= expected for number or big integer values.\n   *\n   * @param expected The value to compare to.\n   */\n  toBeLessThanOrEqual(expected: number | bigint): void;\n\n  /**\n   * Ensures that value is NaN.\n   */\n  toBeNaN(): void;\n\n  /**\n   * Ensures that value is null.\n   */\n  toBeNull(): void;\n\n  /**\n   * Ensures that value is true in a boolean context, anything but false, 0, '', null, undefined or NaN.\n   * Use this method when you don't care about the specific value.\n   */\n  toBeTruthy(): void;\n\n  /**\n   * Ensures that value is `undefined`.\n   */\n  toBeUndefined(): void;\n\n  /**\n   * Asserts that the value is equal to the expected value.\n   *\n   * @param expected the expected value\n   */\n  toEqual(expected: unknown): void;\n\n  /**\n   * Ensures that value has a `.length` property equal to expected.\n   * Useful for arrays and strings.\n   *\n   * @param expected\n   */\n  toHaveLength(expected: number): void;\n\n  /**\n   * Ensures that a string contains an expected substring using a case-sensitive comparison,\n   * or that an Array or Set contains an expected item.\n   *\n   * @param expected The substring or item to check for\n   */\n  toContain(expected: unknown): void;\n\n  /**\n   * Ensures that value is an Array or Set and contains an item equal to the expected.\n   *\n   * For objects, this method recursively checks equality of all fields, rather than comparing objects by reference.\n   * For primitive values, this method is equivalent to expect(value).toContain().\n   *\n   * @param expected The item to check for deep equality within the collection\n   */\n  toContainEqual(expected: unknown): void;\n\n  /**\n   * Ensures that property at provided `keyPath` exists on the object and optionally checks\n   * that property is equal to the expected. Equality is checked recursively, similarly to expect(value).toEqual().\n   *\n   * @param keyPath Path to the property. Use dot notation a.b to check nested properties\n   *                and indexed a[2] notation to check nested array items.\n   * @param expected Optional expected value to compare the property to.\n   */\n  toHaveProperty(keyPath: string, expected?: unknown): void;\n}\n\n/**\n * createExpectation is a factory function that creates an expectation object for a given value.\n *\n * It effectively implements the NonRetryingExpectation interface, and provides the actual\n * implementation of the matchers attached to the expectation object.\n *\n * @param received the value to create an expectation for\n * @param config the configuration for the expectation\n * @param message the optional custom message for the expectation\n * @param isNegated whether the expectation is negated\n * @returns an expectation object over the given value exposing the Expectation set of methods\n */\nexport function createExpectation(\n  received: unknown,\n  config: ExpectConfig,\n  message?: string,\n  isNegated: boolean = false,\n): NonRetryingExpectation {\n  // In order to facilitate testing, we support passing in a custom assert function.\n  // As a result, we need to make sure that the assert function is always available, and\n  // if not, we need to use the default assert function.\n  //\n  // From this point forward, we will use the `usedAssert` variable to refer to the assert function.\n  const usedAssert = config.assertFn ?? assert;\n\n  // Configure the renderer with the colorize option.\n  MatcherErrorRendererRegistry.configure({\n    colorize: config.colorize,\n    display: config.display,\n  });\n\n  // Register renderers specific to each matchers at initialization time.\n  MatcherErrorRendererRegistry.register(\n    \"toBe\",\n    new DefaultMatcherErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeCloseTo\",\n    new ToBeCloseToErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeDefined\",\n    new ToBeDefinedErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeFalsy\",\n    new ToBeFalsyErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeGreaterThan\",\n    new ToBeGreaterThanErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeGreaterThanOrEqual\",\n    new ToBeGreaterThanOrEqualErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeInstanceOf\",\n    new ToBeInstanceOfErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeLessThan\",\n    new ToBeLessThanErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeLessThanOrEqual\",\n    new ToBeLessThanOrEqualErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\"toBeNaN\", new ToBeNaNErrorRenderer());\n  MatcherErrorRendererRegistry.register(\n    \"toBeNull\",\n    new ToBeNullErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeTruthy\",\n    new ToBeTruthyErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeUndefined\",\n    new ToBeUndefinedErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\"toEqual\", new ToEqualErrorRenderer());\n  MatcherErrorRendererRegistry.register(\n    \"toHaveLength\",\n    new ToHaveLengthErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toContain\",\n    new ToContainErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toContainEqual\",\n    new ToContainEqualErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toHaveProperty\",\n    new ToHavePropertyErrorRenderer(),\n  );\n\n  const matcherConfig = {\n    usedAssert,\n    isSoft: config.soft,\n    isNegated,\n    message,\n  };\n\n  const expectation: NonRetryingExpectation = {\n    get not(): NonRetryingExpectation {\n      return createExpectation(received, config, message, !isNegated);\n    },\n\n    toBe(expected: unknown): void {\n      createMatcher(\n        \"toBe\",\n        () => Object.is(received, expected),\n        expected,\n        received,\n        matcherConfig,\n      );\n    },\n\n    toBeCloseTo(expected: number, precision: number = 2): void {\n      const tolerance = Math.pow(10, -precision) *\n        Math.max(Math.abs(received as number), Math.abs(expected));\n      const diff = Math.abs((received as number) - expected);\n\n      createMatcher(\n        \"toBeCloseTo\",\n        () => diff < tolerance,\n        expected,\n        received,\n        {\n          ...matcherConfig,\n          matcherSpecific: {\n            precision,\n            difference: diff,\n            expectedDifference: tolerance,\n          },\n        },\n      );\n    },\n\n    toBeDefined(): void {\n      createMatcher(\n        \"toBeDefined\",\n        () => received !== undefined,\n        \"defined\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toBeFalsy(): void {\n      createMatcher(\n        \"toBeFalsy\",\n        () => !received,\n        \"falsy\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toBeGreaterThan(expected: number | bigint): void {\n      createMatcher(\n        \"toBeGreaterThan\",\n        () => (received as number) > expected,\n        expected,\n        received,\n        matcherConfig,\n      );\n    },\n\n    toBeGreaterThanOrEqual(expected: number | bigint): void {\n      createMatcher(\n        \"toBeGreaterThanOrEqual\",\n        () => (received as number) >= expected,\n        expected,\n        received,\n        matcherConfig,\n      );\n    },\n\n    // deno-lint-ignore ban-types\n    toBeInstanceOf(expected: Function): void {\n      createMatcher(\n        \"toBeInstanceOf\",\n        () => received instanceof expected,\n        expected.name,\n        (received as { constructor: { name: string } }).constructor.name,\n        matcherConfig,\n      );\n    },\n\n    toBeLessThan(expected: number | bigint): void {\n      createMatcher(\n        \"toBeLessThan\",\n        () => (received as number) < expected,\n        expected,\n        received,\n        matcherConfig,\n      );\n    },\n\n    toBeLessThanOrEqual(expected: number | bigint): void {\n      createMatcher(\n        \"toBeLessThanOrEqual\",\n        () => (received as number) <= expected,\n        expected,\n        received,\n        matcherConfig,\n      );\n    },\n\n    toBeNaN(): void {\n      createMatcher(\n        \"toBeNaN\",\n        () => isNaN(received as number),\n        \"NaN\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toBeNull(): void {\n      createMatcher(\n        \"toBeNull\",\n        () => received === null,\n        \"null\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toBeTruthy(): void {\n      createMatcher(\n        \"toBeTruthy\",\n        () => !!received,\n        \"truthy\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toBeUndefined(): void {\n      createMatcher(\n        \"toBeUndefined\",\n        () => received === undefined,\n        \"undefined\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toEqual(expected: unknown): void {\n      createMatcher(\n        \"toEqual\",\n        () => isDeepEqual(received, expected),\n        JSON.stringify(expected),\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toHaveLength(expected: number): void {\n      createMatcher(\n        \"toHaveLength\",\n        () => (received as Array<unknown>).length === expected,\n        expected.toString(),\n        (received as Array<unknown>).length.toString(),\n        matcherConfig,\n      );\n    },\n\n    toContain(expected: unknown): void {\n      let receivedType = \"\";\n      if (typeof received === \"string\") {\n        receivedType = \"string\";\n      } else if (Array.isArray(received)) {\n        receivedType = \"array\";\n      } else if (received instanceof Set) {\n        receivedType = \"set\";\n      } else {\n        throw new Error(\n          \"toContain is only supported for strings, arrays, and sets\",\n        );\n      }\n      createMatcher(\n        \"toContain\",\n        () => {\n          if (typeof received === \"string\") {\n            return received.includes(expected as string);\n          } else if (Array.isArray(received)) {\n            return received.includes(expected);\n          } else if (received instanceof Set) {\n            return Array.from(received).includes(expected);\n          } else {\n            throw new Error(\n              \"toContain is only supported for strings, arrays, and sets\",\n            );\n          }\n        },\n        expected,\n        received,\n        {\n          ...matcherConfig,\n          matcherSpecific: {\n            receivedType,\n          },\n        },\n      );\n    },\n\n    toContainEqual(expected: unknown): void {\n      let receivedType = \"\";\n      if (Array.isArray(received)) {\n        receivedType = \"array\";\n      } else if (received instanceof Set) {\n        receivedType = \"set\";\n      } else {\n        throw new Error(\n          \"toContainEqual is only supported for arrays and sets\",\n        );\n      }\n\n      createMatcher(\n        \"toContainEqual\",\n        () => {\n          if (Array.isArray(received)) {\n            return received.some((item) => isDeepEqual(item, expected));\n          } else if (received instanceof Set) {\n            return Array.from(received).some((item) =>\n              isDeepEqual(item, expected)\n            );\n          } else {\n            throw new Error(\n              \"toContainEqual is only supported for arrays and sets\",\n            );\n          }\n        },\n        expected,\n        received,\n        {\n          ...matcherConfig,\n          matcherSpecific: {\n            receivedType,\n          },\n        },\n      );\n    },\n\n    toHaveProperty(keyPath: string, expected?: unknown): void {\n      if (typeof received !== \"object\" || received === null) {\n        throw new Error(\n          \"toHaveProperty is only supported for objects\",\n        );\n      }\n\n      const hasProperty = () => {\n        try {\n          const value = getPropertyByPath(\n            received as Record<string, unknown>,\n            keyPath,\n          );\n          return expected !== undefined ? isDeepEqual(value, expected) : true;\n        } catch (_) {\n          return false;\n        }\n      };\n\n      createMatcher(\n        \"toHaveProperty\",\n        hasProperty,\n        expected !== undefined ? expected : keyPath,\n        received,\n        {\n          ...matcherConfig,\n          matcherSpecific: {\n            keyPath,\n            hasExpectedValue: expected !== undefined,\n          },\n        },\n      );\n    },\n  };\n\n  return expectation;\n}\n\n// Helper function to handle common matcher logic\nfunction createMatcher(\n  matcherName: string,\n  checkFn: () => boolean,\n  expected: unknown,\n  received: unknown,\n  {\n    usedAssert,\n    isSoft,\n    isNegated = false,\n    matcherSpecific = {},\n    message,\n  }: {\n    usedAssert: typeof assert;\n    isSoft: boolean;\n    isNegated?: boolean;\n    matcherSpecific?: Record<string, unknown>;\n    message?: string;\n  },\n): void {\n  const info = createMatcherInfo(\n    matcherName,\n    expected,\n    received,\n    { ...matcherSpecific, isNegated },\n    message,\n  );\n\n  const result = checkFn();\n  // If isNegated is true, we want to invert the result\n  const finalResult = isNegated ? !result : result;\n\n  usedAssert(\n    finalResult,\n    MatcherErrorRendererRegistry.getRenderer(matcherName).render(\n      info,\n      MatcherErrorRendererRegistry.getConfig(),\n    ),\n    isSoft,\n  );\n}\n\nfunction createMatcherInfo(\n  matcherName: string,\n  expected: string | unknown,\n  received: unknown,\n  matcherSpecific: Record<string, unknown> = {},\n  customMessage?: string,\n): MatcherErrorInfo {\n  const stacktrace = parseStackTrace(new Error().stack);\n  const executionContext = captureExecutionContext(stacktrace);\n\n  if (!executionContext) {\n    throw new Error(\"k6 failed to capture execution context\");\n  }\n\n  return {\n    executionContext,\n    matcherName,\n    expected: typeof expected === \"string\"\n      ? expected\n      : JSON.stringify(expected),\n    received: JSON.stringify(received),\n    matcherSpecific,\n    customMessage,\n  };\n}\n\n/**\n * A matcher error renderer for the `toBeCloseTo` matcher.\n */\nexport class ToBeCloseToErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeCloseTo\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    const matcherInfo = info.matcherSpecific as {\n      precision: number;\n      difference: number;\n      expectedDifference: number;\n    };\n\n    return [\n      {\n        label: \"Expected precision\",\n        value: maybeColorize(matcherInfo.precision.toString(), \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Expected difference\",\n        value: \"< \" +\n          maybeColorize(`${matcherInfo.expectedDifference}`, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received difference\",\n        value: maybeColorize(matcherInfo.difference.toString(), \"red\"),\n        group: 3,\n      },\n    ];\n  }\n\n  protected override renderMatcherArgs(\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): string {\n    return maybeColorize(`(`, \"darkGrey\") +\n      maybeColorize(`expected`, \"green\") +\n      maybeColorize(`, `, \"darkGrey\") +\n      maybeColorize(`precision`, \"white\") +\n      maybeColorize(`)`, \"darkGrey\");\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeDefined` matcher.\n */\nexport class ToBeDefinedErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeDefined\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeFalsy` matcher.\n */\nexport class ToBeFalsyErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeFalsy\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeGreaterThan` matcher.\n */\nexport class ToBeGreaterThanErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeGreaterThan\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: \"> \" + maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeGreaterThanOrEqual` matcher.\n */\nexport class ToBeGreaterThanOrEqualErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeGreaterThanOrEqual\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: \">= \" + maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeInstanceOf` matcher.\n */\nexport class ToBeInstanceOfErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeInstanceOf\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected constructor\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received constructor\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeLessThan` matcher.\n */\nexport class ToBeLessThanErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeLessThan\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: \"< \" + maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeLessThanOrEqual` matcher.\n */\nexport class ToBeLessThanOrEqualErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeLessThanOrEqual\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: \"<= \" + maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeNaN` matcher.\n */\nexport class ToBeNaNErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeNaN\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeNull` matcher.\n */\nexport class ToBeNullErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeNull\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeTruthy` matcher.\n */\nexport class ToBeTruthyErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeTruthy\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeUndefined` matcher.\n */\nexport class ToBeUndefinedErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeUndefined\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toEqual` matcher.\n */\nexport class ToEqualErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toEqual\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toHaveLength` matcher.\n */\nexport class ToHaveLengthErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toHaveLength\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected length\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received length\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n      {\n        label: \"Received array\",\n        value: maybeColorize(\n          info.matcherSpecific?.receivedArray as string,\n          \"red\",\n        ),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toContain` matcher.\n */\nexport class ToContainErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toContain\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    const isNegated = info.matcherSpecific?.isNegated as boolean;\n    const receivedType = typeof info.matcherSpecific?.receivedType === \"string\"\n      ? info.matcherSpecific?.receivedType as string\n      : Array.isArray(JSON.parse(info.received))\n      ? \"array\"\n      : \"string\";\n\n    return [\n      {\n        label: isNegated ? \"Expected not to contain\" : \"Expected to contain\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: `Received ${receivedType}`,\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toContainEqual` matcher.\n */\nexport class ToContainEqualErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toContainEqual\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    const isNegated = info.matcherSpecific?.isNegated as boolean;\n    const receivedType = info.matcherSpecific?.receivedType as string;\n\n    return [\n      {\n        label: isNegated\n          ? \"Expected not to contain equal\"\n          : \"Expected to contain equal\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: `Received ${receivedType}`,\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toHaveProperty` matcher.\n */\nexport class ToHavePropertyErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toHaveProperty\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    const isNegated = info.matcherSpecific?.isNegated as boolean;\n    const keyPath = info.matcherSpecific?.keyPath as string;\n    const hasExpectedValue = info.matcherSpecific?.hasExpectedValue as boolean;\n\n    const lines: LineGroup[] = [\n      {\n        label: \"Property path\",\n        value: maybeColorize(keyPath, \"white\"),\n        group: 3,\n      },\n    ];\n\n    if (hasExpectedValue) {\n      lines.push(\n        {\n          label: isNegated\n            ? \"Expected property not to equal\"\n            : \"Expected property to equal\",\n          value: maybeColorize(info.expected, \"green\"),\n          group: 3,\n        },\n      );\n    } else {\n      lines.push(\n        {\n          label: isNegated\n            ? \"Expected property not to exist\"\n            : \"Expected property to exist\",\n          value: \"\",\n          group: 3,\n        },\n      );\n    }\n\n    lines.push(\n      {\n        label: \"Received object\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    );\n\n    return lines;\n  }\n\n  protected override renderMatcherArgs(\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): string {\n    return maybeColorize(`(`, \"darkGrey\") +\n      maybeColorize(`keyPath`, \"white\") +\n      maybeColorize(`, `, \"darkGrey\") +\n      maybeColorize(`expected?`, \"green\") +\n      maybeColorize(`)`, \"darkGrey\");\n  }\n}\n\nfunction isDeepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n\n  if (a === null || b === null) return false;\n  if (typeof a !== \"object\" || typeof b !== \"object\") return false;\n\n  const keysA = Object.keys(a as object);\n  const keysB = Object.keys(b as object);\n\n  if (keysA.length !== keysB.length) return false;\n\n  return keysA.every((key) => {\n    return keysB.includes(key) &&\n      isDeepEqual(\n        (a as Record<string, unknown>)[key],\n        (b as Record<string, unknown>)[key],\n      );\n  });\n}\n\n/**\n * Gets a property value from an object using a path string.\n * Supports dot notation (obj.prop) and array indexing (obj[0] or obj.array[0]).\n *\n * @param obj The object to get the property from\n * @param path The path to the property (e.g. \"a.b[0].c\")\n * @returns The value at the specified path\n * @throws Error if the property doesn't exist\n */\nfunction getPropertyByPath(\n  obj: Record<string, unknown>,\n  path: string,\n): unknown {\n  if (path === \"\") {\n    throw new Error(\"Invalid path: empty string\");\n  }\n\n  // Parse the path into segments\n  const segments: string[] = [];\n  let currentSegment = \"\";\n  let inBrackets = false;\n\n  for (let i = 0; i < path.length; i++) {\n    const char = path[i];\n\n    if (char === \".\" && !inBrackets) {\n      if (currentSegment) {\n        segments.push(currentSegment);\n        currentSegment = \"\";\n      }\n    } else if (char === \"[\") {\n      if (currentSegment) {\n        segments.push(currentSegment);\n        currentSegment = \"\";\n      }\n      inBrackets = true;\n    } else if (char === \"]\") {\n      if (inBrackets) {\n        segments.push(currentSegment);\n        currentSegment = \"\";\n        inBrackets = false;\n      } else {\n        throw new Error(`Invalid path: ${path}`);\n      }\n    } else {\n      currentSegment += char;\n    }\n  }\n\n  // Add the last segment if there is one\n  if (currentSegment) {\n    segments.push(currentSegment);\n  }\n\n  // Traverse the object using the segments\n  let current: unknown = obj;\n\n  for (const segment of segments) {\n    if (current === null || current === undefined) {\n      throw new Error(`Property ${path} does not exist`);\n    }\n\n    if (typeof segment === \"string\" && !isNaN(Number(segment))) {\n      // If segment is a numeric string, treat it as an array index\n      const index = Number(segment);\n      if (!Array.isArray(current)) {\n        throw new Error(`Cannot access index ${segment} of non-array`);\n      }\n      if (index >= (current as unknown[]).length) {\n        throw new Error(`Index ${segment} out of bounds`);\n      }\n      current = (current as unknown[])[index];\n    } else {\n      // Otherwise treat it as an object property\n      if (typeof current !== \"object\") {\n        throw new Error(`Cannot access property ${segment} of non-object`);\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(current, segment)) {\n        throw new Error(`Property ${segment} does not exist on object`);\n      }\n\n      current = (current as Record<string, unknown>)[segment];\n    }\n  }\n\n  return current;\n}\n", "import { assert } from \"./assert.ts\";\nimport type { ANSI_COLORS } from \"./colors.ts\";\nimport {\n  DEFAULT_RETRY_OPTIONS,\n  type ExpectConfig,\n  type RetryConfig,\n} from \"./config.ts\";\nimport { captureExecutionContext } from \"./execution.ts\";\nimport {\n  ExpectedReceivedMatcherRenderer,\n  type LineGroup,\n  type MatcherErrorInfo,\n  MatcherErrorRendererRegistry,\n  ReceivedOnlyMatcherRenderer,\n} from \"./render.ts\";\nimport { parseStackTrace } from \"./stacktrace.ts\";\nimport type { Locator } from \"https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/refs/heads/master/types/k6/browser/index.d.ts\";\n\n/**\n * RetryingExpectation is an interface that defines the methods that can be used to create a retrying expectation.\n *\n * Retrying expectations are used to assert that a condition is met within a given timeout.\n * The provided assertion function is called repeatedly until the condition is met or the timeout is reached.\n *\n * The RetryingExpectation interface is implemented by the createExpectation function.\n */\nexport interface RetryingExpectation {\n  /**\n   * Negates the expectation, causing the assertion to pass when it would normally fail, and vice versa.\n   */\n  not: RetryingExpectation;\n\n  /**\n   * Ensures the Locator points to a checked input.\n   */\n  toBeChecked(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures the Locator points to a disabled element.\n   * Element is disabled if it has \"disabled\" attribute or is disabled via 'aria-disabled'.\n   *\n   * Note that only native control elements such as HTML button, input, select, textarea, option, optgroup can be disabled by setting \"disabled\" attribute.\n   * \"disabled\" attribute on other elements is ignored by the browser.\n   */\n  toBeDisabled(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures the Locator points to an editable element.\n   */\n  toBeEditable(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures the Locator points to an enabled element.\n   */\n  toBeEnabled(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures that Locator either does not resolve to any DOM node, or resolves to a non-visible one.\n   */\n  toBeHidden(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures that Locator points to an attached and visible DOM node.\n   */\n  toBeVisible(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures the Locator points to an element with the given input value. You can use regular expressions for the value as well.\n   *\n   * @param value {string} the expected value of the input\n   */\n  toHaveValue(value: string, options?: Partial<RetryConfig>): Promise<void>;\n}\n\n/**\n * createExpectation is a factory function that creates an expectation object for a given value.\n *\n * Note that although the browser `is` prefixed methods are used, and return boolean values, we\n * throw errors if the condition is not met. This is to ensure that we align with playwright's\n * API, and have matchers return `Promise<void>`, as opposed to `Promise<boolean>`.\n *\n * @param locator the value to create an expectation for\n * @param config the configuration for the expectation\n * @param message the optional custom message for the expectation\n * @param isNegated whether the expectation is negated\n * @returns an expectation object over the given value exposing the Expectation set of methods\n */\nexport function createExpectation(\n  locator: Locator,\n  config: ExpectConfig,\n  message?: string,\n  isNegated: boolean = false,\n): RetryingExpectation {\n  // In order to facilitate testing, we support passing in a custom assert function.\n  // As a result, we need to make sure that the assert function is always available, and\n  // if not, we need to use the default assert function.\n  //\n  // From this point forward, we will use the `usedAssert` variable to refer to the assert function.\n  const usedAssert = config.assertFn ?? assert;\n  const isSoft = config.soft ?? false;\n  const retryConfig: RetryConfig = {\n    timeout: config.timeout,\n    interval: config.interval,\n  };\n\n  // Configure the renderer with the colorize option.\n  MatcherErrorRendererRegistry.configure({\n    colorize: config.colorize,\n    display: config.display,\n  });\n\n  // Register renderers specific to each matchers at initialization time.\n  MatcherErrorRendererRegistry.register(\n    \"toBeChecked\",\n    new ToBeCheckedErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeDisabled\",\n    new ToBeDisabledErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeEditable\",\n    new ToBeEditableErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeEnabled\",\n    new ToBeEnabledErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeHidden\",\n    new ToBeHiddenErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeVisible\",\n    new ToBeVisibleErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toHaveValue\",\n    new ToHaveValueErrorRenderer(),\n  );\n\n  const matcherConfig = {\n    locator,\n    retryConfig,\n    usedAssert,\n    isSoft,\n    isNegated,\n    message,\n  };\n\n  const expectation: RetryingExpectation = {\n    get not(): RetryingExpectation {\n      return createExpectation(locator, config, message, !isNegated);\n    },\n\n    async toBeChecked(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeChecked\",\n        async () => await locator.isChecked(),\n        \"checked\",\n        \"unchecked\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toBeDisabled(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeDisabled\",\n        async () => await locator.isDisabled(),\n        \"disabled\",\n        \"enabled\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toBeEditable(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeEditable\",\n        async () => await locator.isEditable(),\n        \"editable\",\n        \"uneditable\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toBeEnabled(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeEnabled\",\n        async () => await locator.isEnabled(),\n        \"enabled\",\n        \"disabled\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toBeHidden(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeHidden\",\n        async () => await locator.isHidden(),\n        \"hidden\",\n        \"visible\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toBeVisible(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeVisible\",\n        async () => await locator.isVisible(),\n        \"visible\",\n        \"hidden\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toHaveValue(\n      expectedValue: string,\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      const stacktrace = parseStackTrace(new Error().stack);\n      const executionContext = captureExecutionContext(stacktrace);\n      if (!executionContext) {\n        throw new Error(\"k6 failed to capture execution context\");\n      }\n\n      const info: MatcherErrorInfo = {\n        executionContext,\n        matcherName: \"toHaveValue\",\n        expected: expectedValue,\n        received: \"unknown\",\n        matcherSpecific: { isNegated },\n        customMessage: message,\n      };\n\n      try {\n        await withRetry(async () => {\n          const actualValue = await locator.inputValue();\n          const result = expectedValue === actualValue;\n          // If isNegated is true, we want to invert the result\n          const finalResult = isNegated ? !result : result;\n\n          usedAssert(\n            finalResult,\n            MatcherErrorRendererRegistry.getRenderer(\"toHaveValue\").render(\n              info,\n              MatcherErrorRendererRegistry.getConfig(),\n            ),\n            isSoft,\n          );\n        }, { ...retryConfig, ...options });\n      } catch (_) {\n        usedAssert(\n          false,\n          MatcherErrorRendererRegistry.getRenderer(\"toHaveValue\").render(\n            info,\n            MatcherErrorRendererRegistry.getConfig(),\n          ),\n          isSoft,\n        );\n      }\n    },\n  };\n\n  return expectation;\n}\n\n// Helper function to create common matcher info\nfunction createMatcherInfo(\n  matcherName: string,\n  expected: string,\n  received: string,\n  additionalInfo = {},\n  customMessage?: string,\n): MatcherErrorInfo {\n  const stacktrace = parseStackTrace(new Error().stack);\n  const executionContext = captureExecutionContext(stacktrace);\n\n  if (!executionContext) {\n    throw new Error(\"k6 failed to capture execution context\");\n  }\n\n  return {\n    executionContext,\n    matcherName,\n    expected,\n    received,\n    customMessage,\n    ...additionalInfo,\n  };\n}\n\n// Helper function to handle common matcher logic\nasync function createMatcher(\n  matcherName: string,\n  checkFn: () => Promise<boolean>,\n  expected: string,\n  received: string,\n  {\n    locator,\n    retryConfig,\n    usedAssert,\n    isSoft,\n    isNegated = false,\n    options = {},\n    message,\n  }: {\n    locator: Locator;\n    retryConfig: RetryConfig;\n    usedAssert: typeof assert;\n    isSoft: boolean;\n    isNegated?: boolean;\n    options?: Partial<RetryConfig>;\n    message?: string;\n  },\n): Promise<void> {\n  const info = createMatcherInfo(matcherName, expected, received, {\n    matcherSpecific: {\n      locator,\n      timeout: options.timeout,\n      isNegated,\n    },\n  }, message);\n\n  try {\n    await withRetry(async () => {\n      const result = await checkFn();\n      // If isNegated is true, we want to invert the result\n      const finalResult = isNegated ? !result : result;\n\n      if (!finalResult) {\n        throw new Error(\"matcher failed\");\n      }\n\n      usedAssert(\n        finalResult,\n        MatcherErrorRendererRegistry.getRenderer(matcherName).render(\n          info,\n          MatcherErrorRendererRegistry.getConfig(),\n        ),\n        isSoft,\n      );\n    }, { ...retryConfig, ...options });\n  } catch (_) {\n    usedAssert(\n      false,\n      MatcherErrorRendererRegistry.getRenderer(matcherName).render(\n        info,\n        MatcherErrorRendererRegistry.getConfig(),\n      ),\n      isSoft,\n    );\n  }\n}\n\n/**\n * Base class for boolean state matchers (checked, disabled, etc.)\n */\nexport abstract class BooleanStateErrorRenderer\n  extends ReceivedOnlyMatcherRenderer {\n  protected abstract state: string;\n  protected abstract oppositeState: string;\n\n  protected getMatcherName(): string {\n    return `toBe${this.state[0].toUpperCase()}${this.state.slice(1)}`;\n  }\n\n  protected override getReceivedPlaceholder(): string {\n    return \"locator\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      { label: \"Expected\", value: this.state, group: 3 },\n      { label: \"Received\", value: this.oppositeState, group: 3 },\n      { label: \"Call log\", value: \"\", group: 3 },\n      {\n        label: \"\",\n        value: maybeColorize(\n          `  - expect.toBe${this.state[0].toUpperCase()}${\n            this.state.slice(1)\n          } with timeout ${info.matcherSpecific?.timeout}ms`,\n          \"darkGrey\",\n        ),\n        group: 3,\n        raw: true,\n      },\n      {\n        label: \"\",\n        value: maybeColorize(`  - waiting for locator`, \"darkGrey\"),\n        group: 3,\n        raw: true,\n      },\n    ];\n  }\n}\n\nexport class ToBeCheckedErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"checked\";\n  protected oppositeState = \"unchecked\";\n}\n\n/**\n * A matcher error renderer for the `toBeDisabled` matcher.\n */\nexport class ToBeDisabledErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"disabled\";\n  protected oppositeState = \"enabled\";\n}\n\nexport class ToBeEditableErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"editable\";\n  protected oppositeState = \"uneditable\";\n}\n\nexport class ToBeEnabledErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"enabled\";\n  protected oppositeState = \"disabled\";\n}\n\nexport class ToBeHiddenErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"hidden\";\n  protected oppositeState = \"visible\";\n}\n\nexport class ToBeVisibleErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"visible\";\n  protected oppositeState = \"hidden\";\n}\n\nexport class ToHaveValueErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toHaveValue\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      // FIXME (@oleiade): When k6/#4210 is fixed, we can use the locator here.\n      // { label: \"Locator\", value: maybeColorize(`locator('${info.matcherSpecific?.locator}')`, \"white\"), group: 3 },\n      {\n        label: \"Expected\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n      { label: \"Call log\", value: \"\", group: 3 },\n      {\n        label: \"\",\n        value: maybeColorize(\n          `  - expect.toHaveValue with timeout ${info.matcherSpecific?.timeout}ms`,\n          \"darkGrey\",\n        ),\n        group: 3,\n        raw: true,\n      },\n      // FIXME (@oleiade): When k6/#4210 is fixed, we can use the locator's selector here.\n      {\n        label: \"\",\n        value: maybeColorize(`  - waiting for locator`, \"darkGrey\"),\n        group: 3,\n        raw: true,\n      },\n    ];\n  }\n}\n\n/**\n * Implements retry logic for async assertions.\n *\n * @param assertion Function that performs the actual check\n * @param options Retry configuration\n * @returns Promise that resolves when assertion passes or rejects if timeout is reached\n */\nexport async function withRetry(\n  assertion: () => Promise<void>,\n  options: RetryConfig & {\n    // Optional test hooks - only used in testing\n    _now?: () => number;\n    _sleep?: (ms: number) => Promise<void>;\n  } = {},\n): Promise<boolean> {\n  const timeout: number = options.timeout ?? DEFAULT_RETRY_OPTIONS.timeout;\n  const interval: number = options.interval ?? DEFAULT_RETRY_OPTIONS.interval;\n  const getNow = options._now ?? (() => Date.now());\n  const sleep = options._sleep ??\n    ((ms: number) => new Promise((resolve) => setTimeout(resolve, ms)));\n\n  const startTime: number = getNow();\n\n  while (getNow() - startTime < timeout) {\n    try {\n      await assertion();\n      return true;\n    } catch (_error) {\n      // Ignore error and continue retrying\n    }\n\n    await sleep(interval);\n  }\n\n  throw new RetryTimeoutError(\n    `Expect condition not met within ${timeout}ms timeout`,\n  );\n}\n\n/**\n * RetryTimeoutError is an error that is thrown when an expectation is not met within a provided timeout.\n */\nexport class RetryTimeoutError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"RetryTimeoutError\";\n  }\n}\n", "import type { Locator } from \"https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/refs/heads/master/types/k6/browser/index.d.ts\";\nimport { ConfigLoader, type ExpectConfig } from \"./config.ts\";\nimport {\n  createExpectation as createNonRetryingExpectation,\n  type NonRetryingExpectation,\n} from \"./expectNonRetrying.ts\";\nimport {\n  createExpectation as createRetryingExpectation,\n  type RetryingExpectation,\n} from \"./expectRetrying.ts\";\n\n/**\n * The expect function is used to assert that a value meets certain conditions.\n *\n * The expect function can be used in two ways:\n *\n * 1. Non-retrying: The expect function will perform the assertion only once. If the assertion\n * is not met, the test will fail.\n * 2. Retrying: The expect function will perform the assertion multiple times, until the assertion\n * is met or the timeout is reached. If the assertion is not met, the test will fail.\n *\n * @param {unknown | Locator} value The value to assert.\n */\nexport const expect: ExpectFunction = makeExpect();\n\nexport interface ExpectFunction {\n  /**\n   * The expect function can be used directly to assert that a value meets certain conditions.\n   *\n   * If the value argument provided to it is a Locator, the expect function will\n   * return a (asynchronous) RetryingExpectation, otherwise it will return a NonRetryingExpectation.\n   */\n  <T>(value: T, message?: string): T extends Locator ? RetryingExpectation\n    : NonRetryingExpectation;\n\n  /**\n   * The soft function can be used to assert that a value meets certain conditions, but\n   * without terminating the test if the assertion is not met.\n   */\n  soft<T>(\n    value: T,\n    message?: string,\n  ): T extends Locator ? RetryingExpectation : NonRetryingExpectation;\n\n  /**\n   * Creates a new expect instance with the given configuration.\n   */\n  configure(newConfig: Partial<ExpectConfig>): ExpectFunction;\n\n  /**\n   * The configuration used by the expect function.\n   */\n  readonly config: ExpectConfig;\n}\n\n/**\n * Creates a new expect function with the given configuration.\n *\n * This allows us\n *\n * @param baseConfig The base configuration for the expect function.\n * @returns\n */\nfunction makeExpect(baseConfig?: Partial<ExpectConfig>): ExpectFunction {\n  /**\n   * Loads the configuration for the expect function.\n   */\n  const config = ConfigLoader.load(baseConfig);\n\n  return Object.assign(\n    function <T>(\n      value: T,\n      message?: string,\n    ): T extends Locator ? RetryingExpectation : NonRetryingExpectation {\n      if (isLocator(value)) {\n        return createRetryingExpectation(\n          value as Locator,\n          config,\n          message,\n        ) as T extends Locator ? RetryingExpectation : NonRetryingExpectation;\n      } else {\n        return createNonRetryingExpectation(\n          value,\n          config,\n          message,\n        ) as T extends Locator ? RetryingExpectation : NonRetryingExpectation;\n      }\n    },\n    {\n      soft<T>(\n        value: T,\n        message?: string,\n      ): T extends Locator ? RetryingExpectation : NonRetryingExpectation {\n        if (isLocator(value)) {\n          return createRetryingExpectation(\n            value as Locator,\n            { ...config, soft: true },\n            message,\n          ) as T extends Locator ? RetryingExpectation : NonRetryingExpectation;\n        } else {\n          return createNonRetryingExpectation(\n            value,\n            { ...config, soft: true },\n            message,\n          ) as T extends Locator ? RetryingExpectation : NonRetryingExpectation;\n        }\n      },\n      configure(newConfig: Partial<ExpectConfig>): ExpectFunction {\n        return makeExpect(newConfig);\n      },\n      get config(): ExpectConfig {\n        return { ...config };\n      },\n    },\n  );\n}\n\n/**\n * Checks if the given value is a browser Locator.\n *\n * If it quacks like a duck, it's a duck.\n *\n * @param value The value to check.\n * @returns Whether the value is a Locator.\n */\nfunction isLocator(value: unknown): value is Locator {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  const locatorProperties = [\n    \"clear\",\n    \"isEnabled\",\n    \"isHidden\",\n    \"getAttribute\",\n    \"selectOption\",\n    \"press\",\n    \"type\",\n    \"dispatchEvent\",\n    \"dblclick\",\n    \"setChecked\",\n    \"isDisabled\",\n    \"focus\",\n    \"innerText\",\n    \"inputValue\",\n    \"check\",\n    \"isEditable\",\n    \"fill\",\n    \"textContent\",\n    \"hover\",\n    \"waitFor\",\n    \"click\",\n    \"uncheck\",\n    \"isChecked\",\n    \"isVisible\",\n    \"innerHTML\",\n    \"tap\",\n  ];\n\n  const hasLocatorProperties = (value: object): boolean => {\n    return locatorProperties.every((prop) => prop in value);\n  };\n\n  return (\n    value !== null &&\n    value !== undefined &&\n    typeof value === \"object\" &&\n    hasLocatorProperties(value)\n  );\n}\n"],
  "mappings": "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",
  "names": ["createExpectation", "createMatcher", "createMatcherInfo", "createExpectation", "value"]
}
