{
  "version": 3,
  "sources": ["../assert.ts", "../environment.ts", "../config.ts", "../execution.ts", "../stacktrace.ts", "../colors.ts", "../render.ts", "../expectNonRetrying.ts", "../utils/string.ts", "../expectRetrying.ts", "../expect.ts"],
  "sourcesContent": ["// NOTE (@oleiade): This is a shim for the k6/execution module, meaning that\n// imports of k6-execution-shim will be replaced with k6/execution in the\n// output bundle file.\n//\n// This allows us to avoid relying on the k6/execution module in the Deno runtime,\n// which is not compatible with the k6 runtime. Instead replacing it with a mock\n// implementation that does not abort the test. While making sure that we do replace\n// it with the real k6/execution module when bundling for the k6 runtime.\n//\n// It allows us to use the `deno test` command and unit tests in the Deno runtime. While\n// still being able to use the `k6 run` command and tests in the k6 runtime.\nimport exec from \"k6-execution-shim\";\n\n/**\n * assert is a function that checks a condition and fails the test if the condition is false.\n *\n * As a default, a failing assertion will immediately abort the whole test, exit with code 108, and\n * display an error message. If you want to continue the test after a failing assertion, you can pass\n * `true` as the third argument to `assert`.\n *\n * @param condition condition to assert the truthyness of\n * @param message the message to display if the condition is false\n * @param soft if true, the assertion will mark the test as failed without interrupting the execution\n */\nexport function assert(condition: boolean, message: string, soft?: boolean) {\n  if (condition) return;\n\n  if (soft) {\n    throw new AssertionFailedError(message);\n  } else {\n    // This will the k6-execution-shim module's abort method in the Deno runtime.\n    // It will instead be replaced with the k6/execution module's abort method\n    // in the output bundle file produced by esbuild specifically for the k6 runtime.\n    exec.test.abort(message);\n  }\n}\n\n/**\n * This indicates that an assertion failed.\n *\n * It is used to express a soft assertion's failure, as throwing will not abort the\n * test, and will instead fail the iteration.\n */\nexport class AssertionFailedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AssertionFailedError\";\n  }\n}\n", "// In the k6 runtime, the __ENV object is available and contains the environment variables.\nexport declare const __ENV: Record<string, string | undefined>;\n\n/**\n * Environment interface that matches the shape of k6's __ENV object.\n */\nexport interface Environment {\n  [key: string]: string | undefined;\n}\n\nfunction getEnvironment(): Environment {\n  // When running in Deno\n  if (typeof Deno !== \"undefined\") {\n    return Deno.env.toObject();\n  }\n\n  // When running in k6\n  return __ENV;\n}\n\n// Export a singleton instance of the environment object\nexport const env: Environment = getEnvironment();\n\n/**\n * Environment variable parser\n */\nexport const envParser = {\n  /**\n   * Check if an environment variable is set\n   */\n  hasValue(key: string): boolean {\n    return env[key] !== undefined;\n  },\n\n  /**\n   * Parse a boolean environment variable\n   * \"false\" (case insensitive) -> false\n   * anything else -> true\n   * @throws if value is undefined\n   */\n  boolean(key: string): boolean {\n    const value = env[key]?.toLowerCase();\n    if (value === undefined) {\n      throw new Error(`Environment variable ${key} is not set`);\n    }\n    return value !== \"false\";\n  },\n\n  /**\n   * Parse an environment variable that should match specific values\n   * @throws if value is undefined or doesn't match allowed values\n   */\n  enum<T extends string>(key: string, allowedValues: T[]): T {\n    const value = env[key]?.toLowerCase() as T;\n    if (value === undefined) {\n      throw new Error(`Environment variable ${key} is not set`);\n    }\n    if (!allowedValues.includes(value)) {\n      throw new Error(\n        `Invalid value for ${key}. Must be one of: ${allowedValues.join(\", \")}`,\n      );\n    }\n    return value;\n  },\n\n  /**\n   * Parses an environment variable as a non-negative number.\n   * @param name The name of the environment variable\n   * @throws Error if the value is not a valid non-negative number\n   * @returns The parsed number value\n   */\n  number(name: string): number {\n    const value = env[name];\n    if (!value) {\n      throw new Error(`Environment variable ${name} is not set`);\n    }\n\n    const parsed = Number(value);\n    if (Number.isNaN(parsed) || !Number.isFinite(parsed)) {\n      throw new Error(\n        `Environment variable ${name} must be a valid number, got: ${value}`,\n      );\n    }\n\n    if (parsed < 0) {\n      throw new Error(\n        `Environment variable ${name} must be a non-negative number, got: ${value}`,\n      );\n    }\n\n    return parsed;\n  },\n};\n", "import { assert } from \"./assert.ts\";\nimport { envParser } from \"./environment.ts\";\n\n/**\n * Options that can be set for the expect function.\n */\nexport interface ExpectConfig extends RenderConfig, RetryConfig {\n  /**\n   * Setting this option to true will make the assertions performed by expect\n   * to be always soft, meaning that they will not fail the test if the assertion\n   * is not met.\n   */\n  soft: boolean;\n\n  /**\n   * Optional custom assertion function to be used instead of the default assert function.\n   *\n   * This function should have the same signature as the assert function.\n   */\n  assertFn?: (...args: Parameters<typeof import(\"./assert.ts\").assert>) => void;\n}\n\n/**\n * The configuration for the retry behavior.\n */\nexport interface RetryConfig {\n  /**\n   * Maximum amount of time to retry in milliseconds.\n   * @default 5000\n   */\n  timeout?: number;\n\n  /**\n   * Time between retries in milliseconds.\n   * @default 100\n   */\n  interval?: number;\n}\n\nexport const DEFAULT_RETRY_OPTIONS: Required<RetryConfig> = {\n  // 5 seconds default timeout\n  timeout: 5000,\n  // 100ms between retries\n  interval: 100,\n};\n\n/**\n * The configuration for the renderer.\n */\nexport interface RenderConfig {\n  /**\n   * Setting this option to false will disable the colorization of the output of the\n   * expect function. The default is true.\n   */\n  colorize: boolean;\n\n  /**\n   * Expectations can be displayed in two different ways: inline or pretty.\n   * The default is pretty.\n   *\n   * When displayed inline, the expectation will be displayed in a single line, to\n   * make it easier to interpret the output when written to logs.\n   *\n   * When displayed pretty, the expectation will be displayed in a more human-readable\n   * format, with each part of the expectation in a separate line.\n   */\n  display: DisplayFormat;\n}\n\n/**\n * The display format to use.\n *\n * \"pretty\" is the default format and outputs in a human readable format with aligned columns.\n * \"inline\" is a logfmt style format that outputs in a single line.\n */\nexport type DisplayFormat = \"inline\" | \"pretty\";\n\n/**\n * Default configuration values, without any environment overrides\n */\nexport const DEFAULT_CONFIG: ExpectConfig = {\n  ...DEFAULT_RETRY_OPTIONS,\n  soft: false,\n  colorize: true,\n  display: \"pretty\",\n  assertFn: assert,\n};\n\n/**\n * Configuration loader that handles different sources of configuration\n * with clear precedence rules\n */\nexport class ConfigLoader {\n  /**\n   * Loads configuration with the following precedence (highest to lowest):\n   * 1. Environment variables\n   * 2. Explicit configuration passed to the function\n   * 3. Default values\n   */\n  static load(explicitConfig: Partial<ExpectConfig> = {}): ExpectConfig {\n    const envConfig = ConfigLoader.loadFromEnv();\n\n    return {\n      ...DEFAULT_CONFIG,\n      ...explicitConfig,\n      ...envConfig,\n    };\n  }\n\n  /**\n   * Loads configuration from environment variables\n   * Returns only the values that are explicitly set in the environment\n   */\n  private static loadFromEnv(): Partial<ExpectConfig> {\n    const config: Partial<ExpectConfig> = {};\n\n    // Load colorize from environment variable\n    if (envParser.hasValue(\"K6_TESTING_COLORIZE\")) {\n      config.colorize = envParser.boolean(\"K6_TESTING_COLORIZE\");\n    }\n\n    // Load display from environment variable\n    if (envParser.hasValue(\"K6_TESTING_DISPLAY\")) {\n      config.display = envParser.enum<DisplayFormat>(\n        \"K6_TESTING_DISPLAY\",\n        [\"inline\", \"pretty\"],\n      );\n    }\n\n    // Load timeout from environment variable\n    if (envParser.hasValue(\"K6_TESTING_TIMEOUT\")) {\n      config.timeout = envParser.number(\"K6_TESTING_TIMEOUT\");\n    }\n\n    // Load interval from environment variable\n    if (envParser.hasValue(\"K6_TESTING_INTERVAL\")) {\n      config.interval = envParser.number(\"K6_TESTING_INTERVAL\");\n    }\n\n    return config;\n  }\n}\n", "import type { StackFrame, Stacktrace } from \"./stacktrace.ts\";\n\n/**\n * Holds the execution context for a given assertion, and is used to render the error message.\n */\nexport interface ExecutionContext {\n  /**\n   * The file path where the assertion was called. e.g. \"/some/path.ts\".\n   */\n  filePath: string;\n\n  /**\n   * The file name where the assertion was called. e.g. \"path.ts\".\n   */\n  fileName: string;\n\n  /**\n   * The line number within `filename` where the assertion was called. e.g. 42.\n   */\n  lineNumber: number;\n\n  /**\n   * The column number within `filename` where the assertion was called. e.g. 24.\n   */\n  columnNumber: number;\n\n  /**\n   * The location of the assertion. e.g. \"/some/path.ts:124:12\".\n   */\n  at: string;\n\n  /**\n   * The stacktrace this execution context was captured from.\n   */\n  stacktrace?: Stacktrace;\n}\n\n/**\n * Captures the execution context from the provided stacktrace.\n *\n * If no stacktrace is provided, the execution context is not captured and the function returns `undefined`.\n *\n * @param stacktrace - The stacktrace to capture the execution context from, as returned by `new Error().stack`.\n * @returns the execution context\n */\nexport function captureExecutionContext(\n  st: Stacktrace,\n): ExecutionContext | undefined {\n  if (!st || st.length <= 1) {\n    return undefined;\n  }\n\n  const stackFrame: StackFrame = st[st.length - 1];\n\n  const filePath = stackFrame.filePath;\n  const fileName = stackFrame.fileName;\n  const lineNumber = stackFrame.lineNumber;\n  const columnNumber = stackFrame.columnNumber;\n  const at = `${filePath}:${lineNumber}:${columnNumber}`;\n\n  return {\n    filePath,\n    fileName,\n    lineNumber,\n    columnNumber,\n    at,\n  };\n}\n", "/**\n * A stacktrace, represented as an array of stack frames.\n */\nexport type Stacktrace = StackFrame[];\n\n/**\n * A single frame in a stacktrace.\n */\nexport interface StackFrame {\n  // Name of the function, if any.\n  functionName: string;\n\n  // The full path to the file, if any.\n  filePath: string;\n\n  // Name of the file, if any.\n  fileName: string;\n\n  // Line number in the file, if any.\n  lineNumber: number;\n\n  // Column number in the file, if any.\n  columnNumber: number;\n}\n\n/**\n * Parses a stacktrace from a string.\n *\n * If no stacktrace is provided, returns an empty array.\n *\n * @param stack the stacktrace to parse, as returned by `new Error().stack`\n * @returns the parsed stacktrace\n */\nexport function parseStackTrace(stack?: string): Stacktrace {\n  // If no stacktrace is provided, return an empty array.\n  if (!stack) return [];\n\n  const lines = stack.split(\"\\n\");\n  const frames: StackFrame[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    let lineStr = lines[i].trim();\n\n    // Skip the first line if it's \"Error\" or any line that doesn't start with \"at \"\n    if (i === 0 && lineStr.startsWith(\"Error\")) continue;\n    if (!lineStr.startsWith(\"at \")) continue;\n\n    // Remove \"at \"\n    lineStr = lineStr.slice(3).trim();\n\n    // 1. Separate the function name from file info\n    let functionName = \"<anonymous>\";\n    let fileInfo = lineStr;\n    const firstParenIndex = lineStr.indexOf(\"(\");\n    const fileProtocolIndex = lineStr.indexOf(\"file://\");\n\n    if (fileProtocolIndex === 0) {\n      functionName = \"<anonymous>\";\n      fileInfo = lineStr.slice(fileProtocolIndex);\n    } else if (firstParenIndex >= 0) {\n      functionName = lineStr.slice(0, firstParenIndex).trim() || \"<anonymous>\";\n      fileInfo = lineStr\n        .slice(firstParenIndex + 1, lineStr.lastIndexOf(\")\"))\n        .trim();\n    } else {\n      fileInfo = lineStr;\n    }\n\n    // 2. Remove any trailing \"(X)\" offset\n    const offsetParenIndex = fileInfo.lastIndexOf(\"(\");\n    if (offsetParenIndex >= 0) {\n      fileInfo = fileInfo.slice(0, offsetParenIndex);\n    }\n\n    // 3. Handle file:// protocol\n    if (fileInfo.startsWith(\"file://\")) {\n      fileInfo = fileInfo.slice(7);\n    }\n\n    // 4. Separate file, line, and column\n    const lastColon = fileInfo.lastIndexOf(\":\");\n    if (lastColon === -1) continue; // Malformed\n    const secondLastColon = fileInfo.lastIndexOf(\":\", lastColon - 1);\n    if (secondLastColon === -1) continue; // Malformed\n\n    const filePath = fileInfo.slice(0, secondLastColon);\n    const fileName = filePath.split(\"/\").pop() ?? \"\";\n    const lineNumberStr = fileInfo.slice(secondLastColon + 1, lastColon);\n    const columnNumberStr = fileInfo.slice(lastColon + 1);\n\n    frames.push({\n      functionName,\n      filePath,\n      fileName,\n      lineNumber: parseInt(lineNumberStr, 10),\n      columnNumber: parseInt(columnNumberStr, 10),\n    });\n  }\n\n  return frames;\n}\n", "export const ANSI_COLORS = {\n  reset: \"\\x1b[0m\",\n\n  // Standard Colors\n  black: \"\\x1b[30m\",\n  red: \"\\x1b[31m\",\n  green: \"\\x1b[32m\",\n  yellow: \"\\x1b[33m\",\n  blue: \"\\x1b[34m\",\n  magenta: \"\\x1b[35m\",\n  cyan: \"\\x1b[36m\",\n  white: \"\\x1b[37m\",\n\n  // Bright Colors\n  brightBlack: \"\\x1b[90m\",\n  brightRed: \"\\x1b[91m\",\n  brightGreen: \"\\x1b[92m\",\n  brightYellow: \"\\x1b[93m\",\n  brightBlue: \"\\x1b[94m\",\n  brightMagenta: \"\\x1b[95m\",\n  brightCyan: \"\\x1b[96m\",\n  brightWhite: \"\\x1b[97m\",\n\n  // Dark Colors\n  darkGrey: \"\\x1b[90m\",\n} as const;\n\nexport function colorize(\n  text: string | undefined,\n  color: keyof typeof ANSI_COLORS,\n): string {\n  return `${ANSI_COLORS[color]}${text}${ANSI_COLORS.reset}`;\n}\n", "import type { ExecutionContext } from \"./execution.ts\";\nimport { type ANSI_COLORS, colorize } from \"./colors.ts\";\nimport type { DisplayFormat, RenderConfig } from \"./config.ts\";\n\n/**\n * The interface that all matchers error renderers must implement.\n */\nexport interface MatcherErrorRenderer {\n  render(info: RenderedErrorInfo, config: RenderConfig): string;\n}\n\n/**\n * The data structure holding all info to be rendered when a matcher fails.\n *\n * Because some matchers require additional info to be rendered, we use a generic type\n * to allow for additional properties to be added to the info structure.\n */\nexport interface MatcherErrorInfo extends RenderedErrorInfo {\n  matcherSpecific?: Record<string, unknown>;\n  customMessage?: string;\n}\n\n/**\n * The data structure holding all info to be rendered.\n */\nexport interface RenderedErrorInfo {\n  // The execution context of the assertion, holding the file name, line number, and column number\n  // where the assertion was called.\n  executionContext: ExecutionContext;\n\n  // This would be something like: \"expect(received).toBe(expected)\"\n  // plus color info or text appended for extra context.\n  matcherName: string;\n\n  // The underlying operation that was used to make the assertion. e.g. \"Object.is\".\n  matcherOperation?: string;\n\n  // The expected value. e.g. \"false\".\n  expected: string;\n\n  // The received value. e.g. \"true\".\n  received: string;\n\n  // The stacktrace of the assertion. e.g. \"Error\".\n  stacktrace?: string;\n}\n\n/**\n * A registry of matchers error renderers.\n */\nexport class MatcherErrorRendererRegistry {\n  private static renderers: Map<string, MatcherErrorRenderer> = new Map();\n  private static config: RenderConfig = { colorize: true, display: \"pretty\" };\n\n  static register(matcherName: string, renderer: MatcherErrorRenderer) {\n    this.renderers.set(matcherName, renderer);\n  }\n\n  static getRenderer(matcherName: string): MatcherErrorRenderer {\n    return this.renderers.get(matcherName) || new DefaultMatcherErrorRenderer();\n  }\n\n  static configure(config: RenderConfig) {\n    this.config = { ...this.config, ...config };\n  }\n\n  static getConfig(): RenderConfig {\n    return this.config;\n  }\n}\n\n/**\n * Base class for all matcher error renderers that implements common functionality\n */\nexport abstract class BaseMatcherErrorRenderer implements MatcherErrorRenderer {\n  protected getReceivedPlaceholder(): string {\n    return \"received\";\n  }\n\n  protected getExpectedPlaceholder(): string {\n    return \"expected\";\n  }\n\n  protected abstract getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[];\n\n  protected abstract getMatcherName(): string;\n\n  protected renderErrorLine(\n    info: RenderedErrorInfo,\n    config: RenderConfig,\n  ): string {\n    const maybeColorize = (text: string, color: keyof typeof ANSI_COLORS) =>\n      config.colorize ? colorize(text, color) : text;\n\n    if (\"customMessage\" in info && typeof info.customMessage === \"string\") {\n      return maybeColorize(info.customMessage, \"white\");\n    }\n\n    return maybeColorize(`expect(`, \"darkGrey\") +\n      maybeColorize(this.getReceivedPlaceholder(), \"red\") +\n      maybeColorize(`).`, \"darkGrey\") +\n      maybeColorize(this.getMatcherName(), \"white\") +\n      this.renderMatcherArgs(maybeColorize);\n  }\n\n  protected renderMatcherArgs(\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): string {\n    return maybeColorize(`()`, \"darkGrey\");\n  }\n\n  render(info: MatcherErrorInfo, config: RenderConfig): string {\n    const maybeColorize = (text: string, color: keyof typeof ANSI_COLORS) =>\n      config.colorize ? colorize(text, color) : text;\n\n    const lines: LineGroup[] = [\n      { label: \"Error\", value: this.renderErrorLine(info, config), group: 1 },\n      {\n        label: \"At\",\n        value: maybeColorize(\n          info.executionContext.at || \"unknown location\",\n          \"darkGrey\",\n        ),\n        group: 1,\n      },\n\n      ...this.getSpecificLines(info, maybeColorize),\n\n      {\n        label: \"Filename\",\n        value: maybeColorize(info.executionContext.fileName, \"darkGrey\"),\n        group: 99,\n      },\n      {\n        label: \"Line\",\n        value: maybeColorize(\n          info.executionContext.lineNumber.toString(),\n          \"darkGrey\",\n        ),\n        group: 99,\n      },\n    ];\n\n    return DisplayFormatRegistry.getFormatter(config.display).renderLines(\n      lines,\n    );\n  }\n}\n\n/**\n * Base class for matchers that only show the received value\n */\nexport abstract class ReceivedOnlyMatcherRenderer\n  extends BaseMatcherErrorRenderer {\n  protected getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 2,\n      },\n    ];\n  }\n}\n\n/**\n * Base class for matchers that show both expected and received values\n */\nexport abstract class ExpectedReceivedMatcherRenderer\n  extends BaseMatcherErrorRenderer {\n  protected getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 2,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 2,\n      },\n    ];\n  }\n\n  protected override renderMatcherArgs(\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): string {\n    return maybeColorize(`(`, \"darkGrey\") +\n      maybeColorize(this.getExpectedPlaceholder(), \"green\") +\n      maybeColorize(`)`, \"darkGrey\");\n  }\n}\n\n/**\n * The default matcher error renderer.\n */\nexport class DefaultMatcherErrorRenderer implements MatcherErrorRenderer {\n  render(info: RenderedErrorInfo, config: RenderConfig): string {\n    const maybeColorize = (text: string, color: keyof typeof ANSI_COLORS) =>\n      config.colorize ? colorize(text, color) : text;\n    const lines: LineGroup[] = [\n      { label: \"Error\", value: this.renderErrorLine(info, config), group: 1 },\n      {\n        label: \"At\",\n        value: maybeColorize(\n          info.executionContext.at || \"unknown location\",\n          \"darkGrey\",\n        ),\n        group: 1,\n      },\n\n      {\n        label: \"Expected\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 2,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 2,\n      },\n\n      {\n        label: \"Filename\",\n        value: maybeColorize(info.executionContext.fileName, \"darkGrey\"),\n        group: 3,\n      },\n      {\n        label: \"Line\",\n        value: maybeColorize(\n          info.executionContext.lineNumber.toString(),\n          \"darkGrey\",\n        ),\n        group: 3,\n      },\n    ];\n\n    return DisplayFormatRegistry.getFormatter(config.display).renderLines(\n      lines,\n    );\n  }\n\n  protected renderErrorLine(\n    info: RenderedErrorInfo,\n    config: RenderConfig,\n  ): string {\n    const maybeColorize = (text: string, color: keyof typeof ANSI_COLORS) =>\n      config.colorize ? colorize(text, color) : text;\n    return maybeColorize(`expect(`, \"darkGrey\") +\n      maybeColorize(`received`, \"red\") +\n      maybeColorize(`).`, \"darkGrey\") +\n      maybeColorize(`${info.matcherName}`, \"white\") +\n      maybeColorize(`(`, \"darkGrey\") +\n      maybeColorize(`expected`, \"green\") +\n      maybeColorize(`)`, \"darkGrey\");\n  }\n}\n\ninterface DisplayFormatRenderer {\n  renderLines(lines: LineGroup[]): string;\n}\n\n/**\n * Pretty format renderer that groups and aligns output\n *\n * Note that any stylization of the lines, such as colorization is expected to\n * be done by the caller.\n */\nclass PrettyFormatRenderer implements DisplayFormatRenderer {\n  renderLines(lines: LineGroup[]): string {\n    const maxLabelWidth = Math.max(\n      ...lines\n        .filter((line) => !line.raw)\n        .map(({ label }: { label: string }) => (label + \":\").length),\n    );\n\n    return \"\\n\\n\" + lines\n      .map(({ label, value, raw }, index) => {\n        let line: string;\n        if (raw) {\n          line = value;\n        } else {\n          const labelWithColon = label + \":\";\n          const spaces = \" \".repeat(maxLabelWidth - labelWithColon.length);\n          line = spaces + labelWithColon + \" \" + value;\n        }\n\n        // Add newlines before a new group of lines (except for the first group)\n        const nextLine = lines[index + 1];\n        if (nextLine && lines[index].group !== nextLine.group) {\n          return line + \"\\n\";\n        }\n        return line;\n      })\n      .join(\"\\n\") +\n      \"\\n\\n\";\n  }\n}\n\n/**\n * Inline format renderer that outputs in logfmt style\n */\nclass InlineFormatRenderer implements DisplayFormatRenderer {\n  renderLines(lines: LineGroup[]): string {\n    return lines\n      .map(({ label, value }) => {\n        // Escape any spaces or special characters in the value\n        const escapedValue = typeof value === \"string\"\n          ? value.includes(\" \") ? `\"${value}\"` : value\n          : value;\n        // Convert label to lowercase and replace spaces with underscores\n        const escapedLabel = label.toLowerCase().replace(/\\s+/g, \"_\");\n        return `${escapedLabel}=${escapedValue}`;\n      })\n      .join(\" \");\n  }\n}\n\nclass DisplayFormatRegistry {\n  private static formatters: Map<DisplayFormat, DisplayFormatRenderer> =\n    new Map([\n      [\"pretty\", new PrettyFormatRenderer()],\n      [\"inline\", new InlineFormatRenderer()],\n    ]);\n\n  static getFormatter(format: DisplayFormat): DisplayFormatRenderer {\n    const formatter = this.formatters.get(format);\n    if (!formatter) {\n      throw new Error(`Unknown display format: ${format}`);\n    }\n    return formatter;\n  }\n}\n\n/**\n * A line with a label and a value.\n *\n * The label is the text before the colon, and the value is the text after the colon.\n *\n * The group number is used to align the lines at the same column and group them into\n * newline separated sections.\n */\nexport interface LineGroup {\n  // The label of the line.\n  label: string;\n\n  // The value of the line.\n  value: string;\n\n  // The group number of the line. Lines with the same group number are aligned at the same column.\n  group?: number;\n\n  // If true, the line is not formatted and is output as raw text.\n  raw?: boolean;\n}\n", "import { assert } from \"./assert.ts\";\nimport type { ANSI_COLORS } from \"./colors.ts\";\nimport type { ExpectConfig } from \"./config.ts\";\nimport { captureExecutionContext } from \"./execution.ts\";\nimport { parseStackTrace } from \"./stacktrace.ts\";\nimport {\n  DefaultMatcherErrorRenderer,\n  ExpectedReceivedMatcherRenderer,\n  type LineGroup,\n  type MatcherErrorInfo,\n  MatcherErrorRendererRegistry,\n  ReceivedOnlyMatcherRenderer,\n} from \"./render.ts\";\n\nexport interface NonRetryingExpectation {\n  /**\n   * Negates the expectation, causing the assertion to pass when it would normally fail, and vice versa.\n   */\n  not: NonRetryingExpectation;\n\n  /**\n   * Asserts that the value is equal to the expected value.\n   *\n   * @param expected the expected value\n   */\n  toBe(expected: unknown): void;\n\n  /**\n   * Asserts that the value is close to the expected value with a given precision.\n   *\n   * @param expected the expected value\n   * @param precision the number of decimal places to consider\n   */\n  toBeCloseTo(expected: number, precision?: number): void;\n\n  /**\n   * Asserts that the value is not `undefined`.\n   */\n  toBeDefined(): void;\n\n  /**\n   * Asserts that the value is truthy.\n   */\n  toBeFalsy(): void;\n\n  /**\n   * Asserts that the value is greater than the expected value.\n   *\n   * @param expected the expected value\n   */\n  toBeGreaterThan(expected: number): void;\n\n  /**\n   * Asserts that the value is greater than or equal to the expected value.\n   *\n   * @param expected\n   */\n  toBeGreaterThanOrEqual(expected: number): void;\n\n  /**\n   * Ensures that value is an instance of a class. Uses instanceof operator.\n   *\n   * @param expected The class or constructor function.\n   */\n  // deno-lint-ignore ban-types\n  toBeInstanceOf(expected: Function): void;\n\n  /**\n   * Asserts that the value is less than the expected value.\n   *\n   * @param expected the expected value\n   */\n  toBeLessThan(expected: number): void;\n\n  /**\n   * Ensures that value <= expected for number or big integer values.\n   *\n   * @param expected The value to compare to.\n   */\n  toBeLessThanOrEqual(expected: number | bigint): void;\n\n  /**\n   * Ensures that value is NaN.\n   */\n  toBeNaN(): void;\n\n  /**\n   * Ensures that value is null.\n   */\n  toBeNull(): void;\n\n  /**\n   * Ensures that value is true in a boolean context, anything but false, 0, '', null, undefined or NaN.\n   * Use this method when you don't care about the specific value.\n   */\n  toBeTruthy(): void;\n\n  /**\n   * Ensures that value is `undefined`.\n   */\n  toBeUndefined(): void;\n\n  /**\n   * Asserts that the value is equal to the expected value.\n   *\n   * @param expected the expected value\n   */\n  toEqual(expected: unknown): void;\n\n  /**\n   * Ensures that value has a `.length` property equal to expected.\n   * Useful for arrays and strings.\n   *\n   * @param expected\n   */\n  toHaveLength(expected: number): void;\n\n  /**\n   * Ensures that a string contains an expected substring using a case-sensitive comparison,\n   * or that an Array or Set contains an expected item.\n   *\n   * @param expected The substring or item to check for\n   */\n  toContain(expected: unknown): void;\n\n  /**\n   * Ensures that value is an Array or Set and contains an item equal to the expected.\n   *\n   * For objects, this method recursively checks equality of all fields, rather than comparing objects by reference.\n   * For primitive values, this method is equivalent to expect(value).toContain().\n   *\n   * @param expected The item to check for deep equality within the collection\n   */\n  toContainEqual(expected: unknown): void;\n\n  /**\n   * Ensures that property at provided `keyPath` exists on the object and optionally checks\n   * that property is equal to the expected. Equality is checked recursively, similarly to expect(value).toEqual().\n   *\n   * @param keyPath Path to the property. Use dot notation a.b to check nested properties\n   *                and indexed a[2] notation to check nested array items.\n   * @param expected Optional expected value to compare the property to.\n   */\n  toHaveProperty(keyPath: string, expected?: unknown): void;\n}\n\n/**\n * createExpectation is a factory function that creates an expectation object for a given value.\n *\n * It effectively implements the NonRetryingExpectation interface, and provides the actual\n * implementation of the matchers attached to the expectation object.\n *\n * @param received the value to create an expectation for\n * @param config the configuration for the expectation\n * @param message the optional custom message for the expectation\n * @param isNegated whether the expectation is negated\n * @returns an expectation object over the given value exposing the Expectation set of methods\n */\nexport function createExpectation(\n  received: unknown,\n  config: ExpectConfig,\n  message?: string,\n  isNegated: boolean = false,\n): NonRetryingExpectation {\n  // In order to facilitate testing, we support passing in a custom assert function.\n  // As a result, we need to make sure that the assert function is always available, and\n  // if not, we need to use the default assert function.\n  //\n  // From this point forward, we will use the `usedAssert` variable to refer to the assert function.\n  const usedAssert = config.assertFn ?? assert;\n\n  // Configure the renderer with the colorize option.\n  MatcherErrorRendererRegistry.configure({\n    colorize: config.colorize,\n    display: config.display,\n  });\n\n  // Register renderers specific to each matchers at initialization time.\n  MatcherErrorRendererRegistry.register(\n    \"toBe\",\n    new DefaultMatcherErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeCloseTo\",\n    new ToBeCloseToErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeDefined\",\n    new ToBeDefinedErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeFalsy\",\n    new ToBeFalsyErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeGreaterThan\",\n    new ToBeGreaterThanErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeGreaterThanOrEqual\",\n    new ToBeGreaterThanOrEqualErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeInstanceOf\",\n    new ToBeInstanceOfErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeLessThan\",\n    new ToBeLessThanErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeLessThanOrEqual\",\n    new ToBeLessThanOrEqualErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\"toBeNaN\", new ToBeNaNErrorRenderer());\n  MatcherErrorRendererRegistry.register(\n    \"toBeNull\",\n    new ToBeNullErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeTruthy\",\n    new ToBeTruthyErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeUndefined\",\n    new ToBeUndefinedErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\"toEqual\", new ToEqualErrorRenderer());\n  MatcherErrorRendererRegistry.register(\n    \"toHaveLength\",\n    new ToHaveLengthErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toContain\",\n    new ToContainErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toContainEqual\",\n    new ToContainEqualErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toHaveProperty\",\n    new ToHavePropertyErrorRenderer(),\n  );\n\n  const matcherConfig = {\n    usedAssert,\n    isSoft: config.soft,\n    isNegated,\n    message,\n  };\n\n  const expectation: NonRetryingExpectation = {\n    get not(): NonRetryingExpectation {\n      return createExpectation(received, config, message, !isNegated);\n    },\n\n    toBe(expected: unknown): void {\n      createMatcher(\n        \"toBe\",\n        () => Object.is(received, expected),\n        expected,\n        received,\n        matcherConfig,\n      );\n    },\n\n    toBeCloseTo(expected: number, precision: number = 2): void {\n      const tolerance = Math.pow(10, -precision) *\n        Math.max(Math.abs(received as number), Math.abs(expected));\n      const diff = Math.abs((received as number) - expected);\n\n      createMatcher(\n        \"toBeCloseTo\",\n        () => diff < tolerance,\n        expected,\n        received,\n        {\n          ...matcherConfig,\n          matcherSpecific: {\n            precision,\n            difference: diff,\n            expectedDifference: tolerance,\n          },\n        },\n      );\n    },\n\n    toBeDefined(): void {\n      createMatcher(\n        \"toBeDefined\",\n        () => received !== undefined,\n        \"defined\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toBeFalsy(): void {\n      createMatcher(\n        \"toBeFalsy\",\n        () => !received,\n        \"falsy\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toBeGreaterThan(expected: number | bigint): void {\n      createMatcher(\n        \"toBeGreaterThan\",\n        () => (received as number) > expected,\n        expected,\n        received,\n        matcherConfig,\n      );\n    },\n\n    toBeGreaterThanOrEqual(expected: number | bigint): void {\n      createMatcher(\n        \"toBeGreaterThanOrEqual\",\n        () => (received as number) >= expected,\n        expected,\n        received,\n        matcherConfig,\n      );\n    },\n\n    // deno-lint-ignore ban-types\n    toBeInstanceOf(expected: Function): void {\n      createMatcher(\n        \"toBeInstanceOf\",\n        () => received instanceof expected,\n        expected.name,\n        (received as { constructor: { name: string } }).constructor.name,\n        matcherConfig,\n      );\n    },\n\n    toBeLessThan(expected: number | bigint): void {\n      createMatcher(\n        \"toBeLessThan\",\n        () => (received as number) < expected,\n        expected,\n        received,\n        matcherConfig,\n      );\n    },\n\n    toBeLessThanOrEqual(expected: number | bigint): void {\n      createMatcher(\n        \"toBeLessThanOrEqual\",\n        () => (received as number) <= expected,\n        expected,\n        received,\n        matcherConfig,\n      );\n    },\n\n    toBeNaN(): void {\n      createMatcher(\n        \"toBeNaN\",\n        () => isNaN(received as number),\n        \"NaN\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toBeNull(): void {\n      createMatcher(\n        \"toBeNull\",\n        () => received === null,\n        \"null\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toBeTruthy(): void {\n      createMatcher(\n        \"toBeTruthy\",\n        () => !!received,\n        \"truthy\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toBeUndefined(): void {\n      createMatcher(\n        \"toBeUndefined\",\n        () => received === undefined,\n        \"undefined\",\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toEqual(expected: unknown): void {\n      createMatcher(\n        \"toEqual\",\n        () => isDeepEqual(received, expected),\n        JSON.stringify(expected),\n        JSON.stringify(received),\n        matcherConfig,\n      );\n    },\n\n    toHaveLength(expected: number): void {\n      createMatcher(\n        \"toHaveLength\",\n        () => (received as Array<unknown>).length === expected,\n        expected.toString(),\n        (received as Array<unknown>).length.toString(),\n        matcherConfig,\n      );\n    },\n\n    toContain(expected: unknown): void {\n      let receivedType = \"\";\n      if (typeof received === \"string\") {\n        receivedType = \"string\";\n      } else if (Array.isArray(received)) {\n        receivedType = \"array\";\n      } else if (received instanceof Set) {\n        receivedType = \"set\";\n      } else {\n        throw new Error(\n          \"toContain is only supported for strings, arrays, and sets\",\n        );\n      }\n      createMatcher(\n        \"toContain\",\n        () => {\n          if (typeof received === \"string\") {\n            return received.includes(expected as string);\n          } else if (Array.isArray(received)) {\n            return received.includes(expected);\n          } else if (received instanceof Set) {\n            return Array.from(received).includes(expected);\n          } else {\n            throw new Error(\n              \"toContain is only supported for strings, arrays, and sets\",\n            );\n          }\n        },\n        expected,\n        received,\n        {\n          ...matcherConfig,\n          matcherSpecific: {\n            receivedType,\n          },\n        },\n      );\n    },\n\n    toContainEqual(expected: unknown): void {\n      let receivedType = \"\";\n      if (Array.isArray(received)) {\n        receivedType = \"array\";\n      } else if (received instanceof Set) {\n        receivedType = \"set\";\n      } else {\n        throw new Error(\n          \"toContainEqual is only supported for arrays and sets\",\n        );\n      }\n\n      createMatcher(\n        \"toContainEqual\",\n        () => {\n          if (Array.isArray(received)) {\n            return received.some((item) => isDeepEqual(item, expected));\n          } else if (received instanceof Set) {\n            return Array.from(received).some((item) =>\n              isDeepEqual(item, expected)\n            );\n          } else {\n            throw new Error(\n              \"toContainEqual is only supported for arrays and sets\",\n            );\n          }\n        },\n        expected,\n        received,\n        {\n          ...matcherConfig,\n          matcherSpecific: {\n            receivedType,\n          },\n        },\n      );\n    },\n\n    toHaveProperty(keyPath: string, expected?: unknown): void {\n      if (typeof received !== \"object\" || received === null) {\n        throw new Error(\n          \"toHaveProperty is only supported for objects\",\n        );\n      }\n\n      const hasProperty = () => {\n        try {\n          const value = getPropertyByPath(\n            received as Record<string, unknown>,\n            keyPath,\n          );\n          return expected !== undefined ? isDeepEqual(value, expected) : true;\n        } catch (_) {\n          return false;\n        }\n      };\n\n      createMatcher(\n        \"toHaveProperty\",\n        hasProperty,\n        expected !== undefined ? expected : keyPath,\n        received,\n        {\n          ...matcherConfig,\n          matcherSpecific: {\n            keyPath,\n            hasExpectedValue: expected !== undefined,\n          },\n        },\n      );\n    },\n  };\n\n  return expectation;\n}\n\n// Helper function to handle common matcher logic\nfunction createMatcher(\n  matcherName: string,\n  checkFn: () => boolean,\n  expected: unknown,\n  received: unknown,\n  {\n    usedAssert,\n    isSoft,\n    isNegated = false,\n    matcherSpecific = {},\n    message,\n  }: {\n    usedAssert: typeof assert;\n    isSoft: boolean;\n    isNegated?: boolean;\n    matcherSpecific?: Record<string, unknown>;\n    message?: string;\n  },\n): void {\n  const info = createMatcherInfo(\n    matcherName,\n    expected,\n    received,\n    { ...matcherSpecific, isNegated },\n    message,\n  );\n\n  const result = checkFn();\n  // If isNegated is true, we want to invert the result\n  const finalResult = isNegated ? !result : result;\n\n  usedAssert(\n    finalResult,\n    MatcherErrorRendererRegistry.getRenderer(matcherName).render(\n      info,\n      MatcherErrorRendererRegistry.getConfig(),\n    ),\n    isSoft,\n  );\n}\n\nfunction createMatcherInfo(\n  matcherName: string,\n  expected: string | unknown,\n  received: unknown,\n  matcherSpecific: Record<string, unknown> = {},\n  customMessage?: string,\n): MatcherErrorInfo {\n  const stacktrace = parseStackTrace(new Error().stack);\n  const executionContext = captureExecutionContext(stacktrace);\n\n  if (!executionContext) {\n    throw new Error(\"k6 failed to capture execution context\");\n  }\n\n  return {\n    executionContext,\n    matcherName,\n    expected: typeof expected === \"string\"\n      ? expected\n      : JSON.stringify(expected),\n    received: JSON.stringify(received),\n    matcherSpecific,\n    customMessage,\n  };\n}\n\n/**\n * A matcher error renderer for the `toBeCloseTo` matcher.\n */\nexport class ToBeCloseToErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeCloseTo\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    const matcherInfo = info.matcherSpecific as {\n      precision: number;\n      difference: number;\n      expectedDifference: number;\n    };\n\n    return [\n      {\n        label: \"Expected precision\",\n        value: maybeColorize(matcherInfo.precision.toString(), \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Expected difference\",\n        value: \"< \" +\n          maybeColorize(`${matcherInfo.expectedDifference}`, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received difference\",\n        value: maybeColorize(matcherInfo.difference.toString(), \"red\"),\n        group: 3,\n      },\n    ];\n  }\n\n  protected override renderMatcherArgs(\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): string {\n    return maybeColorize(`(`, \"darkGrey\") +\n      maybeColorize(`expected`, \"green\") +\n      maybeColorize(`, `, \"darkGrey\") +\n      maybeColorize(`precision`, \"white\") +\n      maybeColorize(`)`, \"darkGrey\");\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeDefined` matcher.\n */\nexport class ToBeDefinedErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeDefined\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeFalsy` matcher.\n */\nexport class ToBeFalsyErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeFalsy\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeGreaterThan` matcher.\n */\nexport class ToBeGreaterThanErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeGreaterThan\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: \"> \" + maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeGreaterThanOrEqual` matcher.\n */\nexport class ToBeGreaterThanOrEqualErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeGreaterThanOrEqual\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: \">= \" + maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeInstanceOf` matcher.\n */\nexport class ToBeInstanceOfErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeInstanceOf\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected constructor\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received constructor\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeLessThan` matcher.\n */\nexport class ToBeLessThanErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeLessThan\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: \"< \" + maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeLessThanOrEqual` matcher.\n */\nexport class ToBeLessThanOrEqualErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeLessThanOrEqual\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: \"<= \" + maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeNaN` matcher.\n */\nexport class ToBeNaNErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeNaN\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeNull` matcher.\n */\nexport class ToBeNullErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeNull\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeTruthy` matcher.\n */\nexport class ToBeTruthyErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeTruthy\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toBeUndefined` matcher.\n */\nexport class ToBeUndefinedErrorRenderer extends ReceivedOnlyMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toBeUndefined\";\n  }\n}\n\n/**\n * A matcher error renderer for the `toEqual` matcher.\n */\nexport class ToEqualErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toEqual\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toHaveLength` matcher.\n */\nexport class ToHaveLengthErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toHaveLength\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      {\n        label: \"Expected length\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received length\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n      {\n        label: \"Received array\",\n        value: maybeColorize(\n          info.matcherSpecific?.receivedArray as string,\n          \"red\",\n        ),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toContain` matcher.\n */\nexport class ToContainErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toContain\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    const isNegated = info.matcherSpecific?.isNegated as boolean;\n    const receivedType = typeof info.matcherSpecific?.receivedType === \"string\"\n      ? info.matcherSpecific?.receivedType as string\n      : Array.isArray(JSON.parse(info.received))\n      ? \"array\"\n      : \"string\";\n\n    return [\n      {\n        label: isNegated ? \"Expected not to contain\" : \"Expected to contain\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: `Received ${receivedType}`,\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toContainEqual` matcher.\n */\nexport class ToContainEqualErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toContainEqual\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    const isNegated = info.matcherSpecific?.isNegated as boolean;\n    const receivedType = info.matcherSpecific?.receivedType as string;\n\n    return [\n      {\n        label: isNegated\n          ? \"Expected not to contain equal\"\n          : \"Expected to contain equal\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: `Received ${receivedType}`,\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    ];\n  }\n}\n\n/**\n * A matcher error renderer for the `toHaveProperty` matcher.\n */\nexport class ToHavePropertyErrorRenderer\n  extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toHaveProperty\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    const isNegated = info.matcherSpecific?.isNegated as boolean;\n    const keyPath = info.matcherSpecific?.keyPath as string;\n    const hasExpectedValue = info.matcherSpecific?.hasExpectedValue as boolean;\n\n    const lines: LineGroup[] = [\n      {\n        label: \"Property path\",\n        value: maybeColorize(keyPath, \"white\"),\n        group: 3,\n      },\n    ];\n\n    if (hasExpectedValue) {\n      lines.push(\n        {\n          label: isNegated\n            ? \"Expected property not to equal\"\n            : \"Expected property to equal\",\n          value: maybeColorize(info.expected, \"green\"),\n          group: 3,\n        },\n      );\n    } else {\n      lines.push(\n        {\n          label: isNegated\n            ? \"Expected property not to exist\"\n            : \"Expected property to exist\",\n          value: \"\",\n          group: 3,\n        },\n      );\n    }\n\n    lines.push(\n      {\n        label: \"Received object\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n    );\n\n    return lines;\n  }\n\n  protected override renderMatcherArgs(\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): string {\n    return maybeColorize(`(`, \"darkGrey\") +\n      maybeColorize(`keyPath`, \"white\") +\n      maybeColorize(`, `, \"darkGrey\") +\n      maybeColorize(`expected?`, \"green\") +\n      maybeColorize(`)`, \"darkGrey\");\n  }\n}\n\nfunction isDeepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n\n  if (a === null || b === null) return false;\n  if (typeof a !== \"object\" || typeof b !== \"object\") return false;\n\n  const keysA = Object.keys(a as object);\n  const keysB = Object.keys(b as object);\n\n  if (keysA.length !== keysB.length) return false;\n\n  return keysA.every((key) => {\n    return keysB.includes(key) &&\n      isDeepEqual(\n        (a as Record<string, unknown>)[key],\n        (b as Record<string, unknown>)[key],\n      );\n  });\n}\n\n/**\n * Gets a property value from an object using a path string.\n * Supports dot notation (obj.prop) and array indexing (obj[0] or obj.array[0]).\n *\n * @param obj The object to get the property from\n * @param path The path to the property (e.g. \"a.b[0].c\")\n * @returns The value at the specified path\n * @throws Error if the property doesn't exist\n */\nfunction getPropertyByPath(\n  obj: Record<string, unknown>,\n  path: string,\n): unknown {\n  if (path === \"\") {\n    throw new Error(\"Invalid path: empty string\");\n  }\n\n  // Parse the path into segments\n  const segments: string[] = [];\n  let currentSegment = \"\";\n  let inBrackets = false;\n\n  for (let i = 0; i < path.length; i++) {\n    const char = path[i];\n\n    if (char === \".\" && !inBrackets) {\n      if (currentSegment) {\n        segments.push(currentSegment);\n        currentSegment = \"\";\n      }\n    } else if (char === \"[\") {\n      if (currentSegment) {\n        segments.push(currentSegment);\n        currentSegment = \"\";\n      }\n      inBrackets = true;\n    } else if (char === \"]\") {\n      if (inBrackets) {\n        segments.push(currentSegment);\n        currentSegment = \"\";\n        inBrackets = false;\n      } else {\n        throw new Error(`Invalid path: ${path}`);\n      }\n    } else {\n      currentSegment += char;\n    }\n  }\n\n  // Add the last segment if there is one\n  if (currentSegment) {\n    segments.push(currentSegment);\n  }\n\n  // Traverse the object using the segments\n  let current: unknown = obj;\n\n  for (const segment of segments) {\n    if (current === null || current === undefined) {\n      throw new Error(`Property ${path} does not exist`);\n    }\n\n    if (typeof segment === \"string\" && !isNaN(Number(segment))) {\n      // If segment is a numeric string, treat it as an array index\n      const index = Number(segment);\n      if (!Array.isArray(current)) {\n        throw new Error(`Cannot access index ${segment} of non-array`);\n      }\n      if (index >= (current as unknown[]).length) {\n        throw new Error(`Index ${segment} out of bounds`);\n      }\n      current = (current as unknown[])[index];\n    } else {\n      // Otherwise treat it as an object property\n      if (typeof current !== \"object\") {\n        throw new Error(`Cannot access property ${segment} of non-object`);\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(current, segment)) {\n        throw new Error(`Property ${segment} does not exist on object`);\n      }\n\n      current = (current as Record<string, unknown>)[segment];\n    }\n  }\n\n  return current;\n}\n", "export function normalizeWhiteSpace(value: string): string {\n  return value\n    .replace(/[\\u200B\\u00AD]/g, \"\") // Remove zero-width space and soft hyphen\n    .replace(/\\s+/g, \" \").trim();\n}\n", "import { assert } from \"./assert.ts\";\nimport type { ANSI_COLORS } from \"./colors.ts\";\nimport {\n  DEFAULT_RETRY_OPTIONS,\n  type ExpectConfig,\n  type RetryConfig,\n} from \"./config.ts\";\nimport { captureExecutionContext } from \"./execution.ts\";\nimport {\n  ExpectedReceivedMatcherRenderer,\n  type LineGroup,\n  type MatcherErrorInfo,\n  MatcherErrorRendererRegistry,\n  ReceivedOnlyMatcherRenderer,\n} from \"./render.ts\";\nimport { parseStackTrace } from \"./stacktrace.ts\";\nimport type { Locator } from \"k6/browser\";\nimport { normalizeWhiteSpace } from \"./utils/string.ts\";\n\ninterface ToHaveTextOptions extends RetryConfig {\n  /**\n   * If true, comparison will be case-insensitive. If defined, this option will override the `i` flag of\n   * regular expressions. Defaults to `undefined`.\n   */\n  ignoreCase?: boolean;\n\n  /**\n   * If true, the text will be compared using `innerText()` instead of `textContent()`. Defaults to `false`.\n   */\n  useInnerText?: boolean;\n}\n\n/**\n * RetryingExpectation is an interface that defines the methods that can be used to create a retrying expectation.\n *\n * Retrying expectations are used to assert that a condition is met within a given timeout.\n * The provided assertion function is called repeatedly until the condition is met or the timeout is reached.\n *\n * The RetryingExpectation interface is implemented by the createExpectation function.\n */\nexport interface RetryingExpectation {\n  /**\n   * Negates the expectation, causing the assertion to pass when it would normally fail, and vice versa.\n   */\n  not: RetryingExpectation;\n\n  /**\n   * Ensures the Locator points to a checked input.\n   */\n  toBeChecked(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures the Locator points to a disabled element.\n   * Element is disabled if it has \"disabled\" attribute or is disabled via 'aria-disabled'.\n   *\n   * Note that only native control elements such as HTML button, input, select, textarea, option, optgroup can be disabled by setting \"disabled\" attribute.\n   * \"disabled\" attribute on other elements is ignored by the browser.\n   */\n  toBeDisabled(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures the Locator points to an editable element.\n   */\n  toBeEditable(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures the Locator points to an enabled element.\n   */\n  toBeEnabled(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures that Locator either does not resolve to any DOM node, or resolves to a non-visible one.\n   */\n  toBeHidden(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures that Locator points to an attached and visible DOM node.\n   */\n  toBeVisible(options?: Partial<RetryConfig>): Promise<void>;\n\n  /**\n   * Ensures that the Locator points to an element with the given text.\n   *\n   * If the type of `expected` is a string, both the expected and actual text will have any zero-width\n   * characters removed and whitespace characters collapsed to a single space. If the type of `expected`\n   * is a regular expression, the content of the element will be matched against the regular expression as-is.\n   */\n  toHaveText(\n    expected: RegExp | string,\n    options?: Partial<ToHaveTextOptions>,\n  ): Promise<void>;\n\n  /**\n   * Ensures that the Locator points to an element that contains the given text.\n   *\n   * If the type of `expected` is a string, both the expected and actual text will have any zero-width\n   * characters removed and whitespace characters collapsed to a single space. If the type of `expected`\n   * is a regular expression, the content of the element will be matched against the regular expression as-is.\n   */\n  toContainText(\n    expected: RegExp | string,\n    options?: Partial<ToHaveTextOptions>,\n  ): Promise<void>;\n\n  /**\n   * Ensures the Locator points to an element with the given input value. You can use regular expressions for the value as well.\n   *\n   * @param value {string} the expected value of the input\n   */\n  toHaveValue(value: string, options?: Partial<RetryConfig>): Promise<void>;\n}\n\n/**\n * createExpectation is a factory function that creates an expectation object for a given value.\n *\n * Note that although the browser `is` prefixed methods are used, and return boolean values, we\n * throw errors if the condition is not met. This is to ensure that we align with playwright's\n * API, and have matchers return `Promise<void>`, as opposed to `Promise<boolean>`.\n *\n * @param locator the value to create an expectation for\n * @param config the configuration for the expectation\n * @param message the optional custom message for the expectation\n * @param isNegated whether the expectation is negated\n * @returns an expectation object over the given value exposing the Expectation set of methods\n */\nexport function createExpectation(\n  locator: Locator,\n  config: ExpectConfig,\n  message?: string,\n  isNegated: boolean = false,\n): RetryingExpectation {\n  // In order to facilitate testing, we support passing in a custom assert function.\n  // As a result, we need to make sure that the assert function is always available, and\n  // if not, we need to use the default assert function.\n  //\n  // From this point forward, we will use the `usedAssert` variable to refer to the assert function.\n  const usedAssert = config.assertFn ?? assert;\n  const isSoft = config.soft ?? false;\n  const retryConfig: RetryConfig = {\n    timeout: config.timeout,\n    interval: config.interval,\n  };\n\n  // Configure the renderer with the colorize option.\n  MatcherErrorRendererRegistry.configure({\n    colorize: config.colorize,\n    display: config.display,\n  });\n\n  // Register renderers specific to each matchers at initialization time.\n  MatcherErrorRendererRegistry.register(\n    \"toBeChecked\",\n    new ToBeCheckedErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeDisabled\",\n    new ToBeDisabledErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeEditable\",\n    new ToBeEditableErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeEnabled\",\n    new ToBeEnabledErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeHidden\",\n    new ToBeHiddenErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toBeVisible\",\n    new ToBeVisibleErrorRenderer(),\n  );\n  MatcherErrorRendererRegistry.register(\n    \"toHaveValue\",\n    new ToHaveValueErrorRenderer(),\n  );\n\n  const matcherConfig = {\n    locator,\n    retryConfig,\n    usedAssert,\n    isSoft,\n    isNegated,\n    message,\n  };\n\n  const createTextMatcher = (\n    matcherName: string,\n    compareFn: (actual: string, expected: string) => boolean,\n  ) => {\n    return async function toHaveText(\n      expected: RegExp | string,\n      options: Partial<ToHaveTextOptions> = {},\n    ): Promise<void> {\n      const stacktrace = parseStackTrace(new Error().stack);\n      const executionContext = captureExecutionContext(stacktrace);\n\n      if (!executionContext) {\n        throw new Error(\"k6 failed to capture execution context\");\n      }\n\n      const checkRegExp = (expected: RegExp, actual: string) => {\n        // `ignoreCase` should take precedence over the `i` flag of the regex if it is defined.\n        const regexp = options.ignoreCase !== undefined\n          ? new RegExp(\n            expected.source,\n            expected.flags.replace(\"i\", \"\") + (options.ignoreCase ? \"i\" : \"\"),\n          )\n          : expected;\n\n        const info: MatcherErrorInfo = {\n          executionContext,\n          matcherName,\n          expected: regexp.toString(),\n          received: actual,\n          matcherSpecific: { isNegated },\n          customMessage: message,\n        };\n\n        const result = regexp.test(actual);\n\n        usedAssert(\n          isNegated ? !result : result,\n          MatcherErrorRendererRegistry.getRenderer(matcherName).render(\n            info,\n            MatcherErrorRendererRegistry.getConfig(),\n          ),\n          isSoft,\n        );\n      };\n\n      const checkText = (expected: string, actual: string) => {\n        const normalizedExpected = normalizeWhiteSpace(expected);\n        const normalizedActual = normalizeWhiteSpace(actual);\n\n        const info: MatcherErrorInfo = {\n          executionContext,\n          matcherName,\n          expected: normalizedExpected,\n          received: normalizedActual,\n          matcherSpecific: { isNegated },\n          customMessage: message,\n        };\n\n        const result = options.ignoreCase\n          ? compareFn(\n            normalizedActual.toLowerCase(),\n            normalizedExpected.toLowerCase(),\n          )\n          : compareFn(normalizedActual, normalizedExpected);\n\n        usedAssert(\n          isNegated ? !result : result,\n          MatcherErrorRendererRegistry.getRenderer(matcherName).render(\n            info,\n            MatcherErrorRendererRegistry.getConfig(),\n          ),\n          isSoft,\n        );\n      };\n\n      try {\n        await withRetry(\n          async () => {\n            const actualText = options.useInnerText\n              ? await locator.innerText()\n              : await locator.textContent();\n\n            if (actualText === null) {\n              throw new Error(\"Element has no text content\");\n            }\n\n            if (expected instanceof RegExp) {\n              checkRegExp(expected, actualText);\n\n              return;\n            }\n\n            checkText(expected, actualText);\n          },\n          { ...retryConfig, ...options },\n        );\n      } catch (_) {\n        const info: MatcherErrorInfo = {\n          executionContext,\n          matcherName,\n          expected: expected.toString(),\n          received: \"unknown\",\n          matcherSpecific: { isNegated },\n          customMessage: message,\n        };\n\n        usedAssert(\n          false,\n          MatcherErrorRendererRegistry.getRenderer(\"toHaveText\").render(\n            info,\n            MatcherErrorRendererRegistry.getConfig(),\n          ),\n          isSoft,\n        );\n      }\n    };\n  };\n\n  const expectation: RetryingExpectation = {\n    get not(): RetryingExpectation {\n      return createExpectation(locator, config, message, !isNegated);\n    },\n\n    async toBeChecked(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeChecked\",\n        async () => await locator.isChecked(),\n        \"checked\",\n        \"unchecked\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toBeDisabled(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeDisabled\",\n        async () => await locator.isDisabled(),\n        \"disabled\",\n        \"enabled\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toBeEditable(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeEditable\",\n        async () => await locator.isEditable(),\n        \"editable\",\n        \"uneditable\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toBeEnabled(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeEnabled\",\n        async () => await locator.isEnabled(),\n        \"enabled\",\n        \"disabled\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toBeHidden(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeHidden\",\n        async () => await locator.isHidden(),\n        \"hidden\",\n        \"visible\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    async toBeVisible(\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      await createMatcher(\n        \"toBeVisible\",\n        async () => await locator.isVisible(),\n        \"visible\",\n        \"hidden\",\n        { ...matcherConfig, options },\n      );\n    },\n\n    toHaveText: createTextMatcher(\n      \"toHaveText\",\n      (actual, expected) => actual === expected,\n    ),\n\n    toContainText: createTextMatcher(\n      \"toContainText\",\n      (actual, expected) => actual.includes(expected),\n    ),\n\n    async toHaveValue(\n      expectedValue: string,\n      options: Partial<RetryConfig> = retryConfig,\n    ): Promise<void> {\n      const stacktrace = parseStackTrace(new Error().stack);\n      const executionContext = captureExecutionContext(stacktrace);\n      if (!executionContext) {\n        throw new Error(\"k6 failed to capture execution context\");\n      }\n\n      const info: MatcherErrorInfo = {\n        executionContext,\n        matcherName: \"toHaveValue\",\n        expected: expectedValue,\n        received: \"unknown\",\n        matcherSpecific: { isNegated },\n        customMessage: message,\n      };\n\n      try {\n        await withRetry(async () => {\n          const actualValue = await locator.inputValue();\n          const result = expectedValue === actualValue;\n          // If isNegated is true, we want to invert the result\n          const finalResult = isNegated ? !result : result;\n\n          usedAssert(\n            finalResult,\n            MatcherErrorRendererRegistry.getRenderer(\"toHaveValue\").render(\n              info,\n              MatcherErrorRendererRegistry.getConfig(),\n            ),\n            isSoft,\n          );\n        }, { ...retryConfig, ...options });\n      } catch (_) {\n        usedAssert(\n          false,\n          MatcherErrorRendererRegistry.getRenderer(\"toHaveValue\").render(\n            info,\n            MatcherErrorRendererRegistry.getConfig(),\n          ),\n          isSoft,\n        );\n      }\n    },\n  };\n\n  return expectation;\n}\n\n// Helper function to create common matcher info\nfunction createMatcherInfo(\n  matcherName: string,\n  expected: string,\n  received: string,\n  additionalInfo = {},\n  customMessage?: string,\n): MatcherErrorInfo {\n  const stacktrace = parseStackTrace(new Error().stack);\n  const executionContext = captureExecutionContext(stacktrace);\n\n  if (!executionContext) {\n    throw new Error(\"k6 failed to capture execution context\");\n  }\n\n  return {\n    executionContext,\n    matcherName,\n    expected,\n    received,\n    customMessage,\n    ...additionalInfo,\n  };\n}\n\n// Helper function to handle common matcher logic\nasync function createMatcher(\n  matcherName: string,\n  checkFn: () => Promise<boolean>,\n  expected: string,\n  received: string,\n  {\n    locator,\n    retryConfig,\n    usedAssert,\n    isSoft,\n    isNegated = false,\n    options = {},\n    message,\n  }: {\n    locator: Locator;\n    retryConfig: RetryConfig;\n    usedAssert: typeof assert;\n    isSoft: boolean;\n    isNegated?: boolean;\n    options?: Partial<RetryConfig>;\n    message?: string;\n  },\n): Promise<void> {\n  const info = createMatcherInfo(matcherName, expected, received, {\n    matcherSpecific: {\n      locator,\n      timeout: options.timeout,\n      isNegated,\n    },\n  }, message);\n\n  try {\n    await withRetry(async () => {\n      const result = await checkFn();\n      // If isNegated is true, we want to invert the result\n      const finalResult = isNegated ? !result : result;\n\n      if (!finalResult) {\n        throw new Error(\"matcher failed\");\n      }\n\n      usedAssert(\n        finalResult,\n        MatcherErrorRendererRegistry.getRenderer(matcherName).render(\n          info,\n          MatcherErrorRendererRegistry.getConfig(),\n        ),\n        isSoft,\n      );\n    }, { ...retryConfig, ...options });\n  } catch (_) {\n    usedAssert(\n      false,\n      MatcherErrorRendererRegistry.getRenderer(matcherName).render(\n        info,\n        MatcherErrorRendererRegistry.getConfig(),\n      ),\n      isSoft,\n    );\n  }\n}\n\n/**\n * Base class for boolean state matchers (checked, disabled, etc.)\n */\nexport abstract class BooleanStateErrorRenderer\n  extends ReceivedOnlyMatcherRenderer {\n  protected abstract state: string;\n  protected abstract oppositeState: string;\n\n  protected getMatcherName(): string {\n    return `toBe${this.state[0].toUpperCase()}${this.state.slice(1)}`;\n  }\n\n  protected override getReceivedPlaceholder(): string {\n    return \"locator\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      { label: \"Expected\", value: this.state, group: 3 },\n      { label: \"Received\", value: this.oppositeState, group: 3 },\n      { label: \"Call log\", value: \"\", group: 3 },\n      {\n        label: \"\",\n        value: maybeColorize(\n          `  - expect.toBe${this.state[0].toUpperCase()}${\n            this.state.slice(1)\n          } with timeout ${info.matcherSpecific?.timeout}ms`,\n          \"darkGrey\",\n        ),\n        group: 3,\n        raw: true,\n      },\n      {\n        label: \"\",\n        value: maybeColorize(`  - waiting for locator`, \"darkGrey\"),\n        group: 3,\n        raw: true,\n      },\n    ];\n  }\n}\n\nexport class ToBeCheckedErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"checked\";\n  protected oppositeState = \"unchecked\";\n}\n\n/**\n * A matcher error renderer for the `toBeDisabled` matcher.\n */\nexport class ToBeDisabledErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"disabled\";\n  protected oppositeState = \"enabled\";\n}\n\nexport class ToBeEditableErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"editable\";\n  protected oppositeState = \"uneditable\";\n}\n\nexport class ToBeEnabledErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"enabled\";\n  protected oppositeState = \"disabled\";\n}\n\nexport class ToBeHiddenErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"hidden\";\n  protected oppositeState = \"visible\";\n}\n\nexport class ToBeVisibleErrorRenderer extends BooleanStateErrorRenderer {\n  protected state = \"visible\";\n  protected oppositeState = \"hidden\";\n}\n\nexport class ToHaveValueErrorRenderer extends ExpectedReceivedMatcherRenderer {\n  protected getMatcherName(): string {\n    return \"toHaveValue\";\n  }\n\n  protected override getSpecificLines(\n    info: MatcherErrorInfo,\n    maybeColorize: (text: string, color: keyof typeof ANSI_COLORS) => string,\n  ): LineGroup[] {\n    return [\n      // FIXME (@oleiade): When k6/#4210 is fixed, we can use the locator here.\n      // { label: \"Locator\", value: maybeColorize(`locator('${info.matcherSpecific?.locator}')`, \"white\"), group: 3 },\n      {\n        label: \"Expected\",\n        value: maybeColorize(info.expected, \"green\"),\n        group: 3,\n      },\n      {\n        label: \"Received\",\n        value: maybeColorize(info.received, \"red\"),\n        group: 3,\n      },\n      { label: \"Call log\", value: \"\", group: 3 },\n      {\n        label: \"\",\n        value: maybeColorize(\n          `  - expect.toHaveValue with timeout ${info.matcherSpecific?.timeout}ms`,\n          \"darkGrey\",\n        ),\n        group: 3,\n        raw: true,\n      },\n      // FIXME (@oleiade): When k6/#4210 is fixed, we can use the locator's selector here.\n      {\n        label: \"\",\n        value: maybeColorize(`  - waiting for locator`, \"darkGrey\"),\n        group: 3,\n        raw: true,\n      },\n    ];\n  }\n}\n\n/**\n * Implements retry logic for async assertions.\n *\n * @param assertion Function that performs the actual check\n * @param options Retry configuration\n * @returns Promise that resolves when assertion passes or rejects if timeout is reached\n */\nexport async function withRetry(\n  assertion: () => Promise<void>,\n  options: RetryConfig & {\n    // Optional test hooks - only used in testing\n    _now?: () => number;\n    _sleep?: (ms: number) => Promise<void>;\n  } = {},\n): Promise<boolean> {\n  const timeout: number = options.timeout ?? DEFAULT_RETRY_OPTIONS.timeout;\n  const interval: number = options.interval ?? DEFAULT_RETRY_OPTIONS.interval;\n  const getNow = options._now ?? (() => Date.now());\n  const sleep = options._sleep ??\n    ((ms: number) => new Promise((resolve) => setTimeout(resolve, ms)));\n\n  const startTime: number = getNow();\n\n  while (getNow() - startTime < timeout) {\n    try {\n      await assertion();\n      return true;\n    } catch (_error) {\n      // Ignore error and continue retrying\n    }\n\n    await sleep(interval);\n  }\n\n  throw new RetryTimeoutError(\n    `Expect condition not met within ${timeout}ms timeout`,\n  );\n}\n\n/**\n * RetryTimeoutError is an error that is thrown when an expectation is not met within a provided timeout.\n */\nexport class RetryTimeoutError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"RetryTimeoutError\";\n  }\n}\n", "import type { Locator } from \"k6/browser\";\nimport { ConfigLoader, type ExpectConfig } from \"./config.ts\";\nimport {\n  createExpectation as createNonRetryingExpectation,\n  type NonRetryingExpectation,\n} from \"./expectNonRetrying.ts\";\nimport {\n  createExpectation as createRetryingExpectation,\n  type RetryingExpectation,\n} from \"./expectRetrying.ts\";\n\n/**\n * The expect function is used to assert that a value meets certain conditions.\n *\n * The expect function can be used in two ways:\n *\n * 1. Non-retrying: The expect function will perform the assertion only once. If the assertion\n * is not met, the test will fail.\n * 2. Retrying: The expect function will perform the assertion multiple times, until the assertion\n * is met or the timeout is reached. If the assertion is not met, the test will fail.\n *\n * @param {unknown | Locator} value The value to assert.\n */\nexport const expect: ExpectFunction = makeExpect();\n\nexport interface ExpectFunction {\n  /**\n   * The expect function can be used directly to assert that a value meets certain conditions.\n   *\n   * If the value argument provided to it is a Locator, the expect function will\n   * return a (asynchronous) RetryingExpectation, otherwise it will return a NonRetryingExpectation.\n   */\n  <T>(value: T, message?: string): T extends Locator ? RetryingExpectation\n    : NonRetryingExpectation;\n\n  /**\n   * The soft function can be used to assert that a value meets certain conditions, but\n   * without terminating the test if the assertion is not met.\n   */\n  soft<T>(\n    value: T,\n    message?: string,\n  ): T extends Locator ? RetryingExpectation : NonRetryingExpectation;\n\n  /**\n   * Creates a new expect instance with the given configuration.\n   */\n  configure(newConfig: Partial<ExpectConfig>): ExpectFunction;\n\n  /**\n   * The configuration used by the expect function.\n   */\n  readonly config: ExpectConfig;\n}\n\n/**\n * Creates a new expect function with the given configuration.\n *\n * This allows us\n *\n * @param baseConfig The base configuration for the expect function.\n * @returns\n */\nfunction makeExpect(baseConfig?: Partial<ExpectConfig>): ExpectFunction {\n  /**\n   * Loads the configuration for the expect function.\n   */\n  const config = ConfigLoader.load(baseConfig);\n\n  return Object.assign(\n    function <T>(\n      value: T,\n      message?: string,\n    ): T extends Locator ? RetryingExpectation : NonRetryingExpectation {\n      if (isLocator(value)) {\n        return createRetryingExpectation(\n          value as Locator,\n          config,\n          message,\n        ) as T extends Locator ? RetryingExpectation : NonRetryingExpectation;\n      } else {\n        return createNonRetryingExpectation(\n          value,\n          config,\n          message,\n        ) as T extends Locator ? RetryingExpectation : NonRetryingExpectation;\n      }\n    },\n    {\n      soft<T>(\n        value: T,\n        message?: string,\n      ): T extends Locator ? RetryingExpectation : NonRetryingExpectation {\n        if (isLocator(value)) {\n          return createRetryingExpectation(\n            value as Locator,\n            { ...config, soft: true },\n            message,\n          ) as T extends Locator ? RetryingExpectation : NonRetryingExpectation;\n        } else {\n          return createNonRetryingExpectation(\n            value,\n            { ...config, soft: true },\n            message,\n          ) as T extends Locator ? RetryingExpectation : NonRetryingExpectation;\n        }\n      },\n      configure(newConfig: Partial<ExpectConfig>): ExpectFunction {\n        return makeExpect(newConfig);\n      },\n      get config(): ExpectConfig {\n        return { ...config };\n      },\n    },\n  );\n}\n\n/**\n * Checks if the given value is a browser Locator.\n *\n * If it quacks like a duck, it's a duck.\n *\n * @param value The value to check.\n * @returns Whether the value is a Locator.\n */\nfunction isLocator(value: unknown): value is Locator {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  const locatorProperties = [\n    \"clear\",\n    \"isEnabled\",\n    \"isHidden\",\n    \"getAttribute\",\n    \"selectOption\",\n    \"press\",\n    \"type\",\n    \"dispatchEvent\",\n    \"dblclick\",\n    \"setChecked\",\n    \"isDisabled\",\n    \"focus\",\n    \"innerText\",\n    \"inputValue\",\n    \"check\",\n    \"isEditable\",\n    \"fill\",\n    \"textContent\",\n    \"hover\",\n    \"waitFor\",\n    \"click\",\n    \"uncheck\",\n    \"isChecked\",\n    \"isVisible\",\n    \"innerHTML\",\n    \"tap\",\n  ];\n\n  const hasLocatorProperties = (value: object): boolean => {\n    return locatorProperties.every((prop) => prop in value);\n  };\n\n  return (\n    value !== null &&\n    value !== undefined &&\n    typeof value === \"object\" &&\n    hasLocatorProperties(value)\n  );\n}\n"],
  "mappings": "AAWA,OAAOA,OAAU,eAaV,SAASC,EAAOC,EAAoBC,EAAiBC,EAAgB,CAC1E,GAAI,CAAAF,EAEJ,IAAIE,EACF,MAAM,IAAIC,EAAqBF,CAAO,EAKtCH,GAAK,KAAK,MAAMG,CAAO,EAE3B,CAQO,IAAME,EAAN,cAAmC,KAAM,CAC9C,YAAYF,EAAiB,CAC3B,MAAMA,CAAO,EACb,KAAK,KAAO,sBACd,CACF,ECtCA,SAASG,IAA8B,CAErC,OAAI,OAAO,KAAS,IACX,KAAK,IAAI,SAAS,EAIpB,KACT,CAGO,IAAMC,EAAmBD,GAAe,EAKlCE,EAAY,CAIvB,SAASC,EAAsB,CAC7B,OAAOF,EAAIE,CAAG,IAAM,MACtB,EAQA,QAAQA,EAAsB,CAC5B,IAAMC,EAAQH,EAAIE,CAAG,GAAG,YAAY,EACpC,GAAIC,IAAU,OACZ,MAAM,IAAI,MAAM,wBAAwBD,CAAG,aAAa,EAE1D,OAAOC,IAAU,OACnB,EAMA,KAAuBD,EAAaE,EAAuB,CACzD,IAAMD,EAAQH,EAAIE,CAAG,GAAG,YAAY,EACpC,GAAIC,IAAU,OACZ,MAAM,IAAI,MAAM,wBAAwBD,CAAG,aAAa,EAE1D,GAAI,CAACE,EAAc,SAASD,CAAK,EAC/B,MAAM,IAAI,MACR,qBAAqBD,CAAG,qBAAqBE,EAAc,KAAK,IAAI,CAAC,EACvE,EAEF,OAAOD,CACT,EAQA,OAAOE,EAAsB,CAC3B,IAAMF,EAAQH,EAAIK,CAAI,EACtB,GAAI,CAACF,EACH,MAAM,IAAI,MAAM,wBAAwBE,CAAI,aAAa,EAG3D,IAAMC,EAAS,OAAOH,CAAK,EAC3B,GAAI,OAAO,MAAMG,CAAM,GAAK,CAAC,OAAO,SAASA,CAAM,EACjD,MAAM,IAAI,MACR,wBAAwBD,CAAI,iCAAiCF,CAAK,EACpE,EAGF,GAAIG,EAAS,EACX,MAAM,IAAI,MACR,wBAAwBD,CAAI,wCAAwCF,CAAK,EAC3E,EAGF,OAAOG,CACT,CACF,ECrDO,IAAMC,EAA+C,CAE1D,QAAS,IAET,SAAU,GACZ,EAoCaC,GAA+B,CAC1C,GAAGD,EACH,KAAM,GACN,SAAU,GACV,QAAS,SACT,SAAUE,CACZ,EAMaC,EAAN,MAAMC,CAAa,CAOxB,OAAO,KAAKC,EAAwC,CAAC,EAAiB,CACpE,IAAMC,EAAYF,EAAa,YAAY,EAE3C,MAAO,CACL,GAAGH,GACH,GAAGI,EACH,GAAGC,CACL,CACF,CAMA,OAAe,aAAqC,CAClD,IAAMC,EAAgC,CAAC,EAGvC,OAAIC,EAAU,SAAS,qBAAqB,IAC1CD,EAAO,SAAWC,EAAU,QAAQ,qBAAqB,GAIvDA,EAAU,SAAS,oBAAoB,IACzCD,EAAO,QAAUC,EAAU,KACzB,qBACA,CAAC,SAAU,QAAQ,CACrB,GAIEA,EAAU,SAAS,oBAAoB,IACzCD,EAAO,QAAUC,EAAU,OAAO,oBAAoB,GAIpDA,EAAU,SAAS,qBAAqB,IAC1CD,EAAO,SAAWC,EAAU,OAAO,qBAAqB,GAGnDD,CACT,CACF,EChGO,SAASE,EACdC,EAC8B,CAC9B,GAAI,CAACA,GAAMA,EAAG,QAAU,EACtB,OAGF,IAAMC,EAAyBD,EAAGA,EAAG,OAAS,CAAC,EAEzCE,EAAWD,EAAW,SACtBE,EAAWF,EAAW,SACtBG,EAAaH,EAAW,WACxBI,EAAeJ,EAAW,aAC1BK,EAAK,GAAGJ,CAAQ,IAAIE,CAAU,IAAIC,CAAY,GAEpD,MAAO,CACL,SAAAH,EACA,SAAAC,EACA,WAAAC,EACA,aAAAC,EACA,GAAAC,CACF,CACF,CClCO,SAASC,EAAgBC,EAA4B,CAE1D,GAAI,CAACA,EAAO,MAAO,CAAC,EAEpB,IAAMC,EAAQD,EAAM,MAAM;AAAA,CAAI,EACxBE,EAAuB,CAAC,EAE9B,QAASC,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAAK,CACrC,IAAIC,EAAUH,EAAME,CAAC,EAAE,KAAK,EAI5B,GADIA,IAAM,GAAKC,EAAQ,WAAW,OAAO,GACrC,CAACA,EAAQ,WAAW,KAAK,EAAG,SAGhCA,EAAUA,EAAQ,MAAM,CAAC,EAAE,KAAK,EAGhC,IAAIC,EAAe,cACfC,EAAWF,EACTG,EAAkBH,EAAQ,QAAQ,GAAG,EACrCI,EAAoBJ,EAAQ,QAAQ,SAAS,EAE/CI,IAAsB,GACxBH,EAAe,cACfC,EAAWF,EAAQ,MAAMI,CAAiB,GACjCD,GAAmB,GAC5BF,EAAeD,EAAQ,MAAM,EAAGG,CAAe,EAAE,KAAK,GAAK,cAC3DD,EAAWF,EACR,MAAMG,EAAkB,EAAGH,EAAQ,YAAY,GAAG,CAAC,EACnD,KAAK,GAERE,EAAWF,EAIb,IAAMK,EAAmBH,EAAS,YAAY,GAAG,EAC7CG,GAAoB,IACtBH,EAAWA,EAAS,MAAM,EAAGG,CAAgB,GAI3CH,EAAS,WAAW,SAAS,IAC/BA,EAAWA,EAAS,MAAM,CAAC,GAI7B,IAAMI,EAAYJ,EAAS,YAAY,GAAG,EAC1C,GAAII,IAAc,GAAI,SACtB,IAAMC,EAAkBL,EAAS,YAAY,IAAKI,EAAY,CAAC,EAC/D,GAAIC,IAAoB,GAAI,SAE5B,IAAMC,EAAWN,EAAS,MAAM,EAAGK,CAAe,EAC5CE,EAAWD,EAAS,MAAM,GAAG,EAAE,IAAI,GAAK,GACxCE,EAAgBR,EAAS,MAAMK,EAAkB,EAAGD,CAAS,EAC7DK,EAAkBT,EAAS,MAAMI,EAAY,CAAC,EAEpDR,EAAO,KAAK,CACV,aAAAG,EACA,SAAAO,EACA,SAAAC,EACA,WAAY,SAASC,EAAe,EAAE,EACtC,aAAc,SAASC,EAAiB,EAAE,CAC5C,CAAC,CACH,CAEA,OAAOb,CACT,CCpGO,IAAMc,GAAc,CACzB,MAAO,UAGP,MAAO,WACP,IAAK,WACL,MAAO,WACP,OAAQ,WACR,KAAM,WACN,QAAS,WACT,KAAM,WACN,MAAO,WAGP,YAAa,WACb,UAAW,WACX,YAAa,WACb,aAAc,WACd,WAAY,WACZ,cAAe,WACf,WAAY,WACZ,YAAa,WAGb,SAAU,UACZ,EAEO,SAASC,EACdC,EACAC,EACQ,CACR,MAAO,GAAGH,GAAYG,CAAK,CAAC,GAAGD,CAAI,GAAGF,GAAY,KAAK,EACzD,CCkBO,IAAMI,EAAN,KAAmC,CACxC,OAAe,UAA+C,IAAI,IAClE,OAAe,OAAuB,CAAE,SAAU,GAAM,QAAS,QAAS,EAE1E,OAAO,SAASC,EAAqBC,EAAgC,CACnE,KAAK,UAAU,IAAID,EAAaC,CAAQ,CAC1C,CAEA,OAAO,YAAYD,EAA2C,CAC5D,OAAO,KAAK,UAAU,IAAIA,CAAW,GAAK,IAAIE,CAChD,CAEA,OAAO,UAAUC,EAAsB,CACrC,KAAK,OAAS,CAAE,GAAG,KAAK,OAAQ,GAAGA,CAAO,CAC5C,CAEA,OAAO,WAA0B,CAC/B,OAAO,KAAK,MACd,CACF,EAKsBC,EAAf,KAAwE,CACnE,wBAAiC,CACzC,MAAO,UACT,CAEU,wBAAiC,CACzC,MAAO,UACT,CASU,gBACRC,EACAF,EACQ,CACR,IAAMG,EAAgB,CAACC,EAAcC,IACnCL,EAAO,SAAWM,EAASF,EAAMC,CAAK,EAAID,EAE5C,MAAI,kBAAmBF,GAAQ,OAAOA,EAAK,eAAkB,SACpDC,EAAcD,EAAK,cAAe,OAAO,EAG3CC,EAAc,UAAW,UAAU,EACxCA,EAAc,KAAK,uBAAuB,EAAG,KAAK,EAClDA,EAAc,KAAM,UAAU,EAC9BA,EAAc,KAAK,eAAe,EAAG,OAAO,EAC5C,KAAK,kBAAkBA,CAAa,CACxC,CAEU,kBACRA,EACQ,CACR,OAAOA,EAAc,KAAM,UAAU,CACvC,CAEA,OAAOD,EAAwBF,EAA8B,CAC3D,IAAMG,EAAgB,CAACC,EAAcC,IACnCL,EAAO,SAAWM,EAASF,EAAMC,CAAK,EAAID,EAEtCG,EAAqB,CACzB,CAAE,MAAO,QAAS,MAAO,KAAK,gBAAgBL,EAAMF,CAAM,EAAG,MAAO,CAAE,EACtE,CACE,MAAO,KACP,MAAOG,EACLD,EAAK,iBAAiB,IAAM,mBAC5B,UACF,EACA,MAAO,CACT,EAEA,GAAG,KAAK,iBAAiBA,EAAMC,CAAa,EAE5C,CACE,MAAO,WACP,MAAOA,EAAcD,EAAK,iBAAiB,SAAU,UAAU,EAC/D,MAAO,EACT,EACA,CACE,MAAO,OACP,MAAOC,EACLD,EAAK,iBAAiB,WAAW,SAAS,EAC1C,UACF,EACA,MAAO,EACT,CACF,EAEA,OAAOM,EAAsB,aAAaR,EAAO,OAAO,EAAE,YACxDO,CACF,CACF,CACF,EAKsBE,EAAf,cACGR,CAAyB,CACvB,iBACRC,EACAC,EACa,CACb,MAAO,CACL,CACE,MAAO,WACP,MAAOA,EAAcD,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,CACF,CACF,EAKsBQ,EAAf,cACGT,CAAyB,CACvB,iBACRC,EACAC,EACa,CACb,MAAO,CACL,CACE,MAAO,WACP,MAAOA,EAAcD,EAAK,SAAU,OAAO,EAC3C,MAAO,CACT,EACA,CACE,MAAO,WACP,MAAOC,EAAcD,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,CACF,CAEmB,kBACjBC,EACQ,CACR,OAAOA,EAAc,IAAK,UAAU,EAClCA,EAAc,KAAK,uBAAuB,EAAG,OAAO,EACpDA,EAAc,IAAK,UAAU,CACjC,CACF,EAKaJ,EAAN,KAAkE,CACvE,OAAOG,EAAyBF,EAA8B,CAC5D,IAAMG,EAAgB,CAACC,EAAcC,IACnCL,EAAO,SAAWM,EAASF,EAAMC,CAAK,EAAID,EACtCG,EAAqB,CACzB,CAAE,MAAO,QAAS,MAAO,KAAK,gBAAgBL,EAAMF,CAAM,EAAG,MAAO,CAAE,EACtE,CACE,MAAO,KACP,MAAOG,EACLD,EAAK,iBAAiB,IAAM,mBAC5B,UACF,EACA,MAAO,CACT,EAEA,CACE,MAAO,WACP,MAAOC,EAAcD,EAAK,SAAU,OAAO,EAC3C,MAAO,CACT,EACA,CACE,MAAO,WACP,MAAOC,EAAcD,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,EAEA,CACE,MAAO,WACP,MAAOC,EAAcD,EAAK,iBAAiB,SAAU,UAAU,EAC/D,MAAO,CACT,EACA,CACE,MAAO,OACP,MAAOC,EACLD,EAAK,iBAAiB,WAAW,SAAS,EAC1C,UACF,EACA,MAAO,CACT,CACF,EAEA,OAAOM,EAAsB,aAAaR,EAAO,OAAO,EAAE,YACxDO,CACF,CACF,CAEU,gBACRL,EACAF,EACQ,CACR,IAAMG,EAAgB,CAACC,EAAcC,IACnCL,EAAO,SAAWM,EAASF,EAAMC,CAAK,EAAID,EAC5C,OAAOD,EAAc,UAAW,UAAU,EACxCA,EAAc,WAAY,KAAK,EAC/BA,EAAc,KAAM,UAAU,EAC9BA,EAAc,GAAGD,EAAK,WAAW,GAAI,OAAO,EAC5CC,EAAc,IAAK,UAAU,EAC7BA,EAAc,WAAY,OAAO,EACjCA,EAAc,IAAK,UAAU,CACjC,CACF,EAYMQ,EAAN,KAA4D,CAC1D,YAAYJ,EAA4B,CACtC,IAAMK,EAAgB,KAAK,IACzB,GAAGL,EACA,OAAQM,GAAS,CAACA,EAAK,GAAG,EAC1B,IAAI,CAAC,CAAE,MAAAC,CAAM,KAA0BA,EAAQ,KAAK,MAAM,CAC/D,EAEA,MAAO;AAAA;AAAA,EAASP,EACb,IAAI,CAAC,CAAE,MAAAO,EAAO,MAAAC,EAAO,IAAAC,CAAI,EAAGC,IAAU,CACrC,IAAIJ,EACJ,GAAIG,EACFH,EAAOE,MACF,CACL,IAAMG,EAAiBJ,EAAQ,IAE/BD,EADe,IAAI,OAAOD,EAAgBM,EAAe,MAAM,EAC/CA,EAAiB,IAAMH,CACzC,CAGA,IAAMI,EAAWZ,EAAMU,EAAQ,CAAC,EAChC,OAAIE,GAAYZ,EAAMU,CAAK,EAAE,QAAUE,EAAS,MACvCN,EAAO;AAAA,EAETA,CACT,CAAC,EACA,KAAK;AAAA,CAAI,EACV;AAAA;AAAA,CACJ,CACF,EAKMO,EAAN,KAA4D,CAC1D,YAAYb,EAA4B,CACtC,OAAOA,EACJ,IAAI,CAAC,CAAE,MAAAO,EAAO,MAAAC,CAAM,IAAM,CAEzB,IAAMM,EAAe,OAAON,GAAU,UAClCA,EAAM,SAAS,GAAG,EAAI,IAAIA,CAAK,IAC/BA,EAGJ,MAAO,GADcD,EAAM,YAAY,EAAE,QAAQ,OAAQ,GAAG,CACtC,IAAIO,CAAY,EACxC,CAAC,EACA,KAAK,GAAG,CACb,CACF,EAEMb,EAAN,KAA4B,CAC1B,OAAe,WACb,IAAI,IAAI,CACN,CAAC,SAAU,IAAIG,CAAsB,EACrC,CAAC,SAAU,IAAIS,CAAsB,CACvC,CAAC,EAEH,OAAO,aAAaE,EAA8C,CAChE,IAAMC,EAAY,KAAK,WAAW,IAAID,CAAM,EAC5C,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,2BAA2BD,CAAM,EAAE,EAErD,OAAOC,CACT,CACF,ECxLO,SAASC,EACdC,EACAC,EACAC,EACAC,EAAqB,GACG,CAMxB,IAAMC,EAAaH,EAAO,UAAYI,EAGtCC,EAA6B,UAAU,CACrC,SAAUL,EAAO,SACjB,QAASA,EAAO,OAClB,CAAC,EAGDK,EAA6B,SAC3B,OACA,IAAIC,CACN,EACAD,EAA6B,SAC3B,cACA,IAAIE,CACN,EACAF,EAA6B,SAC3B,cACA,IAAIG,CACN,EACAH,EAA6B,SAC3B,YACA,IAAII,CACN,EACAJ,EAA6B,SAC3B,kBACA,IAAIK,CACN,EACAL,EAA6B,SAC3B,yBACA,IAAIM,CACN,EACAN,EAA6B,SAC3B,iBACA,IAAIO,CACN,EACAP,EAA6B,SAC3B,eACA,IAAIQ,CACN,EACAR,EAA6B,SAC3B,sBACA,IAAIS,CACN,EACAT,EAA6B,SAAS,UAAW,IAAIU,CAAsB,EAC3EV,EAA6B,SAC3B,WACA,IAAIW,EACN,EACAX,EAA6B,SAC3B,aACA,IAAIY,EACN,EACAZ,EAA6B,SAC3B,gBACA,IAAIa,EACN,EACAb,EAA6B,SAAS,UAAW,IAAIc,EAAsB,EAC3Ed,EAA6B,SAC3B,eACA,IAAIe,EACN,EACAf,EAA6B,SAC3B,YACA,IAAIgB,EACN,EACAhB,EAA6B,SAC3B,iBACA,IAAIiB,EACN,EACAjB,EAA6B,SAC3B,iBACA,IAAIkB,EACN,EAEA,IAAMC,EAAgB,CACpB,WAAArB,EACA,OAAQH,EAAO,KACf,UAAAE,EACA,QAAAD,CACF,EAyRA,MAvR4C,CAC1C,IAAI,KAA8B,CAChC,OAAOH,EAAkBC,EAAUC,EAAQC,EAAS,CAACC,CAAS,CAChE,EAEA,KAAKuB,EAAyB,CAC5BC,EACE,OACA,IAAM,OAAO,GAAG3B,EAAU0B,CAAQ,EAClCA,EACA1B,EACAyB,CACF,CACF,EAEA,YAAYC,EAAkBE,EAAoB,EAAS,CACzD,IAAMC,EAAY,KAAK,IAAI,GAAI,CAACD,CAAS,EACvC,KAAK,IAAI,KAAK,IAAI5B,CAAkB,EAAG,KAAK,IAAI0B,CAAQ,CAAC,EACrDI,EAAO,KAAK,IAAK9B,EAAsB0B,CAAQ,EAErDC,EACE,cACA,IAAMG,EAAOD,EACbH,EACA1B,EACA,CACE,GAAGyB,EACH,gBAAiB,CACf,UAAAG,EACA,WAAYE,EACZ,mBAAoBD,CACtB,CACF,CACF,CACF,EAEA,aAAoB,CAClBF,EACE,cACA,IAAM3B,IAAa,OACnB,UACA,KAAK,UAAUA,CAAQ,EACvByB,CACF,CACF,EAEA,WAAkB,CAChBE,EACE,YACA,IAAM,CAAC3B,EACP,QACA,KAAK,UAAUA,CAAQ,EACvByB,CACF,CACF,EAEA,gBAAgBC,EAAiC,CAC/CC,EACE,kBACA,IAAO3B,EAAsB0B,EAC7BA,EACA1B,EACAyB,CACF,CACF,EAEA,uBAAuBC,EAAiC,CACtDC,EACE,yBACA,IAAO3B,GAAuB0B,EAC9BA,EACA1B,EACAyB,CACF,CACF,EAGA,eAAeC,EAA0B,CACvCC,EACE,iBACA,IAAM3B,aAAoB0B,EAC1BA,EAAS,KACR1B,EAA+C,YAAY,KAC5DyB,CACF,CACF,EAEA,aAAaC,EAAiC,CAC5CC,EACE,eACA,IAAO3B,EAAsB0B,EAC7BA,EACA1B,EACAyB,CACF,CACF,EAEA,oBAAoBC,EAAiC,CACnDC,EACE,sBACA,IAAO3B,GAAuB0B,EAC9BA,EACA1B,EACAyB,CACF,CACF,EAEA,SAAgB,CACdE,EACE,UACA,IAAM,MAAM3B,CAAkB,EAC9B,MACA,KAAK,UAAUA,CAAQ,EACvByB,CACF,CACF,EAEA,UAAiB,CACfE,EACE,WACA,IAAM3B,IAAa,KACnB,OACA,KAAK,UAAUA,CAAQ,EACvByB,CACF,CACF,EAEA,YAAmB,CACjBE,EACE,aACA,IAAM,CAAC,CAAC3B,EACR,SACA,KAAK,UAAUA,CAAQ,EACvByB,CACF,CACF,EAEA,eAAsB,CACpBE,EACE,gBACA,IAAM3B,IAAa,OACnB,YACA,KAAK,UAAUA,CAAQ,EACvByB,CACF,CACF,EAEA,QAAQC,EAAyB,CAC/BC,EACE,UACA,IAAMI,EAAY/B,EAAU0B,CAAQ,EACpC,KAAK,UAAUA,CAAQ,EACvB,KAAK,UAAU1B,CAAQ,EACvByB,CACF,CACF,EAEA,aAAaC,EAAwB,CACnCC,EACE,eACA,IAAO3B,EAA4B,SAAW0B,EAC9CA,EAAS,SAAS,EACjB1B,EAA4B,OAAO,SAAS,EAC7CyB,CACF,CACF,EAEA,UAAUC,EAAyB,CACjC,IAAIM,EAAe,GACnB,GAAI,OAAOhC,GAAa,SACtBgC,EAAe,iBACN,MAAM,QAAQhC,CAAQ,EAC/BgC,EAAe,gBACNhC,aAAoB,IAC7BgC,EAAe,UAEf,OAAM,IAAI,MACR,2DACF,EAEFL,EACE,YACA,IAAM,CACJ,GAAI,OAAO3B,GAAa,SACtB,OAAOA,EAAS,SAAS0B,CAAkB,EACtC,GAAI,MAAM,QAAQ1B,CAAQ,EAC/B,OAAOA,EAAS,SAAS0B,CAAQ,EAC5B,GAAI1B,aAAoB,IAC7B,OAAO,MAAM,KAAKA,CAAQ,EAAE,SAAS0B,CAAQ,EAE7C,MAAM,IAAI,MACR,2DACF,CAEJ,EACAA,EACA1B,EACA,CACE,GAAGyB,EACH,gBAAiB,CACf,aAAAO,CACF,CACF,CACF,CACF,EAEA,eAAeN,EAAyB,CACtC,IAAIM,EAAe,GACnB,GAAI,MAAM,QAAQhC,CAAQ,EACxBgC,EAAe,gBACNhC,aAAoB,IAC7BgC,EAAe,UAEf,OAAM,IAAI,MACR,sDACF,EAGFL,EACE,iBACA,IAAM,CACJ,GAAI,MAAM,QAAQ3B,CAAQ,EACxB,OAAOA,EAAS,KAAMiC,GAASF,EAAYE,EAAMP,CAAQ,CAAC,EACrD,GAAI1B,aAAoB,IAC7B,OAAO,MAAM,KAAKA,CAAQ,EAAE,KAAMiC,GAChCF,EAAYE,EAAMP,CAAQ,CAC5B,EAEA,MAAM,IAAI,MACR,sDACF,CAEJ,EACAA,EACA1B,EACA,CACE,GAAGyB,EACH,gBAAiB,CACf,aAAAO,CACF,CACF,CACF,CACF,EAEA,eAAeE,EAAiBR,EAA0B,CACxD,GAAI,OAAO1B,GAAa,UAAYA,IAAa,KAC/C,MAAM,IAAI,MACR,8CACF,EAeF2B,EACE,iBAbkB,IAAM,CACxB,GAAI,CACF,IAAMQ,EAAQC,GACZpC,EACAkC,CACF,EACA,OAAOR,IAAa,OAAYK,EAAYI,EAAOT,CAAQ,EAAI,EACjE,MAAY,CACV,MAAO,EACT,CACF,EAKEA,IAAa,OAAYA,EAAWQ,EACpClC,EACA,CACE,GAAGyB,EACH,gBAAiB,CACf,QAAAS,EACA,iBAAkBR,IAAa,MACjC,CACF,CACF,CACF,CACF,CAGF,CAGA,SAASC,EACPU,EACAC,EACAZ,EACA1B,EACA,CACE,WAAAI,EACA,OAAAmC,EACA,UAAApC,EAAY,GACZ,gBAAAqC,EAAkB,CAAC,EACnB,QAAAtC,CACF,EAOM,CACN,IAAMuC,EAAOC,GACXL,EACAX,EACA1B,EACA,CAAE,GAAGwC,EAAiB,UAAArC,CAAU,EAChCD,CACF,EAEMyC,EAASL,EAAQ,EAIvBlC,EAFoBD,EAAY,CAACwC,EAASA,EAIxCrC,EAA6B,YAAY+B,CAAW,EAAE,OACpDI,EACAnC,EAA6B,UAAU,CACzC,EACAiC,CACF,CACF,CAEA,SAASG,GACPL,EACAX,EACA1B,EACAwC,EAA2C,CAAC,EAC5CI,EACkB,CAClB,IAAMC,EAAaC,EAAgB,IAAI,MAAM,EAAE,KAAK,EAC9CC,EAAmBC,EAAwBH,CAAU,EAE3D,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,wCAAwC,EAG1D,MAAO,CACL,iBAAAA,EACA,YAAAV,EACA,SAAU,OAAOX,GAAa,SAC1BA,EACA,KAAK,UAAUA,CAAQ,EAC3B,SAAU,KAAK,UAAU1B,CAAQ,EACjC,gBAAAwC,EACA,cAAAI,CACF,CACF,CAKO,IAAMpC,EAAN,cAAuCyC,CAAgC,CAClE,gBAAyB,CACjC,MAAO,aACT,CAEmB,iBACjBR,EACAS,EACa,CACb,IAAMC,EAAcV,EAAK,gBAMzB,MAAO,CACL,CACE,MAAO,qBACP,MAAOS,EAAcC,EAAY,UAAU,SAAS,EAAG,OAAO,EAC9D,MAAO,CACT,EACA,CACE,MAAO,sBACP,MAAO,KACLD,EAAc,GAAGC,EAAY,kBAAkB,GAAI,OAAO,EAC5D,MAAO,CACT,EACA,CACE,MAAO,sBACP,MAAOD,EAAcC,EAAY,WAAW,SAAS,EAAG,KAAK,EAC7D,MAAO,CACT,CACF,CACF,CAEmB,kBACjBD,EACQ,CACR,OAAOA,EAAc,IAAK,UAAU,EAClCA,EAAc,WAAY,OAAO,EACjCA,EAAc,KAAM,UAAU,EAC9BA,EAAc,YAAa,OAAO,EAClCA,EAAc,IAAK,UAAU,CACjC,CACF,EAKazC,EAAN,cAAuC2C,CAA4B,CAC9D,gBAAyB,CACjC,MAAO,aACT,CACF,EAKa1C,EAAN,cAAqC0C,CAA4B,CAC5D,gBAAyB,CACjC,MAAO,WACT,CACF,EAKazC,EAAN,cACGsC,CAAgC,CAC9B,gBAAyB,CACjC,MAAO,iBACT,CAEmB,iBACjBR,EACAS,EACa,CACb,MAAO,CACL,CACE,MAAO,WACP,MAAO,KAAOA,EAAcT,EAAK,SAAU,OAAO,EAClD,MAAO,CACT,EACA,CACE,MAAO,WACP,MAAOS,EAAcT,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,CACF,CACF,EAKa7B,EAAN,cACGqC,CAAgC,CAC9B,gBAAyB,CACjC,MAAO,wBACT,CAEmB,iBACjBR,EACAS,EACa,CACb,MAAO,CACL,CACE,MAAO,WACP,MAAO,MAAQA,EAAcT,EAAK,SAAU,OAAO,EACnD,MAAO,CACT,EACA,CACE,MAAO,WACP,MAAOS,EAAcT,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,CACF,CACF,EAKa5B,EAAN,cACGoC,CAAgC,CAC9B,gBAAyB,CACjC,MAAO,gBACT,CAEmB,iBACjBR,EACAS,EACa,CACb,MAAO,CACL,CACE,MAAO,uBACP,MAAOA,EAAcT,EAAK,SAAU,OAAO,EAC3C,MAAO,CACT,EACA,CACE,MAAO,uBACP,MAAOS,EAAcT,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,CACF,CACF,EAKa3B,EAAN,cAAwCmC,CAAgC,CACnE,gBAAyB,CACjC,MAAO,cACT,CAEmB,iBACjBR,EACAS,EACa,CACb,MAAO,CACL,CACE,MAAO,WACP,MAAO,KAAOA,EAAcT,EAAK,SAAU,OAAO,EAClD,MAAO,CACT,EACA,CACE,MAAO,WACP,MAAOS,EAAcT,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,CACF,CACF,EAKa1B,EAAN,cACGkC,CAAgC,CAC9B,gBAAyB,CACjC,MAAO,qBACT,CAEmB,iBACjBR,EACAS,EACa,CACb,MAAO,CACL,CACE,MAAO,WACP,MAAO,MAAQA,EAAcT,EAAK,SAAU,OAAO,EACnD,MAAO,CACT,EACA,CACE,MAAO,WACP,MAAOS,EAAcT,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,CACF,CACF,EAKazB,EAAN,cAAmCoC,CAA4B,CAC1D,gBAAyB,CACjC,MAAO,SACT,CACF,EAKanC,GAAN,cAAoCmC,CAA4B,CAC3D,gBAAyB,CACjC,MAAO,UACT,CACF,EAKalC,GAAN,cAAsCkC,CAA4B,CAC7D,gBAAyB,CACjC,MAAO,YACT,CACF,EAKajC,GAAN,cAAyCiC,CAA4B,CAChE,gBAAyB,CACjC,MAAO,eACT,CACF,EAKahC,GAAN,cAAmC6B,CAAgC,CAC9D,gBAAyB,CACjC,MAAO,SACT,CAEmB,iBACjBR,EACAS,EACa,CACb,MAAO,CACL,CACE,MAAO,WACP,MAAOA,EAAcT,EAAK,SAAU,OAAO,EAC3C,MAAO,CACT,EACA,CACE,MAAO,WACP,MAAOS,EAAcT,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,CACF,CACF,EAKapB,GAAN,cAAwC4B,CAAgC,CACnE,gBAAyB,CACjC,MAAO,cACT,CAEmB,iBACjBR,EACAS,EACa,CACb,MAAO,CACL,CACE,MAAO,kBACP,MAAOA,EAAcT,EAAK,SAAU,OAAO,EAC3C,MAAO,CACT,EACA,CACE,MAAO,kBACP,MAAOS,EAAcT,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,EACA,CACE,MAAO,iBACP,MAAOS,EACLT,EAAK,iBAAiB,cACtB,KACF,EACA,MAAO,CACT,CACF,CACF,CACF,EAKanB,GAAN,cAAqC2B,CAAgC,CAChE,gBAAyB,CACjC,MAAO,WACT,CAEmB,iBACjBR,EACAS,EACa,CACb,IAAM/C,EAAYsC,EAAK,iBAAiB,UAClCT,EAAe,OAAOS,EAAK,iBAAiB,cAAiB,SAC/DA,EAAK,iBAAiB,aACtB,MAAM,QAAQ,KAAK,MAAMA,EAAK,QAAQ,CAAC,EACvC,QACA,SAEJ,MAAO,CACL,CACE,MAAOtC,EAAY,0BAA4B,sBAC/C,MAAO+C,EAAcT,EAAK,SAAU,OAAO,EAC3C,MAAO,CACT,EACA,CACE,MAAO,YAAYT,CAAY,GAC/B,MAAOkB,EAAcT,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,CACF,CACF,EAKalB,GAAN,cACG0B,CAAgC,CAC9B,gBAAyB,CACjC,MAAO,gBACT,CAEmB,iBACjBR,EACAS,EACa,CACb,IAAM/C,EAAYsC,EAAK,iBAAiB,UAClCT,EAAeS,EAAK,iBAAiB,aAE3C,MAAO,CACL,CACE,MAAOtC,EACH,gCACA,4BACJ,MAAO+C,EAAcT,EAAK,SAAU,OAAO,EAC3C,MAAO,CACT,EACA,CACE,MAAO,YAAYT,CAAY,GAC/B,MAAOkB,EAAcT,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,CACF,CACF,EAKajB,GAAN,cACGyB,CAAgC,CAC9B,gBAAyB,CACjC,MAAO,gBACT,CAEmB,iBACjBR,EACAS,EACa,CACb,IAAM/C,EAAYsC,EAAK,iBAAiB,UAClCP,EAAUO,EAAK,iBAAiB,QAChCY,EAAmBZ,EAAK,iBAAiB,iBAEzCa,EAAqB,CACzB,CACE,MAAO,gBACP,MAAOJ,EAAchB,EAAS,OAAO,EACrC,MAAO,CACT,CACF,EAEA,OAAImB,EACFC,EAAM,KACJ,CACE,MAAOnD,EACH,iCACA,6BACJ,MAAO+C,EAAcT,EAAK,SAAU,OAAO,EAC3C,MAAO,CACT,CACF,EAEAa,EAAM,KACJ,CACE,MAAOnD,EACH,iCACA,6BACJ,MAAO,GACP,MAAO,CACT,CACF,EAGFmD,EAAM,KACJ,CACE,MAAO,kBACP,MAAOJ,EAAcT,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,CACF,EAEOa,CACT,CAEmB,kBACjBJ,EACQ,CACR,OAAOA,EAAc,IAAK,UAAU,EAClCA,EAAc,UAAW,OAAO,EAChCA,EAAc,KAAM,UAAU,EAC9BA,EAAc,YAAa,OAAO,EAClCA,EAAc,IAAK,UAAU,CACjC,CACF,EAEA,SAASnB,EAAYwB,EAAYC,EAAqB,CACpD,GAAID,IAAMC,EAAG,MAAO,GAGpB,GADID,IAAM,MAAQC,IAAM,MACpB,OAAOD,GAAM,UAAY,OAAOC,GAAM,SAAU,MAAO,GAE3D,IAAMC,EAAQ,OAAO,KAAKF,CAAW,EAC/BG,EAAQ,OAAO,KAAKF,CAAW,EAErC,OAAIC,EAAM,SAAWC,EAAM,OAAe,GAEnCD,EAAM,MAAOE,GACXD,EAAM,SAASC,CAAG,GACvB5B,EACGwB,EAA8BI,CAAG,EACjCH,EAA8BG,CAAG,CACpC,CACH,CACH,CAWA,SAASvB,GACPwB,EACAC,EACS,CACT,GAAIA,IAAS,GACX,MAAM,IAAI,MAAM,4BAA4B,EAI9C,IAAMC,EAAqB,CAAC,EACxBC,EAAiB,GACjBC,EAAa,GAEjB,QAASC,EAAI,EAAGA,EAAIJ,EAAK,OAAQI,IAAK,CACpC,IAAMC,EAAOL,EAAKI,CAAC,EAEnB,GAAIC,IAAS,KAAO,CAACF,EACfD,IACFD,EAAS,KAAKC,CAAc,EAC5BA,EAAiB,YAEVG,IAAS,IACdH,IACFD,EAAS,KAAKC,CAAc,EAC5BA,EAAiB,IAEnBC,EAAa,WACJE,IAAS,IAClB,GAAIF,EACFF,EAAS,KAAKC,CAAc,EAC5BA,EAAiB,GACjBC,EAAa,OAEb,OAAM,IAAI,MAAM,iBAAiBH,CAAI,EAAE,OAGzCE,GAAkBG,CAEtB,CAGIH,GACFD,EAAS,KAAKC,CAAc,EAI9B,IAAII,EAAmBP,EAEvB,QAAWQ,KAAWN,EAAU,CAC9B,GAAIK,GAAY,KACd,MAAM,IAAI,MAAM,YAAYN,CAAI,iBAAiB,EAGnD,GAAI,OAAOO,GAAY,UAAY,CAAC,MAAM,OAAOA,CAAO,CAAC,EAAG,CAE1D,IAAMC,EAAQ,OAAOD,CAAO,EAC5B,GAAI,CAAC,MAAM,QAAQD,CAAO,EACxB,MAAM,IAAI,MAAM,uBAAuBC,CAAO,eAAe,EAE/D,GAAIC,GAAUF,EAAsB,OAClC,MAAM,IAAI,MAAM,SAASC,CAAO,gBAAgB,EAElDD,EAAWA,EAAsBE,CAAK,CACxC,KAAO,CAEL,GAAI,OAAOF,GAAY,SACrB,MAAM,IAAI,MAAM,0BAA0BC,CAAO,gBAAgB,EAGnE,GAAI,CAAC,OAAO,UAAU,eAAe,KAAKD,EAASC,CAAO,EACxD,MAAM,IAAI,MAAM,YAAYA,CAAO,2BAA2B,EAGhED,EAAWA,EAAoCC,CAAO,CACxD,CACF,CAEA,OAAOD,CACT,CC7nCO,SAASG,GAAoBC,EAAuB,CACzD,OAAOA,EACJ,QAAQ,kBAAmB,EAAE,EAC7B,QAAQ,OAAQ,GAAG,EAAE,KAAK,CAC/B,CCyHO,SAASC,EACdC,EACAC,EACAC,EACAC,EAAqB,GACA,CAMrB,IAAMC,EAAaH,EAAO,UAAYI,EAChCC,EAASL,EAAO,MAAQ,GACxBM,EAA2B,CAC/B,QAASN,EAAO,QAChB,SAAUA,EAAO,QACnB,EAGAO,EAA6B,UAAU,CACrC,SAAUP,EAAO,SACjB,QAASA,EAAO,OAClB,CAAC,EAGDO,EAA6B,SAC3B,cACA,IAAIC,EACN,EACAD,EAA6B,SAC3B,eACA,IAAIE,EACN,EACAF,EAA6B,SAC3B,eACA,IAAIG,EACN,EACAH,EAA6B,SAC3B,cACA,IAAII,EACN,EACAJ,EAA6B,SAC3B,aACA,IAAIK,EACN,EACAL,EAA6B,SAC3B,cACA,IAAIM,EACN,EACAN,EAA6B,SAC3B,cACA,IAAIO,EACN,EAEA,IAAMC,EAAgB,CACpB,QAAAhB,EACA,YAAAO,EACA,WAAAH,EACA,OAAAE,EACA,UAAAH,EACA,QAAAD,CACF,EAEMe,EAAoB,CACxBC,EACAC,IAEO,eACLC,EACAC,EAAsC,CAAC,EACxB,CACf,IAAMC,EAAaC,EAAgB,IAAI,MAAM,EAAE,KAAK,EAC9CC,EAAmBC,EAAwBH,CAAU,EAE3D,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,wCAAwC,EAG1D,IAAME,GAAc,CAACN,EAAkBO,IAAmB,CAExD,IAAMC,EAASP,EAAQ,aAAe,OAClC,IAAI,OACJD,EAAS,OACTA,EAAS,MAAM,QAAQ,IAAK,EAAE,GAAKC,EAAQ,WAAa,IAAM,GAChE,EACED,EAEES,EAAyB,CAC7B,iBAAAL,EACA,YAAAN,EACA,SAAUU,EAAO,SAAS,EAC1B,SAAUD,EACV,gBAAiB,CAAE,UAAAxB,CAAU,EAC7B,cAAeD,CACjB,EAEM4B,EAASF,EAAO,KAAKD,CAAM,EAEjCvB,EACED,EAAY,CAAC2B,EAASA,EACtBtB,EAA6B,YAAYU,CAAW,EAAE,OACpDW,EACArB,EAA6B,UAAU,CACzC,EACAF,CACF,CACF,EAEMyB,GAAY,CAACX,EAAkBO,IAAmB,CACtD,IAAMK,EAAqBC,GAAoBb,CAAQ,EACjDc,EAAmBD,GAAoBN,CAAM,EAE7CE,EAAyB,CAC7B,iBAAAL,EACA,YAAAN,EACA,SAAUc,EACV,SAAUE,EACV,gBAAiB,CAAE,UAAA/B,CAAU,EAC7B,cAAeD,CACjB,EAEM4B,GAAST,EAAQ,WACnBF,EACAe,EAAiB,YAAY,EAC7BF,EAAmB,YAAY,CACjC,EACEb,EAAUe,EAAkBF,CAAkB,EAElD5B,EACED,EAAY,CAAC2B,GAASA,GACtBtB,EAA6B,YAAYU,CAAW,EAAE,OACpDW,EACArB,EAA6B,UAAU,CACzC,EACAF,CACF,CACF,EAEA,GAAI,CACF,MAAM6B,GACJ,SAAY,CACV,IAAMC,EAAaf,EAAQ,aACvB,MAAMrB,EAAQ,UAAU,EACxB,MAAMA,EAAQ,YAAY,EAE9B,GAAIoC,IAAe,KACjB,MAAM,IAAI,MAAM,6BAA6B,EAG/C,GAAIhB,aAAoB,OAAQ,CAC9BM,GAAYN,EAAUgB,CAAU,EAEhC,MACF,CAEAL,GAAUX,EAAUgB,CAAU,CAChC,EACA,CAAE,GAAG7B,EAAa,GAAGc,CAAQ,CAC/B,CACF,MAAY,CACV,IAAMQ,EAAyB,CAC7B,iBAAAL,EACA,YAAAN,EACA,SAAUE,EAAS,SAAS,EAC5B,SAAU,UACV,gBAAiB,CAAE,UAAAjB,CAAU,EAC7B,cAAeD,CACjB,EAEAE,EACE,GACAI,EAA6B,YAAY,YAAY,EAAE,OACrDqB,EACArB,EAA6B,UAAU,CACzC,EACAF,CACF,CACF,CACF,EA0IF,MAvIyC,CACvC,IAAI,KAA2B,CAC7B,OAAOP,EAAkBC,EAASC,EAAQC,EAAS,CAACC,CAAS,CAC/D,EAEA,MAAM,YACJkB,EAAgCd,EACjB,CACf,MAAM8B,EACJ,cACA,SAAY,MAAMrC,EAAQ,UAAU,EACpC,UACA,YACA,CAAE,GAAGgB,EAAe,QAAAK,CAAQ,CAC9B,CACF,EAEA,MAAM,aACJA,EAAgCd,EACjB,CACf,MAAM8B,EACJ,eACA,SAAY,MAAMrC,EAAQ,WAAW,EACrC,WACA,UACA,CAAE,GAAGgB,EAAe,QAAAK,CAAQ,CAC9B,CACF,EAEA,MAAM,aACJA,EAAgCd,EACjB,CACf,MAAM8B,EACJ,eACA,SAAY,MAAMrC,EAAQ,WAAW,EACrC,WACA,aACA,CAAE,GAAGgB,EAAe,QAAAK,CAAQ,CAC9B,CACF,EAEA,MAAM,YACJA,EAAgCd,EACjB,CACf,MAAM8B,EACJ,cACA,SAAY,MAAMrC,EAAQ,UAAU,EACpC,UACA,WACA,CAAE,GAAGgB,EAAe,QAAAK,CAAQ,CAC9B,CACF,EAEA,MAAM,WACJA,EAAgCd,EACjB,CACf,MAAM8B,EACJ,aACA,SAAY,MAAMrC,EAAQ,SAAS,EACnC,SACA,UACA,CAAE,GAAGgB,EAAe,QAAAK,CAAQ,CAC9B,CACF,EAEA,MAAM,YACJA,EAAgCd,EACjB,CACf,MAAM8B,EACJ,cACA,SAAY,MAAMrC,EAAQ,UAAU,EACpC,UACA,SACA,CAAE,GAAGgB,EAAe,QAAAK,CAAQ,CAC9B,CACF,EAEA,WAAYJ,EACV,aACA,CAACU,EAAQP,IAAaO,IAAWP,CACnC,EAEA,cAAeH,EACb,gBACA,CAACU,EAAQP,IAAaO,EAAO,SAASP,CAAQ,CAChD,EAEA,MAAM,YACJkB,EACAjB,EAAgCd,EACjB,CACf,IAAMe,EAAaC,EAAgB,IAAI,MAAM,EAAE,KAAK,EAC9CC,EAAmBC,EAAwBH,CAAU,EAC3D,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,wCAAwC,EAG1D,IAAMK,EAAyB,CAC7B,iBAAAL,EACA,YAAa,cACb,SAAUc,EACV,SAAU,UACV,gBAAiB,CAAE,UAAAnC,CAAU,EAC7B,cAAeD,CACjB,EAEA,GAAI,CACF,MAAMiC,GAAU,SAAY,CAC1B,IAAMI,EAAc,MAAMvC,EAAQ,WAAW,EACvC8B,EAASQ,IAAkBC,EAIjCnC,EAFoBD,EAAY,CAAC2B,EAASA,EAIxCtB,EAA6B,YAAY,aAAa,EAAE,OACtDqB,EACArB,EAA6B,UAAU,CACzC,EACAF,CACF,CACF,EAAG,CAAE,GAAGC,EAAa,GAAGc,CAAQ,CAAC,CACnC,MAAY,CACVjB,EACE,GACAI,EAA6B,YAAY,aAAa,EAAE,OACtDqB,EACArB,EAA6B,UAAU,CACzC,EACAF,CACF,CACF,CACF,CACF,CAGF,CAGA,SAASkC,GACPtB,EACAE,EACAqB,EACAC,EAAiB,CAAC,EAClBC,EACkB,CAClB,IAAMrB,EAAaC,EAAgB,IAAI,MAAM,EAAE,KAAK,EAC9CC,EAAmBC,EAAwBH,CAAU,EAE3D,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,wCAAwC,EAG1D,MAAO,CACL,iBAAAA,EACA,YAAAN,EACA,SAAAE,EACA,SAAAqB,EACA,cAAAE,EACA,GAAGD,CACL,CACF,CAGA,eAAeL,EACbnB,EACA0B,EACAxB,EACAqB,EACA,CACE,QAAAzC,EACA,YAAAO,EACA,WAAAH,EACA,OAAAE,EACA,UAAAH,EAAY,GACZ,QAAAkB,EAAU,CAAC,EACX,QAAAnB,CACF,EASe,CACf,IAAM2B,EAAOW,GAAkBtB,EAAaE,EAAUqB,EAAU,CAC9D,gBAAiB,CACf,QAAAzC,EACA,QAASqB,EAAQ,QACjB,UAAAlB,CACF,CACF,EAAGD,CAAO,EAEV,GAAI,CACF,MAAMiC,GAAU,SAAY,CAC1B,IAAML,EAAS,MAAMc,EAAQ,EAEvBC,EAAc1C,EAAY,CAAC2B,EAASA,EAE1C,GAAI,CAACe,EACH,MAAM,IAAI,MAAM,gBAAgB,EAGlCzC,EACEyC,EACArC,EAA6B,YAAYU,CAAW,EAAE,OACpDW,EACArB,EAA6B,UAAU,CACzC,EACAF,CACF,CACF,EAAG,CAAE,GAAGC,EAAa,GAAGc,CAAQ,CAAC,CACnC,MAAY,CACVjB,EACE,GACAI,EAA6B,YAAYU,CAAW,EAAE,OACpDW,EACArB,EAA6B,UAAU,CACzC,EACAF,CACF,CACF,CACF,CAKO,IAAewC,EAAf,cACGC,CAA4B,CAI1B,gBAAyB,CACjC,MAAO,OAAO,KAAK,MAAM,CAAC,EAAE,YAAY,CAAC,GAAG,KAAK,MAAM,MAAM,CAAC,CAAC,EACjE,CAEmB,wBAAiC,CAClD,MAAO,SACT,CAEmB,iBACjBlB,EACAmB,EACa,CACb,MAAO,CACL,CAAE,MAAO,WAAY,MAAO,KAAK,MAAO,MAAO,CAAE,EACjD,CAAE,MAAO,WAAY,MAAO,KAAK,cAAe,MAAO,CAAE,EACzD,CAAE,MAAO,WAAY,MAAO,GAAI,MAAO,CAAE,EACzC,CACE,MAAO,GACP,MAAOA,EACL,kBAAkB,KAAK,MAAM,CAAC,EAAE,YAAY,CAAC,GAC3C,KAAK,MAAM,MAAM,CAAC,CACpB,iBAAiBnB,EAAK,iBAAiB,OAAO,KAC9C,UACF,EACA,MAAO,EACP,IAAK,EACP,EACA,CACE,MAAO,GACP,MAAOmB,EAAc,0BAA2B,UAAU,EAC1D,MAAO,EACP,IAAK,EACP,CACF,CACF,CACF,EAEavC,GAAN,cAAuCqC,CAA0B,CAC5D,MAAQ,UACR,cAAgB,WAC5B,EAKapC,GAAN,cAAwCoC,CAA0B,CAC7D,MAAQ,WACR,cAAgB,SAC5B,EAEanC,GAAN,cAAwCmC,CAA0B,CAC7D,MAAQ,WACR,cAAgB,YAC5B,EAEalC,GAAN,cAAuCkC,CAA0B,CAC5D,MAAQ,UACR,cAAgB,UAC5B,EAEajC,GAAN,cAAsCiC,CAA0B,CAC3D,MAAQ,SACR,cAAgB,SAC5B,EAEahC,GAAN,cAAuCgC,CAA0B,CAC5D,MAAQ,UACR,cAAgB,QAC5B,EAEa/B,GAAN,cAAuCkC,CAAgC,CAClE,gBAAyB,CACjC,MAAO,aACT,CAEmB,iBACjBpB,EACAmB,EACa,CACb,MAAO,CAGL,CACE,MAAO,WACP,MAAOA,EAAcnB,EAAK,SAAU,OAAO,EAC3C,MAAO,CACT,EACA,CACE,MAAO,WACP,MAAOmB,EAAcnB,EAAK,SAAU,KAAK,EACzC,MAAO,CACT,EACA,CAAE,MAAO,WAAY,MAAO,GAAI,MAAO,CAAE,EACzC,CACE,MAAO,GACP,MAAOmB,EACL,uCAAuCnB,EAAK,iBAAiB,OAAO,KACpE,UACF,EACA,MAAO,EACP,IAAK,EACP,EAEA,CACE,MAAO,GACP,MAAOmB,EAAc,0BAA2B,UAAU,EAC1D,MAAO,EACP,IAAK,EACP,CACF,CACF,CACF,EASA,eAAsBb,GACpBe,EACA7B,EAII,CAAC,EACa,CAClB,IAAM8B,EAAkB9B,EAAQ,SAAW+B,EAAsB,QAC3DC,EAAmBhC,EAAQ,UAAY+B,EAAsB,SAC7DE,EAASjC,EAAQ,OAAS,IAAM,KAAK,IAAI,GACzCkC,EAAQlC,EAAQ,SAClBmC,GAAe,IAAI,QAASC,GAAY,WAAWA,EAASD,CAAE,CAAC,GAE7DE,EAAoBJ,EAAO,EAEjC,KAAOA,EAAO,EAAII,EAAYP,GAAS,CACrC,GAAI,CACF,aAAMD,EAAU,EACT,EACT,MAAiB,CAEjB,CAEA,MAAMK,EAAMF,CAAQ,CACtB,CAEA,MAAM,IAAIM,GACR,mCAAmCR,CAAO,YAC5C,CACF,CAKO,IAAMQ,GAAN,cAAgC,KAAM,CAC3C,YAAYzD,EAAiB,CAC3B,MAAMA,CAAO,EACb,KAAK,KAAO,mBACd,CACF,ECrqBO,IAAM0D,GAAyBC,GAAW,EAwCjD,SAASA,GAAWC,EAAoD,CAItE,IAAMC,EAASC,EAAa,KAAKF,CAAU,EAE3C,OAAO,OAAO,OACZ,SACEG,EACAC,EACkE,CAClE,OAAIC,GAAUF,CAAK,EACVG,EACLH,EACAF,EACAG,CACF,EAEOE,EACLH,EACAF,EACAG,CACF,CAEJ,EACA,CACE,KACED,EACAC,EACkE,CAClE,OAAIC,GAAUF,CAAK,EACVG,EACLH,EACA,CAAE,GAAGF,EAAQ,KAAM,EAAK,EACxBG,CACF,EAEOE,EACLH,EACA,CAAE,GAAGF,EAAQ,KAAM,EAAK,EACxBG,CACF,CAEJ,EACA,UAAUG,EAAkD,CAC1D,OAAOR,GAAWQ,CAAS,CAC7B,EACA,IAAI,QAAuB,CACzB,MAAO,CAAE,GAAGN,CAAO,CACrB,CACF,CACF,CACF,CAUA,SAASI,GAAUF,EAAkC,CACnD,GAAI,CAACA,GAAS,OAAOA,GAAU,SAC7B,MAAO,GAGT,IAAMK,EAAoB,CACxB,QACA,YACA,WACA,eACA,eACA,QACA,OACA,gBACA,WACA,aACA,aACA,QACA,YACA,aACA,QACA,aACA,OACA,cACA,QACA,UACA,QACA,UACA,YACA,YACA,YACA,KACF,EAEMC,EAAwBN,GACrBK,EAAkB,MAAOE,GAASA,KAAQP,CAAK,EAGxD,OACEA,GAAU,MAEV,OAAOA,GAAU,UACjBM,EAAqBN,CAAK,CAE9B",
  "names": ["exec", "assert", "condition", "message", "soft", "AssertionFailedError", "getEnvironment", "env", "envParser", "key", "value", "allowedValues", "name", "parsed", "DEFAULT_RETRY_OPTIONS", "DEFAULT_CONFIG", "assert", "ConfigLoader", "_ConfigLoader", "explicitConfig", "envConfig", "config", "envParser", "captureExecutionContext", "st", "stackFrame", "filePath", "fileName", "lineNumber", "columnNumber", "at", "parseStackTrace", "stack", "lines", "frames", "i", "lineStr", "functionName", "fileInfo", "firstParenIndex", "fileProtocolIndex", "offsetParenIndex", "lastColon", "secondLastColon", "filePath", "fileName", "lineNumberStr", "columnNumberStr", "ANSI_COLORS", "colorize", "text", "color", "MatcherErrorRendererRegistry", "matcherName", "renderer", "DefaultMatcherErrorRenderer", "config", "BaseMatcherErrorRenderer", "info", "maybeColorize", "text", "color", "colorize", "lines", "DisplayFormatRegistry", "ReceivedOnlyMatcherRenderer", "ExpectedReceivedMatcherRenderer", "PrettyFormatRenderer", "maxLabelWidth", "line", "label", "value", "raw", "index", "labelWithColon", "nextLine", "InlineFormatRenderer", "escapedValue", "format", "formatter", "createExpectation", "received", "config", "message", "isNegated", "usedAssert", "assert", "MatcherErrorRendererRegistry", "DefaultMatcherErrorRenderer", "ToBeCloseToErrorRenderer", "ToBeDefinedErrorRenderer", "ToBeFalsyErrorRenderer", "ToBeGreaterThanErrorRenderer", "ToBeGreaterThanOrEqualErrorRenderer", "ToBeInstanceOfErrorRenderer", "ToBeLessThanErrorRenderer", "ToBeLessThanOrEqualErrorRenderer", "ToBeNaNErrorRenderer", "ToBeNullErrorRenderer", "ToBeTruthyErrorRenderer", "ToBeUndefinedErrorRenderer", "ToEqualErrorRenderer", "ToHaveLengthErrorRenderer", "ToContainErrorRenderer", "ToContainEqualErrorRenderer", "ToHavePropertyErrorRenderer", "matcherConfig", "expected", "createMatcher", "precision", "tolerance", "diff", "isDeepEqual", "receivedType", "item", "keyPath", "value", "getPropertyByPath", "matcherName", "checkFn", "isSoft", "matcherSpecific", "info", "createMatcherInfo", "result", "customMessage", "stacktrace", "parseStackTrace", "executionContext", "captureExecutionContext", "ExpectedReceivedMatcherRenderer", "maybeColorize", "matcherInfo", "ReceivedOnlyMatcherRenderer", "hasExpectedValue", "lines", "a", "b", "keysA", "keysB", "key", "obj", "path", "segments", "currentSegment", "inBrackets", "i", "char", "current", "segment", "index", "normalizeWhiteSpace", "value", "createExpectation", "locator", "config", "message", "isNegated", "usedAssert", "assert", "isSoft", "retryConfig", "MatcherErrorRendererRegistry", "ToBeCheckedErrorRenderer", "ToBeDisabledErrorRenderer", "ToBeEditableErrorRenderer", "ToBeEnabledErrorRenderer", "ToBeHiddenErrorRenderer", "ToBeVisibleErrorRenderer", "ToHaveValueErrorRenderer", "matcherConfig", "createTextMatcher", "matcherName", "compareFn", "expected", "options", "stacktrace", "parseStackTrace", "executionContext", "captureExecutionContext", "checkRegExp", "actual", "regexp", "info", "result", "checkText", "normalizedExpected", "normalizeWhiteSpace", "normalizedActual", "withRetry", "actualText", "createMatcher", "expectedValue", "actualValue", "createMatcherInfo", "received", "additionalInfo", "customMessage", "checkFn", "finalResult", "BooleanStateErrorRenderer", "ReceivedOnlyMatcherRenderer", "maybeColorize", "ExpectedReceivedMatcherRenderer", "assertion", "timeout", "DEFAULT_RETRY_OPTIONS", "interval", "getNow", "sleep", "ms", "resolve", "startTime", "RetryTimeoutError", "expect", "makeExpect", "baseConfig", "config", "ConfigLoader", "value", "message", "isLocator", "createExpectation", "newConfig", "locatorProperties", "hasLocatorProperties", "prop"]
}
