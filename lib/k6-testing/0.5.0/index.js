import Se from"k6/execution";function O(t,e,r,n="throw"){if(!t)if(r)if(n==="fail")Se.test.fail(e);else throw new K(e);else Se.test.abort(e)}var K=class extends Error{constructor(e){super(e),this.name="AssertionFailedError"}};function Le(){return typeof Deno<"u"?Deno.env.toObject():__ENV}var F=Le(),b={hasValue(t){return F[t]!==void 0},boolean(t){let e=F[t]?.toLowerCase();if(e===void 0)throw new Error(`Environment variable ${t} is not set`);return e!=="false"},enum(t,e){let r=F[t]?.toLowerCase();if(r===void 0)throw new Error(`Environment variable ${t} is not set`);if(!e.includes(r))throw new Error(`Invalid value for ${t}. Must be one of: ${e.join(", ")}`);return r},number(t){let e=F[t];if(!e)throw new Error(`Environment variable ${t} is not set`);let r=Number(e);if(Number.isNaN(r)||!Number.isFinite(r))throw new Error(`Environment variable ${t} must be a valid number, got: ${e}`);if(r<0)throw new Error(`Environment variable ${t} must be a non-negative number, got: ${e}`);return r}};var D={timeout:5e3,interval:100},Ne={...D,soft:!1,softMode:"throw",colorize:!0,display:"pretty",assertFn:O},$=class t{static load(e={}){let r=t.loadFromEnv();return{...Ne,...e,...r}}static loadFromEnv(){let e={};return b.hasValue("K6_TESTING_COLORIZE")&&(e.colorize=b.boolean("K6_TESTING_COLORIZE")),b.hasValue("K6_TESTING_DISPLAY")&&(e.display=b.enum("K6_TESTING_DISPLAY",["inline","pretty"])),b.hasValue("K6_TESTING_TIMEOUT")&&(e.timeout=b.number("K6_TESTING_TIMEOUT")),b.hasValue("K6_TESTING_INTERVAL")&&(e.interval=b.number("K6_TESTING_INTERVAL")),b.hasValue("K6_TESTING_SOFT_MODE")&&(e.softMode=b.enum("K6_TESTING_SOFT_MODE",["throw","fail"])),e}};function k(t){if(!t||t.length<=1)return;let e=t[t.length-1],r=e.filePath,n=e.fileName,s=e.lineNumber,i=e.columnNumber,a=`${r}:${s}:${i}`;return{filePath:r,fileName:n,lineNumber:s,columnNumber:i,at:a}}function C(t){if(!t)return[];let e=t.split(`
`),r=[];for(let n=0;n<e.length;n++){let s=e[n].trim();if(n===0&&s.startsWith("Error")||!s.startsWith("at "))continue;s=s.slice(3).trim();let i="<anonymous>",a=s,o=s.indexOf("("),l=s.indexOf("file://");l===0?(i="<anonymous>",a=s.slice(l)):o>=0?(i=s.slice(0,o).trim()||"<anonymous>",a=s.slice(o+1,s.lastIndexOf(")")).trim()):a=s;let g=a.lastIndexOf("(");g>=0&&(a=a.slice(0,g)),a.startsWith("file://")&&(a=a.slice(7));let p=a.lastIndexOf(":");if(p===-1)continue;let d=a.lastIndexOf(":",p-1);if(d===-1)continue;let u=a.slice(0,d),x=u.split("/").pop()??"",h=a.slice(d+1,p),E=a.slice(p+1);r.push({functionName:i,filePath:u,fileName:x,lineNumber:parseInt(h,10),columnNumber:parseInt(E,10)})}return r}var Re={reset:"\x1B[0m",black:"\x1B[30m",red:"\x1B[31m",green:"\x1B[32m",yellow:"\x1B[33m",blue:"\x1B[34m",magenta:"\x1B[35m",cyan:"\x1B[36m",white:"\x1B[37m",brightBlack:"\x1B[90m",brightRed:"\x1B[91m",brightGreen:"\x1B[92m",brightYellow:"\x1B[93m",brightBlue:"\x1B[94m",brightMagenta:"\x1B[95m",brightCyan:"\x1B[96m",brightWhite:"\x1B[97m",darkGrey:"\x1B[90m"};function M(t,e){return`${Re[e]}${t}${Re.reset}`}var c=class{static renderers=new Map;static config={colorize:!0,display:"pretty"};static register(e,r){this.renderers.set(e,r)}static getRenderer(e){return this.renderers.get(e)||new A}static configure(e){this.config={...this.config,...e}}static getConfig(){return this.config}},H=class{getReceivedPlaceholder(){return"received"}getExpectedPlaceholder(){return"expected"}renderErrorLine(e,r){let n=(s,i)=>r.colorize?M(s,i):s;return"customMessage"in e&&typeof e.customMessage=="string"?n(e.customMessage,"white"):n("expect(","darkGrey")+n(this.getReceivedPlaceholder(),"red")+n(").","darkGrey")+n(this.getMatcherName(),"white")+this.renderMatcherArgs(n)}renderMatcherArgs(e){return e("()","darkGrey")}render(e,r){let n=(i,a)=>r.colorize?M(i,a):i,s=[{label:"Error",value:this.renderErrorLine(e,r),group:1},{label:"At",value:n(e.executionContext.at||"unknown location","darkGrey"),group:1},...this.getSpecificLines(e,n),{label:"Filename",value:n(e.executionContext.fileName,"darkGrey"),group:99},{label:"Line",value:n(e.executionContext.lineNumber.toString(),"darkGrey"),group:99}];return q.getFormatter(r.display).renderLines(s)}},v=class extends H{getSpecificLines(e,r){return[{label:"Received",value:r(e.received,"red"),group:2}]}},m=class extends H{getSpecificLines(e,r){return[{label:"Expected",value:r(e.expected,"green"),group:2},{label:"Received",value:r(e.received,"red"),group:2}]}renderMatcherArgs(e){return e("(","darkGrey")+e(this.getExpectedPlaceholder(),"green")+e(")","darkGrey")}},A=class{render(e,r){let n=(i,a)=>r.colorize?M(i,a):i,s=[{label:"Error",value:this.renderErrorLine(e,r),group:1},{label:"At",value:n(e.executionContext.at||"unknown location","darkGrey"),group:1},{label:"Expected",value:n(e.expected,"green"),group:2},{label:"Received",value:n(e.received,"red"),group:2},{label:"Filename",value:n(e.executionContext.fileName,"darkGrey"),group:3},{label:"Line",value:n(e.executionContext.lineNumber.toString(),"darkGrey"),group:3}];return q.getFormatter(r.display).renderLines(s)}renderErrorLine(e,r){let n=(s,i)=>r.colorize?M(s,i):s;return n("expect(","darkGrey")+n("received","red")+n(").","darkGrey")+n(`${e.matcherName}`,"white")+n("(","darkGrey")+n("expected","green")+n(")","darkGrey")}},W=class{renderLines(e){let r=Math.max(...e.filter(n=>!n.raw).map(({label:n})=>(n+":").length));return`

`+e.map(({label:n,value:s,raw:i},a)=>{let o;if(i)o=s;else{let g=n+":";o=" ".repeat(r-g.length)+g+" "+s}let l=e[a+1];return l&&e[a].group!==l.group?o+`
`:o}).join(`
`)+`

`}},Y=class{renderLines(e){return e.map(({label:r,value:n})=>{let s=typeof n=="string"&&n.includes(" ")?`"${n}"`:n;return`${r.toLowerCase().replace(/\s+/g,"_")}=${s}`}).join(" ")}},q=class{static formatters=new Map([["pretty",new W],["inline",new Y]]);static getFormatter(e){let r=this.formatters.get(e);if(!r)throw new Error(`Unknown display format: ${e}`);return r}};function j(t,e,r,n=!1){let s=e.assertFn??O;c.configure({colorize:e.colorize,display:e.display}),c.register("toBe",new A),c.register("toBeCloseTo",new Z),c.register("toBeDefined",new Q),c.register("toBeFalsy",new X),c.register("toBeGreaterThan",new z),c.register("toBeGreaterThanOrEqual",new ee),c.register("toBeInstanceOf",new te),c.register("toBeLessThan",new re),c.register("toBeLessThanOrEqual",new ne),c.register("toBeNaN",new oe),c.register("toBeNull",new ie),c.register("toBeTruthy",new ae),c.register("toBeUndefined",new se),c.register("toEqual",new ce),c.register("toHaveLength",new pe),c.register("toContain",new le),c.register("toContainEqual",new ue),c.register("toHaveProperty",new de);let i={usedAssert:s,isSoft:e.soft,isNegated:n,message:r,softMode:e.softMode};return{get not(){return j(t,e,r,!n)},toBe(o){f("toBe",()=>Object.is(t,o),o,t,i)},toBeCloseTo(o,l=2){let g=Math.pow(10,-l)*Math.max(Math.abs(t),Math.abs(o)),p=Math.abs(t-o);f("toBeCloseTo",()=>p<g,o,t,{...i,matcherSpecific:{precision:l,difference:p,expectedDifference:g}})},toBeDefined(){f("toBeDefined",()=>t!==void 0,"defined",JSON.stringify(t),i)},toBeFalsy(){f("toBeFalsy",()=>!t,"falsy",JSON.stringify(t),i)},toBeGreaterThan(o){f("toBeGreaterThan",()=>t>o,o,t,i)},toBeGreaterThanOrEqual(o){f("toBeGreaterThanOrEqual",()=>t>=o,o,t,i)},toBeInstanceOf(o){f("toBeInstanceOf",()=>t instanceof o,o.name,t.constructor.name,i)},toBeLessThan(o){f("toBeLessThan",()=>t<o,o,t,i)},toBeLessThanOrEqual(o){f("toBeLessThanOrEqual",()=>t<=o,o,t,i)},toBeNaN(){f("toBeNaN",()=>isNaN(t),"NaN",JSON.stringify(t),i)},toBeNull(){f("toBeNull",()=>t===null,"null",JSON.stringify(t),i)},toBeTruthy(){f("toBeTruthy",()=>!!t,"truthy",JSON.stringify(t),i)},toBeUndefined(){f("toBeUndefined",()=>t===void 0,"undefined",JSON.stringify(t),i)},toEqual(o){f("toEqual",()=>B(t,o),JSON.stringify(o),JSON.stringify(t),i)},toHaveLength(o){f("toHaveLength",()=>t.length===o,o.toString(),t.length.toString(),i)},toContain(o){let l="";if(typeof t=="string")l="string";else if(Array.isArray(t))l="array";else if(t instanceof Set)l="set";else throw new Error("toContain is only supported for strings, arrays, and sets");f("toContain",()=>{if(typeof t=="string")return t.includes(o);if(Array.isArray(t))return t.includes(o);if(t instanceof Set)return Array.from(t).includes(o);throw new Error("toContain is only supported for strings, arrays, and sets")},o,t,{...i,matcherSpecific:{receivedType:l}})},toContainEqual(o){let l="";if(Array.isArray(t))l="array";else if(t instanceof Set)l="set";else throw new Error("toContainEqual is only supported for arrays and sets");f("toContainEqual",()=>{if(Array.isArray(t))return t.some(g=>B(g,o));if(t instanceof Set)return Array.from(t).some(g=>B(g,o));throw new Error("toContainEqual is only supported for arrays and sets")},o,t,{...i,matcherSpecific:{receivedType:l}})},toHaveProperty(o,l){if(typeof t!="object"||t===null)throw new Error("toHaveProperty is only supported for objects");f("toHaveProperty",()=>{try{let p=Me(t,o);return l!==void 0?B(p,l):!0}catch{return!1}},l!==void 0?l:o,t,{...i,matcherSpecific:{keyPath:o,hasExpectedValue:l!==void 0}})}}}function f(t,e,r,n,{usedAssert:s,isSoft:i,isNegated:a=!1,matcherSpecific:o={},message:l,softMode:g}){let p=Oe(t,r,n,{...o,isNegated:a},l),d=e();s(a?!d:d,c.getRenderer(t).render(p,c.getConfig()),i,g)}function Oe(t,e,r,n={},s){let i=C(new Error().stack),a=k(i);if(!a)throw new Error("k6 failed to capture execution context");return{executionContext:a,matcherName:t,expected:typeof e=="string"?e:JSON.stringify(e),received:JSON.stringify(r),matcherSpecific:n,customMessage:s}}var Z=class extends m{getMatcherName(){return"toBeCloseTo"}getSpecificLines(e,r){let n=e.matcherSpecific;return[{label:"Expected precision",value:r(n.precision.toString(),"green"),group:3},{label:"Expected difference",value:"< "+r(`${n.expectedDifference}`,"green"),group:3},{label:"Received difference",value:r(n.difference.toString(),"red"),group:3}]}renderMatcherArgs(e){return e("(","darkGrey")+e("expected","green")+e(", ","darkGrey")+e("precision","white")+e(")","darkGrey")}},Q=class extends v{getMatcherName(){return"toBeDefined"}},X=class extends v{getMatcherName(){return"toBeFalsy"}},z=class extends m{getMatcherName(){return"toBeGreaterThan"}getSpecificLines(e,r){return[{label:"Expected",value:"> "+r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3}]}},ee=class extends m{getMatcherName(){return"toBeGreaterThanOrEqual"}getSpecificLines(e,r){return[{label:"Expected",value:">= "+r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3}]}},te=class extends m{getMatcherName(){return"toBeInstanceOf"}getSpecificLines(e,r){return[{label:"Expected constructor",value:r(e.expected,"green"),group:3},{label:"Received constructor",value:r(e.received,"red"),group:3}]}},re=class extends m{getMatcherName(){return"toBeLessThan"}getSpecificLines(e,r){return[{label:"Expected",value:"< "+r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3}]}},ne=class extends m{getMatcherName(){return"toBeLessThanOrEqual"}getSpecificLines(e,r){return[{label:"Expected",value:"<= "+r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3}]}},oe=class extends v{getMatcherName(){return"toBeNaN"}},ie=class extends v{getMatcherName(){return"toBeNull"}},ae=class extends v{getMatcherName(){return"toBeTruthy"}},se=class extends v{getMatcherName(){return"toBeUndefined"}},ce=class extends m{getMatcherName(){return"toEqual"}getSpecificLines(e,r){return[{label:"Expected",value:r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3}]}},pe=class extends m{getMatcherName(){return"toHaveLength"}getSpecificLines(e,r){return[{label:"Expected length",value:r(e.expected,"green"),group:3},{label:"Received length",value:r(e.received,"red"),group:3},{label:"Received array",value:r(e.matcherSpecific?.receivedArray,"red"),group:3}]}},le=class extends m{getMatcherName(){return"toContain"}getSpecificLines(e,r){let n=e.matcherSpecific?.isNegated,s=typeof e.matcherSpecific?.receivedType=="string"?e.matcherSpecific?.receivedType:Array.isArray(JSON.parse(e.received))?"array":"string";return[{label:n?"Expected not to contain":"Expected to contain",value:r(e.expected,"green"),group:3},{label:`Received ${s}`,value:r(e.received,"red"),group:3}]}},ue=class extends m{getMatcherName(){return"toContainEqual"}getSpecificLines(e,r){let n=e.matcherSpecific?.isNegated,s=e.matcherSpecific?.receivedType;return[{label:n?"Expected not to contain equal":"Expected to contain equal",value:r(e.expected,"green"),group:3},{label:`Received ${s}`,value:r(e.received,"red"),group:3}]}},de=class extends m{getMatcherName(){return"toHaveProperty"}getSpecificLines(e,r){let n=e.matcherSpecific?.isNegated,s=e.matcherSpecific?.keyPath,i=e.matcherSpecific?.hasExpectedValue,a=[{label:"Property path",value:r(s,"white"),group:3}];return i?a.push({label:n?"Expected property not to equal":"Expected property to equal",value:r(e.expected,"green"),group:3}):a.push({label:n?"Expected property not to exist":"Expected property to exist",value:"",group:3}),a.push({label:"Received object",value:r(e.received,"red"),group:3}),a}renderMatcherArgs(e){return e("(","darkGrey")+e("keyPath","white")+e(", ","darkGrey")+e("expected?","green")+e(")","darkGrey")}};function B(t,e){if(t===e)return!0;if(t===null||e===null||typeof t!="object"||typeof e!="object")return!1;let r=Object.keys(t),n=Object.keys(e);return r.length!==n.length?!1:r.every(s=>n.includes(s)&&B(t[s],e[s]))}function Me(t,e){if(e==="")throw new Error("Invalid path: empty string");let r=[],n="",s=!1;for(let a=0;a<e.length;a++){let o=e[a];if(o==="."&&!s)n&&(r.push(n),n="");else if(o==="[")n&&(r.push(n),n=""),s=!0;else if(o==="]")if(s)r.push(n),n="",s=!1;else throw new Error(`Invalid path: ${e}`);else n+=o}n&&r.push(n);let i=t;for(let a of r){if(i==null)throw new Error(`Property ${e} does not exist`);if(typeof a=="string"&&!isNaN(Number(a))){let o=Number(a);if(!Array.isArray(i))throw new Error(`Cannot access index ${a} of non-array`);if(o>=i.length)throw new Error(`Index ${a} out of bounds`);i=i[o]}else{if(typeof i!="object")throw new Error(`Cannot access property ${a} of non-object`);if(!Object.prototype.hasOwnProperty.call(i,a))throw new Error(`Property ${a} does not exist on object`);i=i[a]}}return i}function ge(t){return t.replace(/[\u200B\u00AD]/g,"").replace(/\s+/g," ").trim()}function V(t){return{passed:!0,negate(){return I(typeof t.negate=="function"?t.negate():t.negate)}}}function I(t){let e=V({negate:()=>r.detail}),r={passed:!1,detail:t,negate:()=>e};return r}function G(t){if(!t||typeof t!="object")return!1;let e=["clear","isEnabled","isHidden","getAttribute","selectOption","press","type","dispatchEvent","dblclick","setChecked","isDisabled","focus","innerText","inputValue","check","isEditable","fill","textContent","hover","waitFor","click","uncheck","isChecked","isVisible","innerHTML","tap"],r=n=>e.every(s=>s in n);return t!=null&&typeof t=="object"&&r(t)}function Ie(t,e){return e===null?I({type:"expected-received",expected:`Attribute '${t}' to be present`,received:`Attribute '${t}' was not present`}):V({negate(){return{type:"expected-received",expected:`Attribute '${t}' to not be present`,received:`Attribute '${t}' was present`}}})}function Te(t,e,r){return e===null?I({type:"expected-received",expected:`Attribute '${t}' to have value '${r}'`,received:`Attribute '${t}' was not present`}):e!==r?I({type:"expected-received",expected:`Attribute '${t}' to have value '${r}'`,received:`Attribute '${t}' had value '${e}'`}):V({negate(){return{type:"expected-received",expected:`Attribute '${t}' to not have value '${r}'`,received:`Attribute '${t}' had value '${e}'`}}})}async function ke(t,e,r){if(typeof e!="string"||e.trim()==="")throw new TypeError("Attribute name must be a non-empty string");if(r!==void 0&&typeof r!="string")throw new TypeError("Expected attribute value must be a string");if(!G(t))return I({type:"expected-received",expected:"Locator",received:t===null?"null":Array.isArray(t)?"any[]":typeof t});let n=await t.getAttribute(e);return r===void 0?Ie(e,n):Te(e,n,r)}function J(t,e,r,n=!1){let s=e.assertFn??O,i=e.soft??!1,a={timeout:e.timeout,interval:e.interval};c.configure({colorize:e.colorize,display:e.display}),c.register("toBeChecked",new fe),c.register("toBeDisabled",new xe),c.register("toBeEditable",new me),c.register("toBeEnabled",new ye),c.register("toBeHidden",new he),c.register("toBeVisible",new Ee),c.register("toHaveValue",new be);let o={locator:t,retryConfig:a,usedAssert:s,isSoft:i,isNegated:n,message:r,softMode:e.softMode},l=async(p,d,u={},x)=>{let h=C(new Error().stack),E=k(h);if(!E)throw new Error("k6 failed to capture execution context");let L=(y,w)=>{let N=u.ignoreCase!==void 0?new RegExp(y.source,y.flags.replace("i","")+(u.ignoreCase?"i":"")):y,P={executionContext:E,matcherName:p,expected:N.toString(),received:w,matcherSpecific:{isNegated:n},customMessage:r},_=N.test(w);s(n?!_:_,c.getRenderer(p).render(P,c.getConfig()),i,e.softMode)},R=(y,w)=>{let N=ge(y),P=ge(w),_={executionContext:E,matcherName:p,expected:N,received:P,matcherSpecific:{isNegated:n},customMessage:r},we=u.ignoreCase?x(P.toLowerCase(),N.toLowerCase()):x(P,N);s(n?!we:we,c.getRenderer(p).render(_,c.getConfig()),i,e.softMode)};try{await U(async()=>{let y=u.useInnerText?await t.innerText():await t.textContent();if(y===null)throw new Error("Element has no text content");if(d instanceof RegExp){L(d,y);return}R(d,y)},{...a,...u})}catch{let w={executionContext:E,matcherName:p,expected:d.toString(),received:"unknown",matcherSpecific:{isNegated:n},customMessage:r};s(!1,c.getRenderer("toHaveText").render(w,c.getConfig()),i,e.softMode)}};return{get not(){return J(t,e,r,!n)},async toBeChecked(p=a){await T("toBeChecked",async()=>await t.isChecked(),"checked","unchecked",{...o,options:p})},async toBeDisabled(p=a){await T("toBeDisabled",async()=>await t.isDisabled(),"disabled","enabled",{...o,options:p})},async toBeEditable(p=a){await T("toBeEditable",async()=>await t.isEditable(),"editable","uneditable",{...o,options:p})},async toBeEnabled(p=a){await T("toBeEnabled",async()=>await t.isEnabled(),"enabled","disabled",{...o,options:p})},async toBeHidden(p=a){await T("toBeHidden",async()=>await t.isHidden(),"hidden","visible",{...o,options:p})},async toBeVisible(p=a){await T("toBeVisible",async()=>await t.isVisible(),"visible","hidden",{...o,options:p})},toHaveText(p,d={}){return l("toHaveText",p,d,(u,x)=>u===x)},toContainText(p,d={}){return l("toContainText",p,d,(u,x)=>u.includes(x))},async toHaveAttribute(p,d){let u="toHaveAttribute",x=C(new Error().stack),h=k(x);if(!h)throw new Error("k6 failed to capture execution context");let E=c.getRenderer(u),L=c.getConfig();try{await U(async()=>{let R=await ke(t,p,d),y=n?R.negate():R;if(y.passed)return;let w={executionContext:h,matcherName:u,expected:y.detail.expected,received:y.detail.received};s(!1,E.render(w,L),i,e.softMode)},a)}catch{let R={executionContext:h,matcherName:u,expected:"An element matching the locator.",received:`Timeout waiting for element matching locator (${a.timeout}ms)`};s(!1,c.getRenderer(u).render(R,c.getConfig()),i,e.softMode)}},async toHaveValue(p,d=a){let u=C(new Error().stack),x=k(u);if(!x)throw new Error("k6 failed to capture execution context");let h={executionContext:x,matcherName:"toHaveValue",expected:p,received:"unknown",matcherSpecific:{isNegated:n},customMessage:r};try{await U(async()=>{let E=await t.inputValue(),L=p===E;s(n?!L:L,c.getRenderer("toHaveValue").render(h,c.getConfig()),i,e.softMode)},{...a,...d})}catch{s(!1,c.getRenderer("toHaveValue").render(h,c.getConfig()),i,e.softMode)}}}}function Pe(t,e,r,n={},s){let i=C(new Error().stack),a=k(i);if(!a)throw new Error("k6 failed to capture execution context");return{executionContext:a,matcherName:t,expected:e,received:r,customMessage:s,...n}}async function T(t,e,r,n,{locator:s,retryConfig:i,usedAssert:a,isSoft:o,isNegated:l=!1,options:g={},message:p,softMode:d}){let u=Pe(t,r,n,{matcherSpecific:{locator:s,timeout:g.timeout,isNegated:l}},p);try{await U(async()=>{let x=await e(),h=l?!x:x;if(!h)throw new Error("matcher failed");a(h,c.getRenderer(t).render(u,c.getConfig()),o,d)},{...i,...g})}catch{a(!1,c.getRenderer(t).render(u,c.getConfig()),o,d)}}var S=class extends v{getMatcherName(){return`toBe${this.state[0].toUpperCase()}${this.state.slice(1)}`}getReceivedPlaceholder(){return"locator"}getSpecificLines(e,r){return[{label:"Expected",value:this.state,group:3},{label:"Received",value:this.oppositeState,group:3},{label:"Call log",value:"",group:3},{label:"",value:r(`  - expect.toBe${this.state[0].toUpperCase()}${this.state.slice(1)} with timeout ${e.matcherSpecific?.timeout}ms`,"darkGrey"),group:3,raw:!0},{label:"",value:r("  - waiting for locator","darkGrey"),group:3,raw:!0}]}},fe=class extends S{state="checked";oppositeState="unchecked"},xe=class extends S{state="disabled";oppositeState="enabled"},me=class extends S{state="editable";oppositeState="uneditable"},ye=class extends S{state="enabled";oppositeState="disabled"},he=class extends S{state="hidden";oppositeState="visible"},Ee=class extends S{state="visible";oppositeState="hidden"},be=class extends m{getMatcherName(){return"toHaveValue"}getSpecificLines(e,r){return[{label:"Expected",value:r(e.expected,"green"),group:3},{label:"Received",value:r(e.received,"red"),group:3},{label:"Call log",value:"",group:3},{label:"",value:r(`  - expect.toHaveValue with timeout ${e.matcherSpecific?.timeout}ms`,"darkGrey"),group:3,raw:!0},{label:"",value:r("  - waiting for locator","darkGrey"),group:3,raw:!0}]}};async function U(t,e={}){let r=e.timeout??D.timeout,n=e.interval??D.interval,s=e._now??(()=>Date.now()),i=e._sleep??(o=>new Promise(l=>setTimeout(l,o))),a=s();for(;s()-a<r;){try{return await t(),!0}catch{}await i(n)}throw new ve(`Expect condition not met within ${r}ms timeout`)}var ve=class extends Error{constructor(e){super(e),this.name="RetryTimeoutError"}};var Ae=Ce();function Ce(t){let e=$.load(t);return Object.assign(function(r,n){return G(r)?J(r,e,n):j(r,e,n)},{soft(r,n){return G(r)?J(r,{...e,soft:!0},n):j(r,{...e,soft:!0},n)},configure(r){return Ce(r)},get config(){return{...e}}})}export{M as colorize,Ae as expect};
//# sourceMappingURL=index.js.map
